<?xml version="1.0"?>
<kb_documents>
<kb_document>
<kb_title>Introduction to Stata: Using Stata</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p>This article will introduce you to Stata and its core concepts. It has three goals:</p>
<p>First, to prepare you for the rest of SSCC's Data-Centered Research Using Stata curriculum. All the other sections will rely on the concepts and syntax you'll learn in this section.</p>
<p>Second, to prepare you to excel in research methods and applied statistics courses that use Stata. You'll go in already knowing how Stata works and why it does what it does, so you can focus on learning the material for the course.</p>
<p>Third, to teach you how to make your work reproducible right from the beginning, so you never have to unlearn any bad habits.</p>
<p>The primary intended audience for this article is new graduate students, but anyone who wants to learn how to use Stata for research will benefit. If your goal is to learn just enough Stata to get you through a particular course consider reading <a href="https://ssc.wisc.edu/sscc/pubs/sfs/">Stata for Students</a> instead.</p>
<p>There are two different approaches one can take to Stata. One is to use it as an interactive tool: you start Stata, load your data, and start typing or clicking on commands. This can be a good way to explore your data, figure out what you want to do, and check that your programs worked properly. It can also be useful when you're trying to learn something new because you get immediate feedback. However, interactive work cannot be easily or reliably reproduced, or modified if you change your mind. It's also very difficult to recover from mistakes—there's no "undo" command in Stata.</p>
<p>The other approach is to treat Stata as a programming language. In this approach you write your programs, called do files, and run them. A do file contains the same commands you'd type in interactive Stata, but since they're written in a permanent file they can be debugged or modified and then rerun at will. They also serve as an exact record of how you obtained your results—a lab notebook for the social scientist. Any work you intend to publish or present should be done using do files. Thus this series will for the most part ignore Stata's graphical user interface and prepare you to write do files for research.</p>
<p>To get the most out of Introduction to Stata you need to be an active participant. Put this article in one window, and open Stata in another. Type and run the example code yourself. This will help you retain it, and ensure you get all the details right—Stata is always happy to tell you when you're wrong. Do the exercises (some are straightforward applications of what you just learned; others require more creativity). Using Stata is not something you read and understand—it's a skill you must practice.</p>
<p>Introduction to Stata includes the following sections:</p>
<ul>
<li><a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata1.htm">Using Stata</a></li>
<li><a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata2.htm">Structure of a Stata Data Set</a></li>
<li><a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata3.htm">Elements of Stata Syntax</a></li>
<li><a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata4.htm">Do Files</a></li>
<li><a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata5.htm">Statistics</a></li>
<li><a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata6.htm">Creating and Changing Variables</a></li>
</ul>
<h2>Running Stata at the SSCC</h2>
<p>The SSCC makes Stata available on Winstat, in our computer labs, on Linstat, and on our HTCondor flock. For details about the capabilities of the SSCC's servers see <a href="https://ssc.wisc.edu/sscc/pubs/computing_resources.htm">Computing Resources at the SSCC</a>. UW-Madison students, faculty, and staff can also download Stata from the <a href="http://software.wisc.edu">Campus Software Library</a> and install it on their own computers.</p>
<h3>Stata SE vs. Stata MP</h3>
<p>For most people the standard version of Stata, Stata SE, works just fine. But SSCC makes Stata MP available for those who need to run computationally demanding jobs. Stata MP splits its work among up to 32 cores, which speeds up some tasks substantially. You can run a do file using Stata MP on Winstat by right-clicking on it and choosing <span class="MenuOutput">Execute StataMP Batch Mode</span>. On Linstat Stata MP is the default. <a href="https://ssc.wisc.edu/sscc/pubs/stata_mp.htm">Running Stata/MP at the SSCC</a> has details.</p>
<h3>Windows vs. Linux</h3>
<p>Stata looks and acts the same whether it's running on Windows or Linux (or on a Mac). However, Linstat (the SSCC's Linux computing cluster) has much more memory than Winstat or a personal computer, and is better suited for long jobs. Running Stata jobs on Linstat is probably easier than you think: read <a href="https://ssc.wisc.edu/sscc/pubs/linstat.htm">Using Linstat</a> to learn how.</p>
<h2>Running Stata</h2>
<p>To start Stata on Winstat or another Windows computer, type Stata in the search box next to the Windows Logo button, or click on the button and find Stata in the programs list. On Linstat, type <span class="InputCode">xstata</span>.</p>
<h2>Stata's User Interface</h2>
<p>When you start up Stata, the first thing you'll see is the main user interface window:</p>
<img alt="" class="CenterImage" height="527" src="https://ssc.wisc.edu/sscc/pubs/intro_stata/stata_gui.png" width="750"/>
<p> </p>
<p>The central section is the Results window, where you'll see the results of the commands you run. Under it is the Command window where you'll type those commands (when you're not running a do file).</p>
<p> On the left is the Review window, which contains a list of the commands you've run. Click once on a command to paste it back into the Command window for editing. Double-click on a command to run it again. You can also press <span class="InputCode">Page Up</span> to recall a past command to the Command window. Right-click on a command or block of commands to copy it into the clipboard or send it to the Do File editor. This allows you to take something you've done interactively and keep it as part of a do file.</p>
<p>Beneath the Review window Stata displays the working directory. This is where Stata will  save files if you don't specify another location.</p>
<p>On the right is the Variables windows, which contains a list of the variables contained in the data set you are using. Click once on a variable name to select it, and information about the variable will be shown in the Properties window on the bottom right. Click twice, and the variable name will be pasted into the command window. You can also start typing a variable name in the Command window and press <span class="InputCode">Tab</span>, and Stata will either complete the variable name or give you a list of variables that match what you've typed so far.</p>
<p>The Properties window also gives properties of the data set. One to keep an eye on is the size, or how much memory it requires. Stata must load your entire data set into memory.  Modern computers have such large amounts of memory that most Stata users never have to worry about it, but users of big data must make sure they don't run out. If you try to use more memory than your computer has the operating system will use disk space as memory and Stata will become so slow that it's practically unusable.</p>
<p>If a command is running, the button on the far right of the top toolbar will turn stop-sign red. Clicking it will tell Stata to stop what it's doing—though it may take some time to notice. Pressing <span class="InputCode">q</span> will do the same thing.</p>
<p>The menus above the toolbar give you access to most of Stata's commands, but you'll work much faster if you type them. Importing data in non-Stata formats is one exception, because the graphical user interface for doing so gives you a preview of the data that you can use to figure out the correct options for importing it. Another is graphs, because there are so many options for graphs that setting them using the graphical user interface is a good alternative to memorizing them. When you do something using the menus, Stata will craft a command based on what you chose and add it to the history just as if you'd typed it. You can then paste the command into a do file.</p>
<p>Next: <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata2.htm">Structure of a Data Set</a></p>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url>https://ssc.wisc.edu/sscc/pubs/intro_stata/stata_gui.png</img_base_url>
</kb_document>
<kb_document>
<kb_title>Introduction to Stata: Structure of a Data Set</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p class="intro">This is part two of Introduction to Stata. If you're new to Stata we highly recommend starting from the <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata1.htm">beginning</a>.</p>
<p>The 'auto' data set contains information about 1978 cars and has been included with Stata for many, many years. Every Stata user has access to it so it is frequently used for examples, just as we'll use it today. To load it, type:</p>
<p class="InputCode">sysuse auto</p>
<p>Normally the <span class="InputCode">use</span> commands loads data from disk into memory. The <span class="InputCode">sysuse</span> command is a variation of the normal <span class="InputCode">use</span> command which loads data that was installed with Stata. You'll probably never use it for anything other than this data set. (There's also a <span class="InputCode">webuse</span> command that opens example data sets from Stata's web site.) To see what's in the data set, type:</p>
<p class="InputCode">browse</p>
<p>or click the button that looks like a magnifying glass over a spreadsheet. This opens Stata's Data Editor, which shows you your data set in a spreadsheet-like form, in browse mode. You can also invoke the Data Editor by typing <span class="InputCode">edit</span> or clicking the button that looks like a pencil writing in a spreadsheet, and then it will allow you to make changes. You might use edit mode for data entry, but since you should <em><strong>never</strong></em> change your data interactively get in the habit of using browse mode so you don't make changes by accident.</p>
<h2>Observations and Variables</h2>
<p>A Stata data set is a matrix, with one row for each observation and one column for each variable. This raises the question "What is an observation in this data set?" The values of the <span class="InputCode">make</span> variable suggests they are cars, but are they individual cars or kinds of cars? The fact that there is just one row for each value of <span class="InputCode">make</span> suggests kinds of cars. We'll discuss this much more in <a href="https://ssc.wisc.edu/sscc/pubs/dws/data_wrangling_stata1.htm">Data Wrangling in Stata</a>, but you should always know what an observation is in your data set.</p>
<h2>Variable Types</h2>
<p>The variable <span class="InputCode">make</span> contains text or, as Stata calls them, "strings" (as in strings of characters). Obviously you can't do math with text, but Stata can do many other useful things with string variables.</p>
<p>Variables like <span class="InputCode">price</span> and <span class="InputCode">mpg</span> are <em>continuous</em> or <em>quantitative</em> variables. They can, in principle, take on an infinite number of values (though they've been recorded as integers) and represent quantities in the real world.</p>
<p>The variable <span class="InputCode">rep78</span> is a <em>categorical</em> variable. It can only take on certain values, or <em>levels</em>. It is an <em>ordered</em> categorical variable because 5 is better than 4, 4 is better than 3, etc. But they don't represent actual quantities: a 5 is not five times better than a 1. Other categorical variables are <em>unordered</em>, and in that case the numbers used to represent the categories are completely arbitrary.</p>
<p>The variable <span class="InputCode">foreign</span> is an <em>indicator</em> or <em>binary</em> or <em>dummy</em> variable. Indicator variables are just categorical variables with two levels.</p>
<h2>Value Labels</h2>
<p>The foreign variable appears to contain text, like <span class="InputCode">make</span>. But note that it's a different color, and if you click on a cell in that column what appears at the top of the browser is a 0 or a 1. This tells you <span class="InputCode">foreign</span> is really an numeric variable with a set of value labels applied. Comparing the numbers at the top with the words in the table, you'll see that this set of value labels associates the number 0 with the word "Domestic" and the number 1 with the word "Foreign." We'll talk about creating value labels in <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata6.htm">Creating and Changing Variables</a>. But for now, the important thing to remember is that if you write code referring to the <span class="InputCode">foreign</span> variable, it must use the values 0 and 1, not the labels "Domestic" and "Foreign."</p>
<p>Note that a 1 means "Yes, this car is foreign" and a 0 means "no, this car is not foreign." Stata generally uses 1 for true and 0 for false, and if you follow that convention indicator variables will be clear even without value labels.</p>
<p></p>
<h2>Missing Values</h2>
<p>Several cars have a dot in the <span class="InputCode">rep78</span> column rather than numbers. These indicate missing values. A Stata data set is a rectangular matrix, so every observation must have something for every variable. If no actual data are available, Stata stores a code for "missing." While this data set just uses "generic" missing values, there are 26 others you can use:<span class="InputCode">.a</span> through <span class="InputCode">.z</span>. Stata treats them all the same, but you can assign meanings to them. For example, if you were working with a survey you might decide to code "the question did not apply" as <span class="InputCode">.a</span> and "the respondent refused to answer" as <span class="InputCode">.b</span>.</p>
<p>Next: <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata3.htm">Elements of Stata Syntax</a></p>
<div></div>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>Introduction to Stata: Elements of Stata Syntax</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p><span class="intro">This is part three of Introduction to Stata. If you're new to Stata we highly recommend starting from the <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata1.htm">beginning</a>.</span></p>
<p>If you haven't already, load the automobile data set that comes with Stata by running:</p>
<p class="InputCode">sysuse auto</p>
<h2>Elements of Stata Syntax</h2>
<p>Almost all Stata commands use a standard  syntax. This syntax allows you to control what part of the data set the command acts on, modify what the command does, and more.</p>
<p>We'll discuss five syntax elements:</p>
<ul>
<li><em>Commands</em></li>
<li><em>Variable Lists</em></li>
<li><em>If Conditions</em></li>
<li><em>Options</em></li>
<li><em>By Groups</em> </li>
</ul>
<h2>Stata Commands</h2>
<p>Stata is a command-based language. Most Stata commands are verbs. They tell Stata to do something: <span class="InputCode">summarize</span>, <span class="InputCode">tabulate</span>, <span class="InputCode">regress</span>, etc. Normally the command itself comes first and then you tell Stata the details of what you want it to do after.</p>
<p>Many commands can be abbreviated: <span class="InputCode">sum</span> instead of <span class="InputCode">summarize</span>, <span class="InputCode">tab</span> instead of <span class="InputCode">tabulate</span>, <span class="InputCode">reg </span>instead of <span class="InputCode">regress</span>. Commands that can destroy data, like <span class="InputCode">replace</span>, cannot be abbreviated. </p>
<p>We'll explore the elements of Stata syntax using a command that makes it easy to see what they do:</p>
<p class="InputCode">browse</p>
<p>The <span class="InputCode">browse</span> command opens the Data Editor in browse mode, which is what you should always use unless you're doing data entry. Browse mode won't let you accidentally change your data.</p>
<p>Looking at your data is a great way to get a basic understanding of it, but even with this small data set you can't see all of it. The key to using the data browser effectively is being able to view the parts of the data set you care about, and the next two syntax elements will help us do that.</p>
<h2>Variable Lists</h2>
<p>Listing one or more variables after a command tells the command it should only act on the variables listed:</p>
<p class="InputCode">browse make<br/>
                  browse make price mpg
                </p>
<p>There are shortcuts for creating long lists of variables without typing them all, or variable lists containing variables that match a pattern, but we'll discuss them in <a href="https://ssc.wisc.edu/sscc/pubs/dws/data_wrangling_stata1.htm">Data Wrangling in Stata</a>.</p>
<p><strong>Exercise: browse the <span class="InputCode">make</span> and <span class="InputCode">weight</span> of each car.</strong></p>
<h2>If Conditions</h2>
<p>An <em>if condition</em> tell a command which observations it should act on. It will only act on those observations where the condition is true. This allows you to do things with subsets of the data. An if condition comes after a variable list:</p>
<p class="InputCode">browse make foreign if foreign==1
                </p>
<p>Note the two equals signs! In Stata you use one equals sign when you're setting something equal to something else (see <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata6.htm">Creating and Changing Variables</a>) and two equals signs when you're asking if two things are equal. Other operators you can use are:</p>
<table border="0">
<tr>
<td>==</td>
<td>Equal</td>
</tr>
<tr>
<td>&gt;</td>
<td>Greater than</td>
</tr>
<tr>
<td>&lt;</td>
<td>Less than</td>
</tr>
<tr>
<td>&gt;=</td>
<td>Greater than or equal to</td>
</tr>
<tr>
<td>&lt;=</td>
<td>Less than or equal to</td>
</tr>
<tr>
<td>!=</td>
<td>Not equals</td>
</tr>
</table>
<p>! all by itself means "not" and reverses whatever condition follows it. </p>
<p>Internally, Stata equates true and false with one and zero. That means you can write:</p>
<p class="InputCode">browse make foreign if foreign </p>
<p>or:</p>
<p class="InputCode">browse make foreign if !foreign </p>
<p>This makes for simple and readable code. Just be careful: anything other than zero will also be interpreted as true, including missing.</p>
<h3>Combining Conditions</h3>
<p>You can combine conditions with <span class="InputCode">&amp;</span> (logical and) or <em class="InputCode">|</em> (logical or). The character used for logical or is called the "pipe" character and you type it by pressing <span class="InputCode">Shift-Backslash</span>, the key right above <span class="InputCode">Enter</span>. Try: </p>
<p class="InputCode">browse make price mpg if mpg&gt;25 &amp; price&lt;5000<br/>
</p>
<p>This shows you cars that get more than 25 miles per gallon <em>and</em> cost less than $5000 (in 1978 dollars). In set theory terms it is the intersection of the two sets. Now try:</p>
<p class="InputCode">browse make price mpg if mpg&gt;25 | price&lt;5000 </p>
<p>This shows you cars that get more than 25 miles per gallon <em>or</em> cost less than $5000. A car must meet only one of the two conditions to be shown. In set theory terms it is the union of the two sets.</p>
<p>All the conditions to be combined must be complete. If you wanted to list the cars that have a 1 or a 2 for <span class="InputCode">rep78</span> you should <em>not</em> use:</p>
<p class="InputCode">browse make rep78 if rep78==1 | 2 </p>
<p>(Why this does what it does is left as an exercise for the reader, but it's not what you want.) Instead you should use:</p>
<p class="InputCode">browse make rep78 if rep78==1 | rep78==2</p>
<h3>Missing Values</h3>
<p>If you have missing values in your data, you need to keep them in mind when writing if conditions. Internally, missing values are stored using the 27 largest possible numbers, starting with the generic missing value (<span class="InputCode">.</span>) and the extended missing values (<span class="InputCode">.a</span>, <span class="InputCode">.b</span>, etc.) after that in alphabetical order, so the following inequalities hold:</p>
<p><em>any observed value</em> &lt; <span class="InputCode">.</span> &lt; <span class="InputCode">.a</span> &lt; <span class="InputCode">.b</span> &lt; <span class="InputCode">.c</span> ... &lt; <span class="InputCode">.x </span>&lt; <span class="InputCode">.y</span> &lt; <span class="InputCode">.z</span></p>
<p>If you want a list of cars that are known to have good repair records, you won't get it with:</p>
<p class="InputCode">browse make rep78 if rep78&gt;3</p>
<p>An easy shortcut is to think of missing values as (positive) infinity, and since infinity is greater than 3 cars with a missing value for <span class="InputCode">rep78</span> are included in the list. So add a second condition to exclude them:</p>
<p class="InputCode">browse make rep78 if rep78&gt;3 &amp; rep78&lt;.</p>
<p>Why <span class="InputCode">&lt;.</span> rather than <span class="InputCode">!=.</span> ? In this data set it makes no difference. But if the data set included extended missing values, the condition <span class="InputCode">!=.</span> would not exclude them. The condition <span class="InputCode">&lt;.</span> excludes them because extended missing values are greater than the generic missing value. Thus using <span class="InputCode">&lt;.</span> ensures you're excluding all missing values.</p>
<p><strong>Exercise: Browse domestic cars that get more than 25 miles per gallon and are known to have good repair records (<span class="InputCode">rep78</span> greater than 3). Then browse foreign cars that cost less than $5,000 and are not known to have poor repair records (<span class="InputCode">rep78</span> less than or equal to 3). Include the variables used in the conditions so you can spot-check your results. Explain why you handled missing values the way you did in both cases.</strong></p>
<h2>Options</h2>
<p>Options change how a command works. They go after any variable list or if condition, following a comma. The comma means "everything after this is options" so you only type one comma no matter how many options you're using.</p>
<p>Consider:</p>
<p class="InputCode">browse make foreign</p>
<p>We know that value labels have been applied to the <span class="InputCode">foreign</span> variable, so the words "Domestic" and "Foreign" are not the actual values. We can see the values instead of the labels by adding the <span class="InputCode">nolabel</span> option:</p>
<p class="InputCode">browse make foreign, nolabel</p>
<p>Options must always be one word. Here the words "no" and "label" are combined because otherwise Stata would think they were two different options.</p>
<p>Many options require additional information, such as a number or a variable they apply to. This additional information goes in parentheses directly after the option name. To illustrate that we need to use a command other than <span class="InputCode">browse</span>, because <span class="InputCode">nolabel</span> is the only option it has.</p>
<p>The <span class="InputCode">list</span> command is very simlar to <span class="InputCode">browse</span>, but it just lists the data in the Results window. If you have a log open the list output will be stored in the log, which is sometimes useful. Try:</p>
<p class="InputCode">list make</p>
<p>The <span class="InputCode">string()</span> option tells the <span class="InputCode">list</span> command to truncate string variables after a given number of characters, with the number going in the parentheses:</p>
<p class="InputCode">list make, string(5)<br/>
</p>
<p>You might use the <span class="InputCode">string()</span> option to save space, or if the first part of the string contains all the information you really need. But it's mostly here as an example of the "additional information goes in parentheses" syntax you'll use regularly.</p>
<p>Stata reuses option names wherever it makes sense. Thus many commands take a <span class="InputCode">nolabel</span> option that prompts them to ignore value labels. Other common options include <span class="InputCode">gen()</span> to create a new variable (with the name of the new variable going in parentheses),  <span class="InputCode">by()</span> to act on groups, and <span class="InputCode">vce()</span> to tell regression commands how to estimate the variance-covariance matrix.</p>
<h2>By Groups</h2>
<p><em>By groups</em> allows you to execute a command separately for subgroups within your data. Try:</p>
<p class="InputCode">by foreign: list make</p>
<p>The <span class="InputCode">by foreign:</span> prefix tells Stata to:</p>
<ol>
<li>Identify the unique values of <span class="InputCode">foreign</span> (in this case, 0 and 1 or "Domestic" and "Foreign")</li>
<li>Temporarily split the data set into groups based on their value of <span class="InputCode">foreign</span></li>
<li>Run the subsequent command (<span class="InputCode">list make</span>) separately for each group</li>
</ol>
<p>You'll see how powerful <em>by</em> is later.</p>
<p>In order for <em>by</em> to work, the data must be sorted by the same variable. You can do that with the <span class="InputCode">sort</span> command:</p>
<p class="InputCode">sort rep78<br/>
                by rep78: list make</p>
<p> Alternatively, you can have <em>by</em> do this for you either by adding the <span class="InputCode">sort</span> option to the <em>by</em> prefix or just saying <span class="InputCode">bysort</span>:</p>
<p class="InputCode">by rep78, sort: list make<br/>
                  bysort rep78: list make
                </p>
<p>Of course we don't need to have Stata sort the data three times. Once the data are  sorted, you can just say:</p>
<p class="InputCode">by rep78: list make</p>
<p>You can have more than one variable in the by list. In that case, Stata will split the data set up into one group for each unique combination of the variables. The data set must still be sorted in the same order.</p>
<p>Next: <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata4.htm">Do Files</a></p>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>Introduction to Stata: Do Files</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p><span class="intro">This is part four of Introduction to Stata. If you're new to Stata we highly recommend starting from the <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata1.htm">beginning</a>.</span></p>
<p>Do files are simply text files whose names end with <span class="InputCode">.do</span> and
                which contain Stata commands. Sometimes people call them programs, though Stata uses this term for something else.</p>
<p></p>
<p>Working in Stata involves three different things: the <em>commands</em> you run, the <em>data</em> they act on, and the <em>results</em> they produce. A properly written do file manages all three. It contains all the commands needed to carry out its work. It loads the appropriate data and saves new versions of the data when needed. And it stores all the results in a permanent log file. </p>
<p>Do files are the key to reproducibility: a properly written do file (or set of do files) will reproduce your research at will. But they also make working with Stata much more efficient. At the most basic level, writing a do file ensures you can quit for the night and pick up where you left off the next day without having to start over. If you change your mind about what you want to do, simply change the do file and run it again. If you find you've made a mistake, fix it in the do file and run it again.</p>
<p>Start the Do File Editor by clicking on the button that looks like a pencil writing in a notebook or by typing <span class="InputCode">doedit</span>.</p>
<h2>Anatomy of a Do File</h2>
<p>Almost all do files carry out the same basic steps.</p>
<h3>Create a Log File to Store Results</h3>
<p>The first thing your do file should do is set up a log file which will store its results. Make sure that no previous log files are still open with:</p>
<p class="InputCode">capture log close</p>
<p>This is important because if your do file crashes before it gets to the command to close its log at the end, it will leave the log file open.</p>
<p> The <span class="InputCode">capture</span> prefix tells Stata to ignore any error messages the following command produces. In this case, we use it because we want the do file to proceed whether there's an open log to close or not.</p>
<p>Then open a new log file. We suggest giving a log file the same name as the do file whose results it records, so there's never any confusion about which log goes with which do file. To give your do file a name, press <span class="InputCode">Ctrl-s</span> or click <span class="MenuOutput">File</span>, <span class="MenuOutput">Save as</span> and call it <span class="InputCode">first.do</span>, being sure to save it in Stata's working directory (the one in the lower left corner of the main Stata window). Then go back to the do file itself and type:</p>
<p class="InputCode">log using first.log, replace</p>
<p>The <span class="InputCode">replace</span> option tells Stata it's okay to replace previous versions of that file. Specifying the <span class="InputCode">.log</span> extension tell Stata you want a plain text log, which can be used by many programs.</p>
<h3>Clear Stata's Memory</h3>
<p>Another key to reproducibility is always starting with a blank slate, so the next command should be:</p>
<p class="InputCode">clear all</p>
<p>This clears out any data or stored results from whatever you were doing before running this do file.</p>
<h3>Open a Data Set</h3>
<p>In general, you'll load data with the <span class="InputCode">use</span> command. However, since we're using the auto data set that comes with Stata, you'll open it with <span class="InputCode">sysuse</span>:</p>
<p class="InputCode">sysuse auto</p>
<p>Every time you run this do file, it will load a fresh copy of the data from disk into memory. This means you don't have to worry about  any mistakes you might have made previously or keep track of the current state of data set in general.</p>
<h3>Do Your Work</h3>
<p>You're now ready to do your work. For now just add:</p>
<p class="InputCode">list make if foreign</p>
<p>Of course real do files will have many more (and much more useful) commands at this point.</p>
<h3>Save your Data</h3>
<p>Do files that carry out data wrangling will change the data set, and need to save the new version of the data at the end. This do file does not change the data, but save it anyway for practice:</p>
<p class="InputCode">save autoV2, replace</p>
<p>The <span class="InputCode">replace</span> option again  allows Stata to overwrite the output from previous attempts to run the do file.</p>
<p><strong>Never, ever save your output data set over your input data set. </strong>(In other words, the starting <span class="InputCode">use</span> command and the ending <span class="InputCode">save</span> command should never act on the same file.) If you do, the data set your do file was written to work with will no longer exist. The do file may not run at all, and if it does it most likely won't give the same results. If it turns out you made a mistake, you may have to go back to your raw data and start over.</p>
<h3>Close your Log</h3>
<p>The last line of the do file will normally be:</p>
<p class="InputCode">log close</p>
<p>If you don't close the do file's log, any commands you run after the do file finishes will be recorded in the the log. This includes if your do file crashes before reaching the <span class="InputCode">log close</span> command (hence <span class="InputCode">capture log close</span> at the beginning).</p>
<h2>Running a Do File</h2>
<p>The easiest way to run a do file is to press <span class="InputCode">Ctrl-d</span> in the Do File Editor, or click the icon on the far right that looks like a "play" button over some code. If you first select just part of the do file then only that part will be run.</p>
<p> Running parts of your code rather than the entire do file can be useful, but code taken out of context won't always work. For example, if you run a command that creates a variable <span class="InputCode">x</span>, realize you made a mistake, and then fix it, you can't simply select the command that creates <span class="InputCode">x</span> and run it again because <span class="InputCode">x</span> already exists. You could drop the existing version of <span class="InputCode">x</span>, but that step that won't be part of your final do file. Running the entire do file will eliminate this problem because it reloads the data from disk every time. If you find yourself getting confused by these kinds of issues, run the entire do file rather than a selection.</p>
<p>You can also tell Stata to run a do file with the <span class="InputCode">do</span> command followed by the name of the do file to run. This means do files can run other do files. For complicated projects it can be very helpful to have a master do file that runs all the other do files in the proper sequence.</p>
<h2>Output Files</h2>
<p>Because you did not tell Stata where to put <span class="InputCode">first.log</span> or <span class="InputCode">autoV2.dta</span>, Stata saved them in its working directory (the directory in the lower left corner of the main Stata window). Go to that location and open the <span class="InputCode">first.log</span> file and you should see everything that your do file put in the Results window, but stored as a permanent file. While <span class="InputCode">autoV2.dta</span> is just a copy of <span class="InputCode">auto.dta</span>, if your do file had improved the data set the new version would be ready for use as the input for your next do file.</p>
<h2>How long should a do file be?</h2>
<p>For data preparation work, it's easy to "daisy-chain" do files: <span class="InputCode">dofile1</span> loads <span class="InputCode">dataset1</span>, modifies it, and saves it as <span class="InputCode">dataset2</span>; <span class="InputCode">dofile2</span> loads <span class="InputCode">dataset2</span>, modifies it, and saves it as <span class="InputCode">dataset3</span>, etc. When you're done, a master do file can run them all. Thus there's very little downside to breaking up one long do file into two or more short do files. Our suggestion is that you keep your do files short enough that when you're working on one of them you can easily wrap your head around it. You also want to keep do files short so they run as quickly as possible: working on a do file usually requires running it repeatedly, so moving any code that you consider "done" to a different do file will save time.</p>
<h2>Comments</h2>
<p>Comments are  text included in a do file for the benefit
                  of human readers, not for Stata. Comments can explain what the do file does and why, and if
                  anyone else ever needs to read and understand your do file they'll be very grateful for good comments. But <em>you</em> are the most likely beneficiary of your comments, when you have to figure out how your do file works months or years after writing it.</p>
<p>You don't need to comment every command—most Stata
                  code is fairly easy to read. But be sure to comment any code 
                  that required particular cleverness to write, or you'll need to be just as clever to figure out what it does later.</p>
<p>Comments need to be marked as such so that Stata will not try to execute them. <span class="InputCode">/*</span> means Stata should ignore everything until it sees <span class="InputCode">*/</span>, while <span class="InputCode">//</span> means Stata should ignore the rest of that line. Here's an example of commenting code:</p>
<p class="InputCode">// make a list of cars I might be interested in buying<br/>
                  list make price mpg rep78 if price&lt;4000 | (price&lt;5000 &amp; rep78&gt;3 &amp; rep78&lt;.)<br/>
                  /* <br/>
                  Note:<br/>
                  Some cars will appear on the list even though they have<br/>
                  a missing value for rep78.<br/>
                  This is not an error.<br/>
                  If their price is less than $4,000 I don't care about their<br/>
                  repair record.<br/>
                  */</p>
<p>A useful programmer's trick is to "comment out" code you don't want to run right now but don't want to delete entirely. For example, if you temporarily wanted to focus on just the cars that meet the <span class="InputCode">price&lt;4000</span> condition, you could change that command to:</p>
<p class="InputCode">list make price mpg rep78 if price&lt;4000 // | (price&lt;5000 &amp; rep78&gt;3 &amp; rep78&lt;.) </p>
<p>When you're ready to return to the original command, just remove the comment markers.</p>
<p>Three forward slashes (<span class="InputCode">///</span>) means that the current command is continued on the next line. This allows you to break up commands over multiple lines for readability:</p>
<p class="InputCode">list make price mpg rep78 ///<br/>
<span class="indent3">if price&lt;4000 | (price&lt;5000 &amp; rep78&gt;3 &amp; rep78&lt;.)</span></p>
<p>From now on we'll do everything using do files.</p>
<p>Next: <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata5.htm">Statistics</a></p>
<div></div>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>Introduction to Stata: Statistics</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p><span class="intro">This is part five of Introduction to Stata. If you're new to Stata we highly recommend starting from the <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata1.htm">beginning</a>.</span></p>
<p>In this section we'll discuss two of the most basic and useful statistical commands. You can do a great deal of valuable work with these commands, but our primary goal will be to help you understand how the syntax elements you learned earlier can be combined with statistical commands to do analysis.</p>
<p>Start by creating a do file that loads the <span class="InputCode">auto</span> data set:</p>
<p class="InputCode">capture log close<br/>
                  log using stats.log, replace<br/>
<br/>
                  clear all<br/>
                  sysuse auto
                </p>
<h2>Summary Statistics for Continuous Variables                </h2>
<p><span class="InputCode">summarize</span> (<span class="InputCode">sum</span>)
                  gives you summary statistics which will help you understand the distribution of continuous (quantitative) variables . If you just run:</p>
<p class="InputCode">sum</p>
<p>you will get basic summary statistics for all the variables in
                  your data set. Note
                  that there is nothing for <span class="InputCode">make</span>:
                  it is a string variable so summary statistics don't make sense. Also note that for <span class="InputCode">rep78</span> the number of observations is 69 rather than 74. That's because  five missing values were ignored and the summary statistics calculated over the remaining 69 values of <span class="InputCode">rep78</span>. Most statistical commands take a similar approach to missing values and that's usually what you want, so you rarely have to include special handing for missing values in statistical commands. </p>
<p>On the other hand, <span class="InputCode">rep78</span> is a categorical variable, so these summary statistics don't make a lot of sense for it. </p>
<p>All the syntax elements you learned earlier also work with statistical commands. To get summary statistics for just <span class="InputCode">mpg</span>, give <span class="InputCode">sum</span> a <em>varlist</em>:</p>
<p class="InputCode">sum mpg</p>
<p> If you want summary statistics for just the foreign cars, add an <em>if</em> condition:</p>
<p class="InputCode">sum mpg if foreign</p>
<p>If you want summary statistics of <span class="InputCode">mpg</span> for both foreign and domestic cars,  calculated separately, use <em>by</em>:</p>
<p class="InputCode">by foreign: sum mpg</p>
<p>This is one way to compare the two groups.</p>
<p>The <span class="InputCode">detail</span> (<span class="InputCode">d</span>) <em>option</em> will give more information.
                  Try:</p>
<p class="InputCode">sum mpg, detail</p>
<p>Now run your do file by pressing <span class="InputCode">Ctrl-d</span> or clicking the button in the upper right corner that looks like a "play" button and examine the results.</p>
<p><strong>Exercise: Compare the mean price of cars that get more than 25 miles per gallon with the mean price of cars that get 25 miles per gallon or less. Does this mean American consumers in 1978 considered high gas mileage a negative characteristic?</strong></p>
<h2>Frequencies for Categorical Variables</h2>
<p><span class="InputCode">tabulate</span> (<span class="InputCode">tab</span>)
           	    will create tables of frequencies, which will help you understand the distribution of categorical variables. It can also be useful for string variables that describe categories or groups. </p>
<p>If you give <span class="InputCode">tab</span> a <em>varlist</em> with one variable it will give you a one-way table, while if you give it two variables it will give you a two-way table (i.e. crosstabs). To get an idea of what <span class="InputCode">tab</span> does, try:</p>
<p class="InputCode">tab rep78<br/>
                  tab rep78 foreign</p>
<p>Tables are usually easier to read if the variable with the most
                unique values comes first, so they're listed vertically.</p>
<p></p>
<p>The <span class="InputCode">tab</span> command won't accept more
                  than two variables, but you can also focus on one group at a time by adding an if condition:</p>
<p class="InputCode">tab headroom rep78 if foreign</p>
<p> You can also use by, but the results are often hard to read.</p>
<p>The <span class="InputCode">tab</span> command has a rich set of  useful options:</p>
<p></p>
<p>Note that the missing values of <span class="InputCode">rep78</span> were not included in the table, which makes it easy to forget they're there. Add them with the <span class="InputCode">missing</span> option:</p>
<p class="InputCode">tab rep78, missing</p>
<p>By default <span class="InputCode">tab</span> will show value labels, but you can override this with the <span class="InputCode">nolabel</span> option. A quick and easy way to find the values underneath the labels is to run two tab commands, one without <span class="InputCode">nolabel</span> and one with it:</p>
<p class="InputCode">tab foreign<br/>
                  tab foreign, nolabel
                </p>
<p>The <span class="InputCode">label list</span> command will give you that information in a form that's much easier to read—unless your data set has a large number of labels (as many do). Then you need to know the name of the label set that was associated with variable, in this case <span class="InputCode">origin</span>:</p>
<p class="InputCode">label list origin</p>
<p>To get percentages, add the <span class="InputCode">row</span>, <span class="InputCode">column</span>, or <span class="InputCode">cell</span> options:</p>
<p class="InputCode">tab rep78 foreign, row column cell</p>
<p>For this table, <span class="InputCode">row</span> answers the question "What percentage of  cars with a <span class="InputCode">rep78</span> of one are domestic?" while <span class="InputCode">column</span> answers "What percentage of domestic cars have a <span class="InputCode">rep78</span> of one?" and <span class="InputCode">cell</span> answers "What percentage of all the cars are both domestic and have a <span class="InputCode">rep78</span> of one?"</p>
<p><span class="InputCode">tab</span> has an option called <span class="InputCode">sum</span> which
                  gives summary statistics for a given variable, calculated over the observations in each cell of the table. Try: </p>
<p class="InputCode">tab foreign, sum(mpg)</p>
<p>There's also a <span class="InputCode">chi2</span> option that
                  runs a chi-squared test on a two-way table: </p>
<p class="InputCode">tab rep78 foreign, chi2</p>
<p>Run your do file and examine the results.</p>
<p><strong>Exercise: Use <span class="InputCode">tab</span> to compare the mean value of <span class="InputCode">price</span> associated with each <span class="InputCode">rep78</span> category. What relationship do you see? How does that relationship change if you examine foreign and domestic cars separately? (Ignore for the moment the small sample sizes for many of the cells.)</strong></p>
<p>This do files does not make any changes to the data set it uses, so there's no need to save a new version of it. But to finish your do file properly have it close its log:</p>
<p class="InputCode">log close</p>
<p>Now that you understand how statistical commands work in Stata, learning more of them in your statistics classes will be easy.</p>
<p>Next: <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata6.htm">Creating and Changing Variables</a></p>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>Introduction to Stata: Creating and Changing Variables</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p><span class="intro">This is part six of Introduction to Stata. If you're new to Stata we highly recommend starting from the <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata1.htm">beginning</a>.</span></p>
<p>This article will teach you the basics of making new variables, modifying existing variables, and creating labels.</p>
<h2><a id="GenerateandReplace" name="GenerateandReplace"></a>Generate and Replace</h2>
<p>The primary commands for creating and changing variables are <span class="InputCode">generate</span> (usually abbreviated <span class="InputCode">gen</span>) and <span class="InputCode">replace</span> (which, like other commands that can destroy information, has no abbreviation). <span class="InputCode">gen</span> creates new variables; <span class="InputCode">replace</span> changes the values of existing variables. Their core syntax  is identical:</p>
<p class="InputCode">gen <span class="Parameter">variable</span> = <span class="Parameter">expression</span></p>
<p>or</p>
<p class="InputCode">replace <span class="Parameter">variable </span>= <span class="Parameter">expression</span></p>
<p>where <span class="Parameter">variable</span> is the name of the variable you want to create or change, and <span class="Parameter">expression</span> is the mathematical expression whose result you want to put in it. Expressions can be as simple as a single number or involve all sorts of complicated functions. You can explore what functions are available by typing <span class="InputCode">help functions</span>. If the expression depends on a missing value at any point, the result is missing. Usually this is exactly what you'd expect and want.</p>
<p>It's especially important to use do files when you change your data, so start by creating a do file that loads the <span class="InputCode">auto</span> data set:</p>
<p class="InputCode">capture log close<br/>
                  log using vars.log, replace<br/>
<br/>
                  clear all<br/>
                  sysuse auto </p>
<h2></h2>
<p>The prices in the auto data set are in 1978 dollars, so it might be useful to convert them to 2020 dollars. To do so you need to multiply the prices by a conversion factor which is the CPI in 2020 divided by the CPI in 1978, or about 4. The code will be:</p>
<p class="InputCode">gen price2020 = price*4</p>
<p>You can now compare them with:</p>
<p class="InputCode">l make price price2020</p>
<p>Add these lines to your do file, run it, and examine the results. The prices are still generally lower than you'd see at a car dealership, but that's probably because today's cars are much nicer than 1978 cars. This is a good example of how to check your work!</p>
<p>Internally, Stata executed a loop: it calculated <span class="InputCode">price*4</span> for the first observation and stored the result in <span class="InputCode">price2020</span> for the first observation, then calculated <span class="InputCode">price*4</span> for the second observation and stored the result in <span class="InputCode">price2020</span> for the second observation, and so forth for all the observations in the data set. You'll learn how to stretch this one-observation-at-a-time paradigm in <a href="https://ssc.wisc.edu/sscc/pubs/dws/data_wrangling_stata1.htm">Data Wrangling in Stata</a>, but tasks that break it (like calculating means) require a different approach.</p>
<p>Suppose we wanted to be a little more precise and use 4.14 as the conversion factor. You might be tempted to try to add code that "fixes" the <span class="InputCode">price2020</span> variable (say, multiplying it by 4.14/4). But it's simpler and cleaner to fix the code that created it in the first place. Change:</p>
<p class="InputCode">gen price2020 = price*4</p>
<p>to:</p>
<p class="InputCode">gen price2020 = price*4.14</p>
<p>and run the do file again. Because your do file loads the original data from disk every time it is run, it can simply create the <span class="InputCode">price2020</span> variable the way you want it to be now.</p>
<p>Having both <span class="InputCode">price</span> and a <span class="InputCode">price2020</span> variables allowed you to compare their values and check your work. But if you only want to work with 2020 dollars and are confident you've got the formula right, you can use the <span class="InputCode">replace</span> command to change the existing <span class="InputCode">price</span> variable instead of creating a new one: </p>
<p class="InputCode">replace price = price*4.14</p>
<p>Run this version and you'll get the message <span class="MenuOutput">(74 real changes made)</span>. Given that the data set has 74 observations this tells you that all of them were changed, as you'd expect. Once you start including if conditions, how many observations were actually changed can be very useful information.</p>
<p><strong>Exercise: Outside the United States, fuel efficiency is frequently measured in liters per kilometer (note that because the fuel used is in the numerator, a low number is good). To convert miles per gallon to liters per kilometer, multiply the reciprocal of <span class="InputCode">mpg</span> (<span class="InputCode">1/mpg</span>) by 2.35. Create a variable that stores the fuel efficiency of each car in liters per kilometer.</strong></p>
<h3>Creating Variables with If Conditions</h3>
<p>If a <span class="InputCode">gen</span> command has an if condition, the resulting variable will (and must) still exist for all observations. However it will be assigned a missing value for observations where the if condition is not true. If a <span class="InputCode">replace</span> command has an if condition, observations where the if condition is not true will be left unchanged. This allows you to set variables to different values for different observations.</p>
<p>Suppose you wanted to collapse the five-point scale of the <span class="InputCode">rep78</span> variable  into a three-point
                  scale. Add the following code to your do file to do so:</p>
<p class="InputCode">gen rep3 = 1 if rep78&lt;3<br/>
                  replace rep3 = 2 if rep78==3<br/>
                replace rep3 = 3 if rep78&gt;3 &amp; rep78&lt;.</p>
<p>The first line creates the new variable <span class="InputCode">rep3</span>, but only sets it to one
                  for cases where <span class="InputCode">rep78</span> is less
                  than             	 three. The
                  others get missing. The second line changes some of those missings
                  to twos, and the third changes more
                  of them to threes. Run the do file, note the number of observations changed by each line, and compare that to the total number of observations in the data set.</p>
<p> What will the value of <span class="InputCode">rep3</span> be for observations where <span class="InputCode">rep78</span> is missing? Missing, as it should be,  because it was never
                  set to anything else. The five observations where <span class="InputCode">rep78</span> is missing were implicitly or explicitly excluded from all three commands, so they started out with a missing value for <span class="InputCode">rep3</span> and were never changed. (If you forgot to exclude missing values from the last command then <span class="InputCode">rep3</span> would be three for cars where <span class="InputCode">rep78</span> is missing, an all-too-common mistake. Remember missing is essentially infinity.)</p>
<p><strong>Exercise: Combining the ones and twos makes sense because there are so few of them, but there was no particular need to combine the fours and fives. Create a <span class="InputCode">rep4</span> variable that  combines the ones and twos and renumbers the other categories accordingly (i.e. <span class="InputCode">rep4</span> should go from one to four).</strong></p>
<h2><a id="Recode" name="Recode"></a>Recode</h2>
<p>The <span class="InputCode">recode</span> command gives you an alternative way of creating <span class="InputCode">rep3</span>. It is designed solely for recoding tasks and is much less flexible than <span class="InputCode">gen</span> and <span class="InputCode">replace</span>. But it's very easy to use. The syntax is:</p>
<p class="InputCode">recode <span class="Parameter">var</span> (<span class="Parameter">rule 1</span>) (<span class="Parameter">rule 2</span>) (<span class="Parameter">more rules as needed...</span>), gen(<span class="Parameter">newvar</span>)</p>
<p>The <span class="InputCode">gen</span> option at the end is not required—if it's not there then the original variable will be changed rather than creating a new variable with the new values. You can also have <span class="InputCode">recode</span> work on a list of variables, recoding them all in the same way.</p>
<p>The core of the recode command is a list of rules, each in parentheses, that tell it how a variable is to be recoded. They take the form <span class="InputCode">(</span><span class="Parameter">inputValue </span><span class="InputCode">= </span><span class="Parameter">outputValue</span><span class="InputCode">)</span>. The <span class="Parameter">inputValue</span> can be a single number, a list of numbers separated by spaces, or a range of numbers specified with <span class="Parameter">start</span>/<span class="Parameter">end</span>. The <span class="Parameter">outputValue</span> will always be a single number. Anything not covered by a rule is left unchanged, so you can use <span class="InputCode">recode</span>  to change just a few values of a variable or completely redefine it as we do here. Here's a <span class="InputCode">recode</span> version of converting <span class="InputCode">rep78</span> to a three-point scale:</p>
<p class="InputCode">recode rep78 (1 2 = 1) (3 = 2) (4 5 = 3), gen(rep3b)</p>
<p> Missing values required no special handling: since  missing was not listed in the input values of any rule, observations with missing values remain unchanged.</p>
<p><strong>Exercise: Create <span class="InputCode">rep4b</span>, combining only the ones and twos as above, using <span class="InputCode">recode</span>.</strong></p>
<h2> Indicator Variables	</h2>
<p>In creating indicator variables you can take advantage of the fact that Stata treats true as one and false as zero by setting the new variable equal to a condition. Consider:</p>
<p class="InputCode">gen lowMPG = (mpg&lt;20)</p>
<p>(The parentheses are optional, but make it easier to read.) This creates an indicator variable called<span class="InputCode"> lowMPG</span> which is one (true) for cars where <span class="InputCode">mpg</span> is less than twenty and zero (false) where <span class="InputCode">mpg</span> is greater than or equal to twenty. You can see the result with:</p>
<p class="InputCode">l make mpg if lowMPG</p>
<p>No car has a missing value for <span class="InputCode">mpg,</span> but if one did, the above code would assign it a zero for <span class="InputCode">lowMPG</span> as if it were known to have good gas mileage. The <span class="InputCode">lowMPG</span> variable should be missing for such cases, which you can do with:</p>
<p class="InputCode">gen lowMPG = (mpg&lt;20) if mpg&lt;.</p>
<h2></h2>
<p></p>
<h2>String Variables</h2>
<p>The <span class="InputCode">gen</span> and <span class="InputCode">replace</span> commands work with string variables too. The expressions on the right side of the equals sign are not mathematical, but they follow similar rules. String values always go in quotes, so if you wanted to store the letter x in a variable called <span class="InputCode">x</span> you'd say <span class="InputCode">gen x = "x"</span>. Stata would not find this confusing (though you might) because x in quotes (<span class="InputCode">"x"</span>) means the letter x and x without quotes means the variable x. </p>
<p>Addition for strings is defined as putting one string after the other, so "abc" + "def" = "abcdef". But most work with strings is done by special-purpose functions that take strings as input (either string values or variables containing strings) and return strings as output.</p>
<p>The <span class="InputCode">make</span> variable really records two pieces of information: the name of the company that produced the car, and the name of the car model. You can easily extract the company name using the <span class="InputCode">word()</span> function:</p>
<p class="InputCode">gen company = word(make,1)</p>
<p>The first input, or argument, for the <span class="InputCode">word()</span> function is the string to act on (in this case a variable containing strings). The second is a number telling it which word you want. The function breaks the input string into words based on the spaces it contains, and returns the one you asked for, in this case the first.</p>
<p>We'll say much more about string functions in Text Data (forthcoming), but if you're eager to get started you can do a great deal with just the following functions:</p>
<table border="1">
<tbody>
<tr>
<td><span class="InputCode">word()</span></td>
<td>Extracts a word from a string
                      </td>
</tr>
<tr>
<td><span class="InputCode">strpos()</span></td>
<td>Tells you if a string contains another string, and if so its position</td>
</tr>
<tr>
<td><span class="InputCode">substr()</span></td>
<td>Extracts parts of a string</td>
</tr>
<tr>
<td><span class="InputCode">subinstr()</span></td>
<td>Replaces part of a string with something else</td>
</tr>
<tr>
<td><span class="InputCode">length()</span></td>
<td>Tells you how long a string is (how many characters it contains)</td>
</tr>
</tbody>
</table>
<p>Type <span class="InputCode"> help</span> and then the name of a function in the main Stata window to learn how it works.</p>
<p><strong>Exercise: Create a <span class="InputCode">model</span> variable containing the name of the car model (i.e. the rest of <span class="InputCode">make</span>). Your code must be able to handle model names that are either one or two words long.</strong></p>
<h2></h2>
<h3>Converting String Variables to Numeric Variables</h3>
<p>Sometimes a variable that should be numeric gets entered into Stata as a string. You can fix that with the <span class="InputCode">destring</span> command, which converts a string variable that contains numbers to a numeric variable. The syntax is just <span class="InputCode">destring </span><span class="Parameter">variable</span><span class="InputCode">, replace</span>, where variable should be replaced by the name of the variable (or variables) to be destringed. If the string variable contains anything but numbers, you can add the <span class="InputCode">force</span> option to tell Stata to convert it anyway, but observations with any non-numeric characters will get a missing value. Note that "non-numeric characters" include dollar signs and commas! </p>
<p>In general, if you have to use the <span class="InputCode">force</span> option it's because Stata isn't sure what you're doing is a good idea, and you should think carefully before doing it. In this case you should examine the non-numeric characters to see if it would make sense to remove them first (like those dollar signs and commas) or if the variable isn't really just numbers after all.</p>
<p>This data set doesn't have any variables that need to be destringed, so let's make one:</p>
<p class="InputCode">gen x = "5"</p>
<p>Note how the quotes around "5" mean that <span class="InputCode">x</span> is a string variable containing the character 5, not a numeric variable containing the value 5. Just to make things complicated, let's change some of the values of <span class="InputCode">x</span> to actual text:</p>
<p class="InputCode">replace x = "missing" if foreign</p>
<p>Now try to <span class="InputCode">destring x</span>:</p>
<p class="InputCode">destring x, replace</p>
<p>Stata will refuse, because some of the values of <span class="InputCode">x</span> can't be converted to numbers. But the values which can't be converted are "missing" so it is entirely appropriate to convert them to missing values. So try again with the force option:</p>
<p class="InputCode">destring x, replace force</p>
<p>Now Stata will convert <span class="InputCode">x</span> to a numeric variable, with some missing values.</p>
<h2>Egen</h2>
<p>The <span class="InputCode">egen</span> command, short for "extended generate" gives you access to a second of library of functions. It's a bit of a hodge-podge, but the <span class="InputCode">egen</span> functions you'll use the most calculate summary statistics:</p>
<table border="1">
<tr>
<th>Name</th>
<th>Description</th>
</tr>
<tr>
<td class="InputCode">min()</td>
<td>Minimum value</td>
</tr>
<tr>
<td class="InputCode">max()</td>
<td>Maximum value</td>
</tr>
<tr>
<td class="InputCode">mean()</td>
<td>Mean</td>
</tr>
<tr>
<td class="InputCode">median()</td>
<td>Median</td>
</tr>
<tr>
<td class="InputCode">sd()</td>
<td>Standard Deviation</td>
</tr>
<tr>
<td class="InputCode">total()</td>
<td>Total</td>
</tr>
</table>
<p>These are examples of <em>aggregate functions</em>: they take multiple numbers as input and return a single number as output. They also work across observations, and thus can't be easily done using <span class="InputCode">gen </span>since it works one observation at a time. The syntax looks almost identical to <span class="InputCode">gen</span>:</p>
<p class="InputCode">egen <span class="Parameter">variable</span> = <span class="Parameter">function()</span></p>
<p>The big difference with <span class="InputCode">egen</span> is that you're not writing your own mathematical expression; you're just using a function from the library. For example, if you needed to set a variable to a mean divided by two, you could not say <span class="InputCode">egen y = mean(x)/2</span>. You'd instead first run <span class="InputCode">egen y = mean(x)</span> and then <span class="InputCode">replace y = y/2</span>.</p>
<p>Another important difference is how missing values are handled. Recall that with <span class="InputCode">gen</span>, if any part of the input was missing the output would be missing. However, <span class="InputCode">egen</span> simply ignores missing values and calculates the result using the data that are available. Usually this is what you want, but you need to be aware of what <span class="InputCode">egen</span> is doing and be sure it makes sense for your particular task.</p>
<p>The <span class="InputCode">egen</span> functions for calculating summary statistics are very commonly combined with <em>by</em> to calculate summary statistics for groups. Calculate the mean car price for each company and then view the results with:</p>
<p class="InputCode">bysort company: egen meanPrice = mean(price)<br/>
                  tab company, sum(meanPrice)
                </p>
<p>Recall that <span class="InputCode">bysort company:</span> first sorts the data by <span class="InputCode">company</span> and then runs the following <span class="InputCode">egen</span> command separately for each company. </p>
<p>The zeros for standard deviation reflect the fact that every car produced by the same company has the same value of <span class="InputCode">meanPrice</span>. That's because <span class="InputCode">meanPrice</span> describes the company, not the car. In fact that's the definition of a variable that describes a group: every unit within the same group must have the same value of the variable.</p>
<p>If we had only wanted to see the mean value of price for each company, we could have just run:</p>
<p class="InputCode">tab company, sum(price)</p>
<p>But having run <span class="InputCode">egen</span> we now have the mean in a variable, available for use.</p>
<p><strong>Exercise: Create a variable containing the mean value of <span class="InputCode">rep78</span> for each company. Then examine the frequencies of <span class="InputCode">rep78</span> within each company by creating a two-way table with <span class="InputCode">tab</span>. Be sure to include missing values. Lincoln and Olds have the same mean; how well do you think this summarizes the distribution of <span class="InputCode">rep78</span> for the two companies? Next consider the missing values: suppose the actual value of <span class="InputCode">rep78</span> for the cars with missing vales  were revealed. What would they have to be  in order for these means to not change? How plausible is that?</strong></p>
<h2>Labels</h2>
<p>Good labels make your data much easier to understand and work with. While Stata has many kinds of labels, we'll focus on the most common and most useful: variable labels and value labels.</p>
<h3>Variable Labels</h3>
<p>Variable labels convey  information about a variable, and can be a substitute for long variable names. This data set already has a good set of variable labels, as you can see in the Variables window. The only one that's confusing is the label on <span class="InputCode">foreign</span>, so  change it using the <span class="InputCode">label variable</span> command. The syntax to set a variable label is: </p>
<p class="InputCode">label variable <span class="Parameter">variableName "</span><span class="Parameter">label"</span></p>
<p>So type:</p>
<p class="InputCode">label variable foreign "Car Origin"</p>
<p>Look at the Variables window again to see the results.</p>
<h3>Value Labels</h3>
<p>Value labels are used with categorical variables to tell you what the categories mean. We've seen one in action with the <span class="InputCode">foreign</span> variable: it was the value labels that told us that a 0 means "Domestic" and a 1 means "Foreign."</p>
<p> Let's explore value labels by labeling the values of <span class="InputCode">rep3</span>, the new variable we recoded to collapse <span class="InputCode">rep78</span> from a five point scale to a three point scale. Value labels
                  are a mapping from a set of integers to a set of text descriptions, so the first step is to define the map. To do so, use the <span class="InputCode">label define</span> command: </p>
<p class="InputCode">label define <span class="Parameter">mapName</span> <span class="Parameter"> value1</span> <span class="Parameter">"label1</span>" <span class="Parameter">value2</span> "<span class="Parameter">label2</span>"...</p>
<p>Thus:</p>
<p class="InputCode">label define replabel 1 "Bad" 2 "Average" 3 "Good"</p>
<p>This creates a mapping called <span class="InputCode">replabel</span> but does not apply it to anything. Before it does anything useful you have to tell Stata to  label the values of the <span class="InputCode">rep</span> variable
                  using the <span class="InputCode">replabel</span> mapping you just
                defined. The syntax  is:</p>
<p class="InputCode">label values <span class="Parameter">variable</span> <span class="Parameter">map</span></p>
<p>And thus:</p>
<p class="InputCode">label values rep3 replabel</p>
<p>To see the results, run:</p>
<p class="InputCode">list make rep3</p>
<p>Once a map is defined you can apply it to any number of variables: just replace the single variable in the <span class="InputCode">label values</span> command above with a list of variables. Suppose you're working with survey data
                  and your variables include the gender of the respondent, the
                  gender of the respondent's spouse, and the genders of all the
                  respondent's children. You could define just one map called <span class="InputCode">gender</span> and
                  then use it to label the values of all the gender variables.</p>
<p>Three 
                  commands for managing value labels: <span class="InputCode">label dir</span> gives you a list of all the defined labels, and <span class="InputCode">label
                list</span> tells you what they mean. The <span class="InputCode">describe</span> command tells you the name of the value labels associated with each variable (among many other useful things).</p>
<p><strong>Exercise: Create value labels for <span class="InputCode">rep4</span> and apply them. Feel free to decide how to describe the levels.</strong></p>
<h3>Labels via Recode</h3>
<p>When you use recode to create a new variable, Stata will automatically create a variable label for it ("RECODE of ..."). You can also define value labels for it by putting the desired label for each value  at the end of the rule that defines it. Create yet another version of rep3, this time with labels right from its creation, with:</p>
<p class="InputCode">recode rep78 (1 2 = 1 "Bad") (3 = 2 "Average") (4 5 = 3 "Good"), gen(rep3c)</p>
<p><strong>Exercise: Create a <span class="InputCode">rep4c</span> using <span class="InputCode">recode</span>, setting value labels for it.</strong></p>
<p>This do file changes the data set it uses, so it should save the new version. Remember, <strong>never save your output over your input</strong>, so don't save the new data as <span class="InputCode">auto</span>. If you did, you could not run this do file again: it would crash when it tried to create <span class="InputCode">price2020</span> because that variable would already exist in the modified data set. Instead, save the data as <span class="InputCode">autoV2</span>, as in "version 2 of the automobile data set."</p>
<p class="InputCode">save autoV2, replace</p>
<p>Finally, close the log:</p>
<p class="InputCode">log close</p>
<p>This brings us to the end of Introduction to Stata. We hope it has been helpful to you. To learn more, consider reading <a href="https://ssc.wisc.edu/sscc/pubs/dws/data_wrangling_stata1.htm">Data Wrangling in Stata</a>, or the other contents of the SSCC's <a href="https://ssc.wisc.edu/sscc/pubs/stat.htm">Statistical Computing Knowledge Base</a>.</p>
<div></div>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
</kb_documents>