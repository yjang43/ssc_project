<?xml version="1.0"?>
<kb_documents>
<kb_document>
<kb_title>Using Compressed Data in SAS</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- #BeginEditable "Text" -->
<p>SAS has a variety of tools for working with compressed data. This article
					will describe how to use them, and why.</p>
<p>Compression programs look for patterns in the data, and then replace the
					original file with a file that describes those patterns.
					Nothing is lost--that description contains all the information
					needed to recreate the original
					file. Normally the description is smaller than the original
					file, but how much smaller will depend on the data itself
					and	the compression	scheme used.
					With the compression scheme build into SAS, the compressed
					file	can	even	be	bigger	than	the	original in rare
					cases.</p>
<p>The catch is that it takes CPU time to compress or uncompress a 
              file. Thus compression is really a way to trade CPU power for disk 
              space. For files you use constantly, this may not be a good trade. 
              But we strongly you encourage to compress any data sets you are 
              not using on a regular basis.</p>
<h2>Using Compressed SAS Data Sets</h2>
<p>SAS has built-in tools for compressing SAS data sets. Simply add the <span class="InputCode">compress</span>			  option
					to your data statement. It can take one of two values: <span class="InputCode">yes</span>			  (or
					equivalently <span class="InputCode">char</span>)
					and <span class="InputCode">binary</span>. These will use two different
					compression schemes (RLE and RDC respectively). The scheme
					you	use will affect the amount of compression you get, but
					it's	impossible	to	predict	which	will work better
					for a particular	data	set.	You may	want	to experiment
					and see, or	just choose	one	and go	with it.</p>
<p>The complete syntax is simply:</p>
<p class="InputCode">data <span class="Parameter">output</span> (compress=yes);</p>
<p>or</p>
<p class="InputCode">data <span class="Parameter">output</span> (compress=binary);</p>
<p>where <span class="Parameter"><span class="InputCode">output</span></span> should
					be	replaced by the name of the data set you wish to create.
					The data step then proceeds as usual.</p>
<p>To use a compressed data set takes no special syntax whatsoever. SAS will
					recognize that the data set is compressed and uncompress
					each	observation automatically as it reads it. Of course
					it takes additional CPU time to both read and write compressed
					data.</p>
<p>Both of the compression schemes available in SAS have the drawback that
					they add 12 bytes per observation, and if the data set has
					many observations but few variables this overhead can be
					greater than the amount of space saved. One other drawback:
					Stat/Transfer cannot read compressed data sets. If you anticipate
					using Stat/Transfer, do not compress your data, or make an
					uncompressed copy before attempting to run Stat/Transfer.</p>
<h2>Reading Compressed Text Files</h2>
<p>Linux has its own set of tools for compressing files, notably compress/uncompress,
					gzip/gunzip, bzip2/bunzip2 and zip/unzip. They are described
					in <a href="https://ssc.wisc.edu/sscc/pubs/7-8.htm">Using
					Compressed	Data in Linux</a>. Windows has another set of compression tools,
					the most common being Winzip and its relatives (note that
					the Linux programs <span class="InputCode">uncompress</span> and <span class="InputCode">unzip</span> can
					both handle Windows	zip	files, as can <span class="InputCode">zcat</span>).
					It is very	common	to	receive data as text	files	that
					have been compressed	using one of these	programs.</p>
<p>Often the easiest way to read in these files is to first uncompress them
					using	Linux tools and then read the uncompressed data
					directly--just remember not to keep both the compressed files
					and the uncompressed files once you're done.	You	can	temporarily
					store	the	uncompressed	files	in	/temp/fivedays	if
					they	are	too large to	fit in	the	space available	to
					you.</p>
<p> But	it	is possible to	have SAS	read	compressed
							files	directly	(with	the exception	of	files
					compressed	using <span class="InputCode">bzip2</span>, since	it is not
					compatible with <span class="InputCode">zcat</span>).
							This can	be handy if the	files are extremely large,
					or	if you are	working with many	compressed files.</p>
<p>The key is to define a SAS filename which is actually the output of the <span class="InputCode">zcat</span>			  command.
					The <span class="InputCode">zcat</span> command simply reads out the tables
					of a compressed	file. SAS can use the output of <span class="InputCode">zcat</span> just
					as if it were a file. Before your data step, insert the following
					in your SAS program:</p>
<p class="InputCode">filename reader pipe 'zcat <span class="Parameter">file</span>';</p>
<p>where <span class="Parameter"><span class="InputCode">file</span></span> is
					the name of the compressed file you want to read. Now in
					your data step, your infile command just uses reader:</p>
<p class="InputCode">infile reader;</p>
<p>Options such as <span class="InputCode">delimiter</span> still work as
					usual if needed. Here's an example of a full data step that
					reads	a compressed text file:</p>
<p class="InputCode">filename reader pipe 'zcat compressed.Z';</p>
<p class="InputCode">data plain;<br/>
<span class="indent3">infile reader delimiter=" ";</span><br/>
<span class="indent3">input x1 x2 x3 x4 x5 x6 x7 x8 x9 x10;</span><br/>
		run;</p>
<h2>Writing Compressed Text Files</h2>
<p>You can have SAS output compressed text files as well. This is equivalent
					to having SAS write normal text and then compressing it,
					but can save you a step (and this way it is all documented
					in your SAS program). Once	again,	the	key	is	a	filename
					containing a compression command:</p>
<p class="InputCode">filename writer pipe 'compress &gt; <span class="Parameter">file</span>.Z';</p>
<p>The <span class="InputCode">.Z</span> is essential so <span class="InputCode">uncompress</span> will
					later recognize the output as a compressed file. You can
					then	use that filename	anywhere where SAS writes
					text. Two examples:</p>
<p class="InputCode">data _null_;<br/>
<span class="indent3">set plain;</span><br/>
<span class="indent3">file writer;</span><br/>
<span class="indent3">put x1-x10;</span><br/>
			run;</p>
<p class="InputCode">proc export data=plain outfile=writer dbms=dlm;<br/>
<span class="indent3">delimiter=',';</span><br/>
run;</p>
<p>Please note that proc export will insist on briefly opening a SAS window
					as it runs. It will disappear very quickly, but this does
					mean that you must have the ability to display Linux graphics
					in your session or a job using proc export will hang. This
					is true whether you're compressing the output of proc export
					or not.</p>
<!-- #EndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>Creating SAS Transport Files</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- #BeginEditable "Text" -->
<p>Starting with version 8, data sets are now portable across most, but not all, 
  operating systems. Most SSCC users will never have to work with a transport 
  file again. But for those who do, there is a new wrinkle: if you make a transport 
  file using PROC COPY (probably what you're used to) variable names longer than 
  eight characters will be truncated. This is so that the resulting transport 
  file can be read in older versions of SAS. On the other hand, PROC CPORT does 
  support long variable names, but the transport files it creates can only be 
  read with SAS 8. </p>
<p>To repeat, most SSCC users will not have to use transport files. SAS data sets 
  can be moved between all SSCC computers "as is." This document is 
  most likely to be of interest if you are trying to make data available to the 
  widest possible audience. If you are concerned about users of SAS 6, then you 
  probably want to keep your variable names under eight characters and use PROC 
  COPY. Otherwise use PROC CPORT. Just one warning: these methods don't mix. PROC 
  COPY can't read files made with PROC CPORT and PROC CIMPORT cannot read files 
  made with PROC COPY, so always tell the recipient which they should use.</p>
<p>The process of moving a SAS data set involves three steps. First, you must 
  convert the data set into a transport file on the source computer. Second, move 
  the transport file from the source computer to the destination computer. Third, 
  convert the transport file back into a standard data set on the destination 
  computer.</p>
<h2>PROC CPORT</h2>
<ol>
<li>
<p>To convert the data set to a transport file using PROC CPORT, run the following 
      SAS program on the source computer.</p>
<p class="InputCode"> proc cport data='<span class="Parameter">datafile</span>' 
      file=<span class="Parameter">transfile</span>;<br/>
      run;</p>
<p>Replace <span class="Parameter"><span class="InputCode">datafile</span></span> 
      with the file name (and the path, unless it is your current directory) of 
      the data file. Replace <span class="Parameter"><span class="InputCode">transfile</span></span> 
      with the name you want to give the transport file (and a path if you don't 
      want it to go in the current directory).</p>
</li>
<li>
<p>Move the transport file to the destination computer, using whatever method
    	 is available (SFTP, etc., but if you use SFTP make sure it is binary
    	mode).</p>
</li>
<li>
<p>To convert the transport file back to a regular data set, run the following 
      on the destination computer.</p>
<p class="InputCode">libname new '<span class="Parameter">newlocation</span>';<br/>
      proc cimport library=new infile='<span class="Parameter">transfile</span>';<br/>
      run;</p>
<p>Here <span class="Parameter"><span class="InputCode">transfile</span></span> 
      is the file created in step one (including the path where it ended up in 
      step 2 if that's not the current directory). <span class="Parameter"><span class="InputCode">newlocation</span></span> 
      is the directory you want the data set to be put in.</p>
</li>
</ol>
<h2>PROC COPY</h2>
<h2></h2>
<ol>
<li>
<p>To convert the data set to a transport file, run the following SAS program 
      on the source computer.</p>
<p class="InputCode"> libname input '<span class="Parameter">datadirectory</span>';<br/>
      libname output xport '<span class="Parameter">transfile</span>';<br/>
      proc copy in=input out=output;<br/>
<span class="indent3">select <span class="Parameter">datafile</span>;</span><br/>
      run;</p>
<p><span class="Parameter"><span class="InputCode">datadirectory</span></span> 
      is the current location of your data set and <span class="Parameter"><span class="InputCode">datafile</span></span> 
      is the file name. <span class="Parameter"><span class="InputCode">transfile</span></span> 
      is the name you want to give the transport file (you can also specify a 
      path if you don't want it to go in the current directory).</p>
</li>
<li>
<p>Move the transport file to the destination computer, using whatever method
    	 is available (SFTP, etc., but if you use SFTP make sure it is in binary
    	mode).</p>
</li>
<li>
<p>To convert the transport file back to a regular data set, run the following 
      on the destination computer.</p>
<p class="InputCode">libname input xport '<span class="Parameter">transfile</span>';<br/>
      libname output '<span class="Parameter">newlocation</span>';<br/>
      proc copy in=input out=output;<br/>
      run;</p>
<p>Here <span class="Parameter"><span class="InputCode">transfile</span></span> 
      is the file created in step one (including the path where it ended up in 
      step 2 if that's not the current directory). <span class="Parameter"><span class="InputCode">newlocation</span></span> 
      is the directory you want the data set to be put in.</p>
</li>
</ol>
<p> </p>
<!-- #EndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>Programming in Color</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- #BeginEditable "Text" -->
<p>Both Textpad for Windows and Emacs for Linux have the ability to recognize 
  parts of some programming languages as you are writing and color it according 
  to its meaning. For example, comments may be green and commands blue. This can 
  help in avoiding syntax errors. </p>
<h2><a id="Textpad" name="Textpad"></a>Textpad</h2>
<p>Our standard installation of Textpad already has syntax coloring set up, so
	if you are running it on Winstat, or if we set it up on your PC for you,
	you're all set. Textpad identifies files by their extension (<span class="InputCode">*.sas</span>, <span class="InputCode">*.do</span>,
	 etc.), which does mean you must save the file and give it a name before
	it can be colored. If syntax coloring is not set up on your machine, or you
	want to add additional file types, you can <a href="http://www.textpad.com/add-ons/syna2g.html">download
	 syntax files from Textpad's web site</a> (they have a huge list of languages
	  available). Instructions for installing them are found at the end of the
	 list of available files.</p>
<h2><a id="Emacs" name="Emacs"></a>Emacs</h2>
<p>The ability to color files for statistical programs such as SAS and Stata
	is  included in a package called ESS (Emacs Speaks Statistics), which is
	installed by default.</p>
<!-- #EndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>Finding and Installing User-Written Stata Programs</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- #BeginEditable "Text" -->
<p>There are a tremendous number of user-written programs for Stata available which, once installed, act just like official Stata commands. Some are conveniences, like <span class="InputCode">outreg</span> for formatting regression output. Others calculate results Stata itself does not, such as <span class="InputCode">polychoric</span> for polychoric correlations. A few represent major extensions of Stata's capabilities, such as <span class="InputCode">ice</span> and <span class="InputCode">mim</span> for multiple imputation or <span class="InputCode">gllamm</span> for mixed models. Most of these programs are stored at Boston College's <a href="http://ideas.repec.org/s/boc/bocode.html">Statistical Software Components</a> archive (or SSC, but not to be confused with the UW's Social Science Computing Cooperative or SSCC) .</p>
<p>You are welcome to install any user-written commands you desire to use, even in the labs, on Winstat or on the Linux servers, because Stata at the SSCC is set up to store the programs you install in your home directory. Thus you don't need to worry about programs you install causing problems for others. On the other hand, this means you need to install the user-written programs you want yourself. The SSCC does not try to identify some useful set of user-written programs and make them available to everyone.</p>
<p>This article will discuss finding, installing, and updating user-written programs. Fortunately Stata includes commands which make this very easy to do.</p>
<h2><a id="Usingfindit" name="Usingfindit"></a>Finding User-Written Programs</h2>
<p>If you know the name of the program you want to use, you can go directly to <a href="#InstallingUserWrittenPrograms">Installing User-Written Programs</a>. However, it's much more common to know what you want to do without knowing what program (if any) can do it. This is a job for Stata's <span class="InputCode">findit</span> command.</p>
<p>For example, suppose you wanted to do something with Heckman selection models but don't know what command to use. Type:</p>
<p class="InputCode">findit heckman</p>
<p>The result is a tremendous amount of information. The <span class="InputCode">findit</span> command first searches Stata's official help files and notes that there is an official <span class="InputCode">heckman</span> command and several other related  commands (this makes <span class="InputCode">findit</span> a powerful tool for figuring out how to do things in Stata in general, not just for finding user-written programs). It then searches Stata's web site and locates several FAQ entries, plus an example on UCLA's large statistics web site. It then begins to list relevant user-written programs, organized into "packages." Programs that were described in the Stata Journal or the older Stata Technical Bulletin are listed first.</p>
<p> You can click on each package to view a very brief description, including a list of files (one package may contain several related programs). Also note the <span class="MenuOutput">(click here to install)</span> link. Clicking on the <span class="InputCode">.hlp</span> file will get you the help entry for the program, which you can use to decide if the program will do what you need.</p>
<h2><a id="InstallingUserWrittenPrograms" name="InstallingUserWrittenPrograms"></a>Installing User-Written Programs</h2>
<p>If you know the name of the package you want to install, you can install it by typing</p>
<p class="InputCode">ssc install <span class="Parameter">package</span></p>
<p>Alternatively, if you identified the package you want using <span class="InputCode">findit</span> you can install it by clicking on its <span class="MenuOutput">(click here to install)</span> link. However, <em>avoid installing any package that is directly tied to an article in the Stata Journal or the Stata Technical Bulletin</em>. These packages contain the program as it was described in the article and are not updated. Look for another package containing the program that is not tied to an article and, if one exists, install that instead.</p>
<p>For example, if you type</p>
<p class="InputCode">findit ice</p>
<p>the first three <span class="InputCode">ice</span> packages you'll see  are (as of  4/30/2008) <span class="InputCode">stb0067_1</span>, <span class="InputCode">stb0067_2</span> and <span class="InputCode">stb0067_3</span>, but none of these contain the latest version of <span class="InputCode">ice</span>. The package which does is simply called <span class="InputCode">ice</span>. As the author of <span class="InputCode">ice</span> (Patrick Royston) makes further changes and improvements, the <span class="InputCode">ice</span> package will be updated accordingly. If he writes another Stata Journal article describing the changes he has made the result will likely be an <span class="InputCode">stb0067_4</span> package, but if you installed <span class="InputCode">stb0067_3</span> you won't get the new version automatically.</p>
<p>(Getting the right version of <span class="InputCode">ice</span> is particularly important because multiply imputed data sets created by one version cannot be used by different versions--and the output of older versions can't be analyzed using <span class="InputCode">mim</span> at all. The newer versions of <span class="InputCode">ice</span> also include more capabilities than the older ones.)</p>
<p>Unfortunately, the <span class="InputCode">ice</span> package you want to install isn't trivial to find--it's about a third of the way through the very long list of results you get from <span class="InputCode">findit ice</span>. However, packages are usually named after the main ado file they contain, and that file is normally listed first in the package description. So if you've looked at <span class="InputCode">stb0067_3</span> and decided that program will meet your needs, noting that <span class="InputCode">ice.ado</span> is the first file listed is enough to know that you can probably install the latest version by typing</p>
<p class="InputCode">ssc install ice</p>
<h2><a id="UpdatingUserWrittenPrograms" name="UpdatingUserWrittenPrograms"></a>Updating User-Written Programs</h2>
<p>While few user-written programs are updated as frequently as <span class="InputCode">ice</span>, it's still important to get the latest versions of any user-written programs you install. Sometimes updates will include important bug fixes, though the SSC archive has quality control measures in place to try to catch bugs before the program is distributed.</p>
<p>The easiest way to check that your user-written programs are up-to-date is to type:</p>
<p class="InputCode">adoupdate</p>
<p>The <span class="InputCode">adoupdate</span> command notes where each package was downloaded from and goes back to that location to see if a more recent version is available. If there is, you can install the latest version by typing:</p>
<p class="InputCode">adoupdate, update</p>
<p>You can get a list of the packages you've installed by typing:</p>
<p class="InputCode">ado dir</p>
<p>This can be very helpful for catching things like having downloaded <span class="InputCode">stb0067_3</span> rather than <span class="InputCode">ice</span>. You can remove a package by typing</p>
<p class="InputCode">ado uninstall <span class="Parameter">package</span></p>
<p>where <span class="InputCode"><span class="Parameter">package</span></span> should be replaced by either  the name of the package you want to remove or the number it is given by <span class="InputCode">ado dir</span>, including the brackets around it.</p>
<p>For example, suppose you downloaded some earlier version of <span class="InputCode">ice</span> that was associated with a Stata Journal article. Just typing</p>
<p class="InputCode">ssc install ice</p>
<p>will fail because you already have a copy of <span class="InputCode">ice.ado</span> and all the other related files, and the installer refuses to overwrite them. Thus you need to identify and remove the older version. To do so, type:</p>
<p class="InputCode">ado dir</p>
<p>If the results included the entry</p>
<pre>[6] package st0067_3 from http://www.stata-journal.com/software/sj7-4<br/>      SJ7-4 st0067_3.  Update: Multiple imputation of missing...<br/></pre>
<p>you could remove it by typing either</p>
<p class="InputCode">ado uninstall st0067_3</p>
<p>or </p>
<p class="InputCode">ado uninstall [6]</p>
<p>Then</p>
<p class="InputCode">ssc install ice</p>
<p>will successfully install the latest version. You should then type</p>
<p class="InputCode">adoupdate</p>
<p>periodically to ensure that ice stays up-to-date.</p>
<!-- #EndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>Using Stat/Transfer</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- #BeginEditable "Text" -->
<p>Stat/Transfer is a utility program that  converts data sets from one format
	to another (for example SPSS to Stata, or Excel to SAS). It is quick and
	easy to use, and  available on  Winstat, Linstat and in the SSCC computer labs.</p>
<h2>Using Stat/Transfer's Graphical User Interface</h2>
<p>If you start Stat/Transfer on Winstat, in the lab or by typing <span class="InputCode">stattransfer</span> on Linstat you'll see the following:</p>
<p><img alt="Stat/Transfer's GUI" height="434" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-17/4-17_1b.png" width="552"/></p>
<p>Set the <span class="MenuOutput">Input File Type</span> to the kind of file you have, then click <span class="MenuOutput">Browse</span> to identify the particular file you want to convert. Set the <span class="MenuOutput">Output File Type</span> to the kind of file you want. Then click <span class="MenuOutput">Transfer</span> and Stat/Transfer will convert the file for you.</p>
<p>The file types are mostly self-explanatory. To create an SPSS file set the <span class="MenuOutput">Output File Type</span> to <span class="MenuOutput">SPSS Unicode for Windows</span>. In general <span class="MenuOutput">ASCII/Text - Delimited</span> can only be used to convert text files if they are very structured.</p>
<p>The other tabs are typically not needed. <span class="MenuOutput">Variables</span> lets you choose which variables are converted, and set their types. <span class="MenuOutput">Observations</span> lets you convert just a subset of your data. <span class="MenuOutput">Options</span> has a wide variety of settings for converting various kinds of files. For example, by default Stat/Transfer will stop reading an Excel file if it encounters a blank line (on the assumption that anything after that will be notes or other material other than data) but you can change that behavior by clicking the <span class="MenuOutput">Options</span> tab and then <span class="MenuOutput">Worksheets</span>.</p>
<h2>Using Stat/Transfer from the Command Line</h2>
<p>On Linstat you can use Stat/Transfer to convert a file very quickly and easily from the command line using <span class="InputCode">st</span> rather than <span class="InputCode">stattransfer</span>:</p>
<p class="InputCode">st <span class="Parameter">inputfile</span> <span class="Parameter">outputfile</span></p>
<p>Stat/Transfer will determine the file types by their extensions. For example:</p>
<p class="InputCode">st file.sas7bdat file.dta</p>
<p>will convert <span class="InputCode">file</span> from SAS format to Stata format.</p>
<p>The same principle applies in Windows. To get a command line, click the Windows Logo button (<span class="MenuOutput">Start</span> in older versions of Windows) and then in the <span class="MenuOutput">Search</span> (<span class="MenuOutput">Run</span>) box type <span class="InputCode">cmd</span>. In Windows you also have to give the location of the program, and it's best to put  file names in quotes (sometimes they're not needed, but often they are). Thus the command becomes:</p>
<p class="InputCode">"c:\program files (x86)\stattransfer10\st.exe" "<span class="Parameter">inputfile</span>" "<span class="Parameter">outputfile</span>"</p>
<p>(The location of  <span class="InputCode">st.exe</span>  may vary. The above is its location on Winstat.)</p>
<p>The command to run Stat/Transfer can be included in  many statistical programs. The following Stata code will save the data set in memory as <span class="InputCode">outputdata.dta</span>, then convert it to Excel format:</p>
<p class="InputCode">save outputdata, replace<br/>! st outputdata.dta outputdata.xls -y</p>
<p>The exclamation point (<span class="InputCode">!</span>) indicates that the following command is to be executed by the computer's operating system rather than Stata. The SAS equivalent is <span class="InputCode">x</span>. The <span class="InputCode">-y</span> switch tell Stat/Transfer that yes, it is allowed to overwrite any existing version of <span class="InputCode">output.xls</span>. It plays the same role as the <span class="InputCode">replace</span> option in Stata's <span class="InputCode">save</span> command. Note that this code was written to run on Linstat. The Windows version would be:</p>
<p class="InputCode">save outputdata, replace<br/>
  ! "c:\program files (x86)\stattransfer11\st.exe" "outputdata.dta" "outputdata.xls" -y</p>
<p>For more complicated tasks you can create Stat/Transfer command files. For more details on command files and Stat/Transfer in general, see the documentation. On Linstat, make sure you're on Linstat1 and type:</p>
<p class="InputCode">acroread /software/stattransfer/Help/manual.pdf</p>
<p>On Winstat, click the Windows Logo button, <span class="MenuOutput">All Programs</span>, <span class="MenuOutput">StatTransfer 10</span>, <span class="MenuOutput">StatTransfer 10 PDF Manual</span>. </p>
<!-- #EndEditable -->

</kb_body>
<img_base_url>https://ssc.wisc.edu/sscc/pubs/screenshots/4-17/4-17_1b.png</img_base_url>
</kb_document>
<kb_document>
<kb_title>An Introduction to SAS Data Steps</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- #BeginEditable "Text" -->
<p>SAS remains a popular and powerful tool for data management and statistical 
  analysis. While other tools, particularly Stata, have similar capabilities and 
  are easier to learn, most SAS experts have seen little reason to switch.</p>
<p style="margin-top: 0;">SAS is a huge program. Many of its capabilities (including 
  those the SAS Institute seems to be most excited about) are geared towards the 
  corporate environment rather than academia. But it would be impossible to cover 
  even the most useful features in a single article. This article will 
  focus on the data step, where you will be writing your own code. After reading 
  this article you should be able to begin writing SAS programs to prepare 
  your data for analysis right away, assuming they are in SAS format.</p>
<h2>Using this Article</h2>
<p>This article is based on the hands-on SAS class taught by the SSCC. Thus
	 it is best read while sitting at the computer, actually doing the tasks
	described. This article is focused on SAS for Linux, so to
	follow the instructions exactly you will need to log in to <a href="https://ssc.wisc.edu/sscc/pubs/linstat.htm">Linstat</a>.</p>
<p> You will also need to use a text editor. Any
  text  editor will do, so if you have a favorite just make sure you can
  run it and save the results to the Linux file system. If you don't have
  a favorite, we suggest using Emacs if you are comfortable with Linux, and
  TextPad if you are more comfortable with Windows.</p>
<p> TextPad is a Windows-based editor similar to Notepad
	 (but much better). If you are in the Social Science building and don't have
	 TextPad on your PC, please <a href="mailto:helpdesk@ssc.wisc.edu">contact
	 the SSCC Help Desk</a> to have it installed. To save the programs you write to
	 the  Linux file system, you will need to be logged in to the PRIMO domain.
	 If you are working remotely the easiest way to do this is to <a href="http://wi.ssc.wisc.edu">log
	 in to Winstat</a>.
	 Your Linux home directory will then be mapped as the <span class="MenuOutput">Z:</span> drive. </p>
<p>We will repeatedly be switching back and forth between the Linux shell  and
	a text editor. You can always tell when you are supposed to type something
	into Linux because the text will include the prompt (the 
	<span class="InputCode">&gt;</span>) even though you should not type it.</p>
<p>You will use a fair number of small files in the course of this article. 
	The following Linux commands will copy all of them to a directory called <span class="InputCode">sasclass</span> 
	under your Linux home directory. Type them at the Linux prompt and hit enter 
	after each line.</p>
<p class="InputCode">&gt; mkdir ~/sasclass<br/>
	&gt; cd ~/sasclass<br/>
	&gt; cp /usr/global/web/sscc/pubs/files/4-18/* .</p>
<p>This will also make <span class="InputCode">sasclass</span> the current working 
	directory, so you'll be all set to run the examples.</p>
<p>Note that SAS for Windows is the same language, and all the SAS code in this
	article will work in SAS for Windows. However, the process of running
	SAS is fairly different. </p>
<h2>Running SAS</h2>
<h3>Servers</h3>
<p>The SSCC has SAS installed on Winstat and Linstat.
   This article will focus on SAS for Linux as run on Linstat, but again, SAS syntax is the
   same on both Windows and Linux.</p>
<h3>Running Programs</h3>
<p>Linux SAS does have an interactive mode, but almost all Linux SAS users prefer
	to use batch mode. To run SAS in batch mode, you start by writing your program
	using your text editor. Once your program is written, you will give the command
	to run it in Linux. It will run quietly without displaying anything on the
	screen. However when it has finished you will find at least one and probably
	two new files. One is a <span class="InputCode">log</span> file, containing
	a record of what SAS did. This includes any error messages, so you should
	always look at the log after running a SAS program. If the program produced
	any output, it will be saved in a <span class="InputCode">lst</span> file. Both
	of these are text files and can be read using the same text editor you used
	to write the program. They can also be viewed immediately using the <span class="InputCode">more</span> 
  command in Linux.</p>
<p>Normally your program should have the extension <span class="InputCode">.sas</span> 
  (e.g. <span class="InputCode">program.sas</span>) so it is easily recognized 
  as a SAS program (including by SAS itself). SAS will give the <span class="InputCode">log</span> 
  and <span class="InputCode">lst</span> files the same name (e.g. <span class="InputCode">program.log</span> 
  and <span class="InputCode">program.lst</span>).</p>
<p>SAS has its own special format for data sets, which cannot be read by other 
  programs. Fortunately Stat/Transfer makes it easy to convert data sets from 
  one format to another. Stat/Transfer is found on the Winstat servers and on 
  Linux and is very easy to use (see <a href="https://ssc.wisc.edu/sscc/pubs/4-17.htm">Using Stat/Transfer</a> 
  for more information). SAS saves data sets with the extension <span class="InputCode">.sas7bdat</span> 
  (the format has not changed since SAS 7).</p>
<h2><a id="YourFirstSASProgram" name="YourFirstSASProgram"></a>Your First SAS Program</h2>
<p>There's no substitute for actually running a SAS program if you want to see 
  how it works. We'll begin by simply viewing the tables of an existing data 
  set.</p>
<h3>Data Steps and Proc Steps</h3>
<p>SAS programs are made up of distinct steps, and each one is completed before
		 it moves on to the next one. Data steps are written by you. They are
		primarily	
  used for data manipulation (hence the name) though in theory you could do some
		 sorts of analysis with them. Proc steps are pre-written programs made
		available	
  as part of SAS. The code may look similar to a data step in some ways, but
	the code in a proc step is not giving SAS step-by-step instructions to execute.
	All you are really doing is controlling how the proc step runs. We will
	use a few simple procs in the course of this article, but for more details
	see the
		<a href="http://support.sas.com/onlinedoc/912/docMainpage.jsp">SAS documentation</a>.</p>
<p>A step starts with either the word <span class="InputCode">data</span> or the 
  word <span class="InputCode">proc</span>, and ends with the word <span class="InputCode">run;</span>. 
  The <span class="InputCode">run;</span> is often not strictly required, as SAS 
  will assume you want to start a new step when it sees <span class="InputCode">data</span> 
  or <span class="InputCode">proc</span>. However your code will be clearer and 
  easier to understand if you make the end of each step explicit. That may not 
  seem very important the first time you work on a particular program, but when 
  you have to come back to it months later and figure out what you did, you'll 
  quickly see that saving a few keystrokes is far less important than writing 
  clear code. Obviously if you will be sharing this code with anyone else then 
  making it easy to understand is even more important.</p>
<h3>Writing Your Program with a Text Editor</h3>
<p>The time has come to actually write your first SAS program. If you want to 
  use emacs, type</p>
<p class="InputCode">&gt; emacs example1.sas</p>
<p>If you want to use Textpad, start it and immediately save the empty document
	 as <span class="InputCode">Z:\sasclass\example1.sas</span>. 
  This will save it in your <span class="InputCode">sasclass</span> directory
   on the Linux system.</p>
<p>As you proceed, you'll notice that both Textpad and emacs will put different
	words in different colors. Because the file is saved with the <span class="InputCode">.sas</span> 
  extension, it knows you are writing SAS code and tries to make it clearer by
   putting official SAS commands and such in various colors. This can help you
   avoid mistakes.</p>
<h3>Proc Print</h3>
<p>Proc print simply prints the tables of a data set to the <span class="InputCode">lst</span> 
  file. The basic syntax is</p>
<p class="InputCode">proc print data=<span class="Parameter">dataset</span>;<br/>
  run;</p>
<p>All you have to do is specify the data set.</p>
<p>By default SAS will format the output such that it will be centered on a printed 
  page. You can override this behavior by adding</p>
<p class="InputCode">options nocenter;</p>
<p>right before the <span class="InputCode">proc print</span>. This can make it 
  easier to read on the screen. You can also set the line size and page size SAS 
  will use. For example, the following will make your output fit nicely if printed 
  in landscape mode on the SSCC's public printers:</p>
<p class="InputCode">options linesize=122 pagesize=47;</p>
<h3>Using Data Sets</h3>
<p>SAS uses two different types of data sets: temporary and permanent. Temporary 
  data sets disappear when the program is completed. Permanent data sets are written 
  as files on the disk and can be used in later programs (of course they can be 
  deleted like any other file despite the name). To refer to a temporary data 
  set, you simply give its name. To refer to a permanent data set, put the name 
  and optionally the path in single quotes. If you don't specify a path, SAS will 
  look for the data set in your current working directory.</p>
<p>You want to print the tables of <span class="InputCode">ex1.sas7bdat</span>, 
  a permanent SAS data set and one of the files you copied earlier. SAS will assume 
  the <span class="InputCode">.sas7bdat</span> extension, so all you need is:</p>
<p class="InputCode">proc print data='ex1';<br/>
  run;</p>
<p>Type this in your text editor, and then save the file.</p>
<div align="center">
<table>
<tr valign="top">
<td align="center" nowrap="nowrap" valign="top">
<p><strong>Note that </strong></p>
<p class="InputCode">proc print data='ex1';<br/>
						run;</p>
<p><strong>and</strong></p>
<p class="InputCode">proc print data=ex1;<br/>
						run;</p>
<p><strong>Will print completely different data!</strong></p>
</td>
</tr>
</table>
<p align="left">There is an alternative way to reference a permanent data set. 
	It used to be the only way, and many people who learned SAS before the ability 
	to just use quotes was added never switched. The first step is to associate 
	a SAS "library" with a directory on the disk using the <span class="InputCode">libname</span> 
	statement:</p>
<p align="left" class="InputCode">libname <span class="Parameter">library</span>
<span class="Parameter">'directory'</span>;</p>
<p align="left">This command is not part of a proc or data step (it's actually 
	what's called a global option). You can then refer to a SAS data set in that 
	directory as <span class="InputCode"><span class="Parameter">library</span>.<span class="Parameter">file</span></span>. 
	For example:</p>
<p align="left" class="InputCode">libname mydata '/home/r/rdimond/sasclass';</p>
<p align="left" class="InputCode">proc print data=mydata.ex1;<br/>
	run;</p>
<p align="left">There are a few advanced features that only work in the context
  	of a library, and using one could save you some typing if you repeatedly use
  	data sets in a directory other than the current working directory. But to
  	be honest the main reason for knowing about libraries is so you can read other
  	people's code.</p>
<h3 align="left">Running Your Program</h3>
<p align="left">Now that the program is written, you need to run it and view 
	the results. Switch to Linux and type</p>
<p align="left" class="InputCode">&gt; sas example1</p>
<p align="left">You'll know it is done when the next prompt appears. If all 
	went well there will now be two new files in your <span class="InputCode">sasclass</span> 
	directory: <span class="InputCode">example1.log</span> and <span class="InputCode">example1.lst</span>. 
	If <span class="InputCode">example1.lst</span> is missing, it's because there 
	was an error that kept proc print from working--the log will tell you what.</p>
<p align="left">A quick and easy way to view these files is with the <span class="InputCode">more</span> 
	command. Just type </p>
<p align="left" class="InputCode">&gt; more example1.log</p>
<p align="left">and</p>
<p align="left" class="InputCode">&gt; more example1.lst</p>
<p align="left">The disadvantage is the you can't easily scroll back to view
  	text that has already passed by. Thus the better method is to open both files
  	in your text editor.</p>
<p align="left">You should see a tremendously boring data set. If you don't, 
	look at the log to find the error messages, and then examine your program 
	to see what needs to be fixed.</p>
<h3 align="left">Running your Program in the Background</h3>
<p align="left">This job runs so quickly it doesn't really matter how you run
  		 it, but if you have a larger job to run you may want to put it in the
  		background.	
	This means you'll be able to use your shell to do other work while SAS does
  			its thing. To do this, just add an ampersand (<span class="InputCode">&amp;</span>)
  				to the end of the command:</p>
<p align="left" class="InputCode">&gt; sas example1 &amp;</p>
<p align="left">You'll see a message like </p>
<p align="left" class="PREFormat">[1]  Done          
	sas example1</p>
<p align="left">when it is done. You can then view the output as usual. One 
	thing you shouldn't do is start another SAS job while the first one is still 
	running. They'll just end up competing for resources and not running any faster, 
	but they will slow down the server's performance for other users.</p>
</div>
<h3>Data Step Basics</h3>
<p>The basic syntax for a data step is</p>
<p class="InputCode">data <span class="Parameter">output</span>;<br/>
<span class="indent3">set </span><span class="Parameter">input</span>;<br/>
<span class="indent3">{do some stuff}</span><br/>
  run;</p>
<p>where <span class="InputCode">output</span> is the data set where you want 
  to store the results, <span class="InputCode">input</span> is the data set you 
  want to start with, and you'll add various commands to make your <span class="InputCode">output</span> 
  more interesting that your <span class="InputCode">input</span> later.</p>
<p>Note how each line ends with a semicolon (<span class="InputCode">;</span>).
	 In fact SAS doesn't care about lines, but it does demand that you put a
	semicolon at the end of each command. Otherwise it can't tell where one command
	ends and the next one begins. Whenever you find that your program is not
	working, especially if SAS seems to have no clue what you are talking about,
	the first thing to look for is a missing semicolon.</p>
<h3>Variables</h3>
<p>You've already seen how a SAS data set is a matrix where each row is an observation 
  and each column is a variable. SAS has two kinds of variables: numeric and character. 
  SAS will attempt to identify the type of a variable by what you put in it. However, 
  once a variable is created, the type cannot be changed.</p>
<p>You can create or change a variable just by telling SAS what to set it equal 
  to. The general syntax is</p>
<p class="InputCode"><span class="Parameter">var</span>=<span class="Parameter">expression</span>;</p>
<p>where the <span class="Parameter"><span class="InputCode">expression</span></span> 
  can be as simple as a number (<span class="InputCode">x=5;</span>) or include 
  a variety of functions (<span class="InputCode">x=log(exp(5));</span>). See 
  the <a href="https://www.ssc.wisc.edu/sashtml/lgref/z0245852.htm">online SAS 
  documentation</a> for a complete list of available functions and how they work.</p>
<p>There is one special value you should be aware of: missing, stored as a period
	 (<span class="InputCode">.</span>). Since a data set is a matrix, every observation
	  must have some value for each variable. If there is no valid value, SAS
	 stores missing. Any time missing appears in an expression the result will
	 be missing.</p>
<p> Change your program so that it creates a new variable <span class="InputCode">z</span> 
  which is the sum of x and y before printing the results.</p>
<p class="InputCode">data out1;<br/>
<span class="indent3">set 'ex1';</span><br/>
<span class="indent3">z=x+y;</span><br/>
  run;</p>
<p class="InputCode">proc print data=out1;<br/>
  run;</p>
<p>Note that this will store the results in a temporary data set called <span class="InputCode">out1</span>,
	 and the proc print has been changed to print this new data set. Run this
	program and take a look at the results. If you've forgotten, do that by switching
	to Linux and typing</p>
<p class="InputCode">&gt; sas example1</p>
<p>TextPad will notice that the log and output files changed and prompt you to
	reload them. You'll have to tell emacs to get the new versions. Once you
	do, you should see that <span class="InputCode">z</span> is
	always 11. Don't worry, we'll be creating more interesting variables soon.</p>
<h2><a id="AnatomyofaDataStep" name="AnatomyofaDataStep"></a>Anatomy of a Data Step</h2>
<p>Now that you've successfully written a data step, let's take a closer look 
  at how they work. Up to this point, everything we've done has been fairly intuitive 
  and the results have probably been pretty much what you expected. Now we're 
  going to see some surprises. Part of that is because we're going to intentionally 
  abuse SAS--many of the odd behaviors you'll see can be easily avoided just by 
  not trying to do things before the <span class="InputCode">set</span> statement. 
  But by understanding how SAS thinks you'll be able to get it to do things that 
  are not so obvious.</p>
<h3>Compile Phase</h3>
<p>SAS executes a data step in two phases. Most commands are carried out in one
		 phase or the other. A few run in both. In compile phase, SAS checks
		your syntax,	
  determines all variable types, and creates the Program Data Vector. In compile
		 phase all relevant commands are executed exactly once, and the execution
		does	not	depend 
  in any way on your actual data. The data is not even loaded into memory. This
		 means you cannot do something like</p>
<p class="InputCode">if x&gt;5 then drop x;</p>
<p>The <span class="InputCode">drop</span> command tells SAS not to write the 
  variable x to your output data set. But it is executed in compile phase, and 
  at that point SAS has no idea what the values of <span class="InputCode">x</span> 
  are.</p>
<h3>Execute Phase</h3>
<p>In execute phase, your data is loaded one observation at a time, the actual 
  work is done, and the output is written to disk. Execute phase very much depends 
  on the actual data, and can include conditional execution (ifs) and loops. But 
  keep in mind that all this is done after compile phase is complete.</p>
<table align="center" border="3" cellpadding="10" width="">
<tr valign="top">
<td align="center" nowrap="nowrap" valign="top"> <strong>All Compile Phase statements 
	  are completed before Execute Phase begins,<br/>
<em>regardless of the order they're written in!</em></strong><br/> </td>
</tr>
</table>
<h3>Order of Execution</h3>
<p>Once you reach execute phase, SAS will load one observation and execute the 
  entire data step before loading the next observation. So suppose you have a 
  data set with three observations and a data step with three statements. The 
  order of execution will be:</p>
<div align="center">
<table align="center" border="1" cellpadding="3" width="206">
<tr valign="top">
<th scope="col" width="93">Observation</th>
<th scope="col" width="93">Statement</th>
</tr>
<tr align="center" valign="top">
<td>1</td>
<td>1</td>
</tr>
<tr align="center" valign="top">
<td>1</td>
<td>2</td>
</tr>
<tr align="center" valign="top">
<td>1</td>
<td>3</td>
</tr>
<tr align="center" valign="top">
<td>2</td>
<td>1</td>
</tr>
<tr align="center" valign="top">
<td>2</td>
<td>2</td>
</tr>
<tr align="center" valign="top">
<td>2</td>
<td>3</td>
</tr>
<tr align="center" valign="top">
<td>3</td>
<td>1</td>
</tr>
<tr align="center" valign="top">
<td>3</td>
<td>2</td>
</tr>
<tr align="center" valign="top">
<td>3</td>
<td>3</td>
</tr>
</table>
</div>
<h3>The Program Data Vector</h3>
<p>The program data vector is SAS's work space. This is where an observation is 
  stored while it is being worked on. Think of it as a matrix, but there is one 
  row for each variable, and each column gives information about that variable. 
  This includes the variable type and several "flags" that tell SAS 
  how to process that variable. Below is an example of what a PDV looks like. 
  We will discuss what all the various items mean in time.</p>
<table align="center" border="1" cellpadding="3" width="716">
<tr valign="top">
<th scope="col" width="92">Name</th>
<th scope="col" valign="top" width="92">Type</th>
<th scope="col" width="92">Length</th>
<th scope="col" width="92">Retain?</th>
<th scope="col" width="92">Missing Protect?</th>
<th scope="col" width="92">Keep?</th>
<th scope="col" width="94">Value</th>
</tr>
<tr align="center" valign="top">
<td class="InputCode">x</td>
<td>Numeric</td>
<td>8</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>1</td>
</tr>
<tr align="center" valign="top">
<td class="InputCode">z</td>
<td>Numeric</td>
<td>8</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>.</td>
</tr>
</table>
<p>SAS creates the PDV during compile phase and sets all but the value at that 
  time. During execute phase the only attribute that can be changed is the value--it 
  wouldn't make sense to have <span class="InputCode">x</span> be numeric for 
  some observations and character for others, for example.</p>
<p>You should also note that the PDV only has room for one observation. When
	observation  two is loaded, SAS has no idea what is contained in observation
	one or observation  three. This used to be one of SAS's strengths, as it
	required very little memory to work with even the largest data sets. But memory
	is plentiful now, and you'll see that it takes some work to get around this
	in some situations. If your plans involve lots of calculations across observations
	(individuals living in households, for example) you should consider learning
	to use proc sql (not covered in this article) or switching to Stata.</p>
<h3>Implicit Code</h3>
<p>A key to understanding SAS is understanding what it adds to your data steps. 
  This implicit code is needed to make your explicit code work, but you need to 
  make sure it is doing what you want.</p>
<p>Suppose you write a data step that says:</p>
<p class="InputCode">data second;<br/>
<span class="indent3">set 'first';</span><br/>
  run; </p>
<p> This simply creates a temporary copy (<span class="InputCode">second</span>) 
  of the permanent data set <span class="InputCode">first</span>. I'll describe 
  what SAS actually does in pseudo-code:</p>
<p><em><strong>Top of Data Step</strong></em><br/>
<span class="indent3">Set each variable to missing if its Retain flag is set 
  to No.</span><br/>
<em><strong>Set Statement</strong></em><br/>
<span class="indent3">If there are no more observations in <span class="InputCode">first.sas7bdat</span>,
   go to <em><strong>End of Data Step</strong></em></span><br/>
<span class="indent3">Else read an observation</span><br/>
<em><strong>End of Code</strong></em><br/>
<span class="indent3">Write each variable to temporary data set <span class="InputCode">second</span> 
  if its Keep flag is set to Yes</span><br/>
<span class="indent3">Go to <em><strong>Top of Data Step</strong></em></span><br/>
<em><strong>End of Data Step</strong></em></p>
<p>Note the importance of the <span class="InputCode">set</span> statement. The 
  <span class="InputCode">set</span> statement is one of the few commands that 
  run in both compile and execute phase. In compile phase, it tells SAS to prepare 
  a place in the PDV for all the variables in the input data set. In execute phase, 
  it is the set command that actually loads an observation. If you put any execute-phase 
  code before the <span class="InputCode">set</span> statement, when that code 
  executes all the variables will either be missing or left over from the previous 
  observation. Finally, it is the <span class="InputCode">set</span> statement 
  that determines when the data set ends. This means that code before the <span class="InputCode">set</span> 
  statement will be executed one last time after the final observation has been 
  written to the output data set.</p>
<h3>The Retain Flag</h3>
<p>The Retain flag is used to prevent a variable from being reset to missing
		at  the top of the data step. This makes it a vital tool for passing
		information	
  from one observation to another. Note however, that information can only move
		 forward (without using tricks that are beyond the scope of this article).
		
  With careful use of the Retain flag, it is possible to store information from
		 observation one until observation two can use it. But observation three
		will still be	
  unknown.</p>
<p>The Retain flag is automatically set to yes for all variables that come from 
  the input data set. For new variables, you can set it using the <span class="InputCode">retain</span> 
  statement.</p>
<p class="InputCode">retain x;</p>
<p>will set the Retain flag to yes for the variable <span class="InputCode">x</span>. 
  You can also set an initial value:</p>
<p class="InputCode">retain x 5;</p>
<p>This will set the Retain flag to yes and set <span class="InputCode">the value
				of x</span> 
  to 5 in compile phase before any observations are read.</p>
<p>To see how this all works, go back to your program and change it to the following:</p>
<p class="InputCode">data out1;<br/>
<span class="indent3">a=x;</span><br/>
<span class="indent3">b=x+z;</span><br/>
<span class="indent3">set 'ex1';</span><br/>
<span class="indent3">z=x+y;</span><br/>
  run;</p>
<p class="InputCode">proc print data=out1;<br/>
  run;</p>
<p>Save it, run it, and look at the output. You're probably in for a surprise:</p>
<pre>
Obs    a     x    b     z     y

  1    .     1    .    11    10
  2    1     2    .    11     9
  3    2     3    .    11     8
  4    3     4    .    11     7
  5    4     5    .    11     6
  6    5     6    .    11     5
  7    6     7    .    11     4
  8    7     8    .    11     3
  9    8     9    .    11     2
 10    9    10    .    11     1
</pre>
<p>At first glance, this looks crazy. But it's perfectly logical--if you think 
  like SAS. Take a moment and try to figure it out yourself before reading further.</p>
<p>The variable <span class="InputCode">a</span> is set equal to <span class="InputCode">x</span>, 
  but before the <span class="InputCode">set</span> statement. Thus the first 
  time it executes, no observation has been loaded and <span class="InputCode">x</span> 
  is missing. After setting <span class="InputCode">a</span> to missing, SAS proceeds 
  to the <span class="InputCode">set</span> statement and loads the first observation, 
  so <span class="InputCode">x</span> is 1. When the other code is complete, SAS 
  then goes to the top of the data set. Because x came from the input data set, 
  its Retain flag is set to yes and <span class="InputCode">x</span> stays 1. 
  So when SAS sees <span class="InputCode">a=x;</span> for the second time, <span class="InputCode">a</span> 
  gets 1. Only after <span class="InputCode">a</span> is set does the second observation 
  (<span class="InputCode">x=2</span>) get loaded. This pattern continues for 
  all the rest of the observations, so <span class="InputCode">a</span> is always 
  one observation behind.</p>
<p>Next consider <span class="InputCode">b</span>. The first time through the
		 data step, both <span class="InputCode">x</span> and <span class="InputCode">z</span> 
  are missing, so <span class="InputCode">b</span> is missing. Then we hit the 
  <span class="InputCode">set</span> statement and the first observation is loaded
   (<span class="InputCode">x=1</span>), and then z is calculated (<span class="InputCode">z=11</span>).
    But then we go to the top of the data step. The Retain flag for <span class="InputCode">x</span> 
  is set to yes automatically, but <span class="InputCode">z</span> does not
  come from the input data set and thus its Retain flag is set to no. So when
  we come
  to <span class="InputCode">b=x+z;</span>
<span class="InputCode">x</span> is still 1, but <span class="InputCode">z</span> 
  is missing. As a result <span class="InputCode">b</span> is also set to missing
   (anything + missing = missing), and this continues for all observations.</p>
<p>Note the order in which the variables are listed: <span class="InputCode">a</span>,<span class="InputCode">x</span>,<span class="InputCode">b</span>,<span class="InputCode">z</span>,<span class="InputCode">y</span>. 
  This is not random--it is the order in which SAS encounters the variables in 
  the code. In compile phase, when SAS sees <span class="InputCode">a=x;</span> 
  it realizes it will need variables a and x, and creates entries for them in 
  the PDV. It then adds <span class="InputCode">b</span> and <span class="InputCode">z</span> 
  when it sees <span class="InputCode">b=x+z;</span>. Occasionally it is useful 
  to have the variables in a certain order. You can do it by controlling the order 
  in which SAS sees them. For example, if we wanted to make the order <span class="InputCode">a</span>,<span class="InputCode">b</span>,<span class="InputCode">x</span>,<span class="InputCode">y</span>,<span class="InputCode">z</span>, 
  you could add</p>
<p class="InputCode">retain a b x y z;</p>
<p>as the first line of the data step. Of course in this case that would change 
  the results for <span class="InputCode">b</span> (how?). It's more common that 
  it wouldn't change anything, but there are alternative commands that really 
  won't change anything.</p>
<h3>The Sum Operator</h3>
<p>SAS gives you an easy shortcut for sums; the sum operator. The syntax is simply:</p>
<p class="InputCode"><span class="Parameter">var</span>+<span class="Parameter">expression</span>;</p>
<p>Note that there is no equals sign, which may bother you if you have a programming
		 background (though C++ and Java both have something kind of similar).
		The	expression 
  will be added to the variable, almost as if you had written</p>
<p class="InputCode"><span class="Parameter">var</span>=<span class="Parameter">var</span>+<span class="Parameter">expression</span>;</p>
<p>But if you use the sum operator, SAS will do several things for you automatically. 
  First, it will set the Retain flag for the variable to yes, and give it an initial 
  value of zero.</p>
<p>It will also set the Missing Protect flag to yes. Normally if you add a missing 
  value to anything the result is a missing value. But if the Missing Protect 
  flag is set to yes, missing values are treated like zeroes. You'll have to decide 
  if this is appropriate for your analysis or not. But without this protection, 
  a single missing value will make the sum missing for all subsequent observations.</p>
<p>To see the sum operator in action, create a new file using your text editor, 
  and save it as <span class="InputCode">example2.sas</span>:</p>
<p class="InputCode">data out2;<br/>
<span class="indent3">set 'ex1';</span><br/>
<span class="indent3">count1+1;</span><br/>
<span class="indent3">count2=count2+1;</span><br/>
<span class="indent3">retain count3 0;</span><br/>
<span class="indent3">count3=count3+1;</span><br/>
<span class="indent3">count4+junk;</span><br/>
<span class="indent3">retain count5 0;</span><br/>
<span class="indent3">count5=count5+junk;</span><br/>
  run;</p>
<p><span class="InputCode">proc print data=out2;<br/>
  run;</span><br/>
</p>
<p>Run it, and you should get the following output:</p>
<pre>Obs     x     y    count1    count2    count3    count4    junk    count5

  1     1    10       1         .         1         0        .        .  
  2     2     9       2         .         2         0        .        .  
  3     3     8       3         .         3         0        .        .  
  4     4     7       4         .         4         0        .        .  
  5     5     6       5         .         5         0        .        .  
  6     6     5       6         .         6         0        .        .  
  7     7     4       7         .         7         0        .        .  
  8     8     3       8         .         8         0        .        .  
  9     9     2       9         .         9         0        .        .  
 10    10     1      10         .        10         0        .        .  
</pre>
<p>We've added five new counting variables, that add up things in various ways. 
  Let's look at each in turn.</p>
<p><span class="InputCode">count1</span> illustrates the normal sum operator. 
  For each observation we add one to <span class="InputCode">count1</span>, so 
  it ends up containing the observation number.</p>
<p><span class="InputCode">count2</span> looks like it should do the exact same 
  thing. However, we did not use the sum operator. This means that the Retain flag is not set to yes, nor is the variable initialized. As a result we are 
  adding 1 to a missing value every time, so the result is always missing.</p>
<p><span class="InputCode">count3</span> is retained and properly initialized, 
  so in this case it does work the same as the sum operator.</p>
<p><span class="InputCode">count4</span> and <span class="InputCode">count5</span> 
  illustrate the effect of the Missing Protect flag. The variable <span class="InputCode">junk</span> 
  is never set to anything, so it is always missing. Thus even 
  though <span class="InputCode">count5</span> is retained and initialized just 
  like <span class="InputCode">count3</span>, when we add <span class="InputCode">junk</span> 
  to it it becomes missing. Because <span class="InputCode">count4</span> uses 
  the sum operator, its Missing Protect flag is set to yes. Thus when junk is 
  added to it, it is treated as zero, and <span class="InputCode">count4</span> 
  is unchanged. Thus it never changes from its initial value of zero (which is 
  also set automatically just because <span class="InputCode">count4</span> uses 
  the sum operator).</p>
<h3>The Keep Flag</h3>
<p>The Keep flag determines whether or not a variable is written to the output 
  data set. It is not removed from the PDV. This means you can continue to use 
  that variable for the duration of the current data step. However if the Keep 
  flag is set to no, that variable will not appear in your output.</p>
<p>The Keep flag can be set using either the <span class="InputCode">keep</span> 
  command or the <span class="InputCode">drop</span> command.</p>
<p class="InputCode">keep x;</p>
<p>will set the Keep flag for <span class="InputCode">x</span> to yes, and the 
  Keep flag for all other variables to no. <span class="InputCode">x</span> will 
  be the only variable in your output data set.</p>
<p class="InputCode">drop y z;</p>
<p>will set the Keep flag for <span class="InputCode">y</span> and <span class="InputCode">z</span> 
  to no, and leave the Keep flag for all other variables unchanged. <span class="InputCode">y</span> 
  and <span class="InputCode">z</span> will not appear in the output data set. 
  Note that it is just fine if <span class="InputCode">drop y z;</span> is followed 
  by <span class="InputCode">x=y+z;</span> since <span class="InputCode">y</span> 
  and <span class="InputCode">z</span> are still in the PDV and can still be used.</p>
<p>Here's a puzzle for you. Consider the following data step:</p>
<p class="InputCode">data out;<br/>
<span class="indent3">set 'ex1';</span><br/>
<span class="indent3">keep count1;</span><br/>
<span class="indent3">count1+1;</span><br/>
  run;</p>
<p>Assuming <span class="InputCode">count1</span> does not exist until it is defined 
  here, does it make any difference at all what data set is used for input? Could 
  we replace <span class="InputCode">'ex1'</span> with <span class="InputCode">'2000USCensus'</span> 
  and get the exact same results in <span class="InputCode">out</span>?</p>
<p><span class="InputCode">count1</span> is the only variable that will be written 
  to <span class="InputCode">second</span>. Since we're assuming it is a new variable 
  all the variables from the input data set will be gone. So the values of the 
  variables from the input data set don't matter. However, it is the <span class="InputCode">set</span> 
  statement that determines when the data step is finished. So <span class="InputCode">out</span> 
  will have the same number of observations as the input data set. Presumably 
  a data set of US census information will have a lot more observations than the 
  ten we have in our simple little example data set, so <span class="InputCode">out</span> 
  would in fact look very different. Incidentally, this is why <span class="InputCode">example2.sas</span> 
  continued to load <span class="InputCode">ex1</span> even though we didn't care 
  about the variables it contained: we needed some observations so we could observe 
  the behavior of the <span class="InputCode">count</span> variables. </p>
<h3>Subsetting If</h3>
<p><span class="InputCode">Keep</span> and <span class="InputCode">drop</span> 
  allow you to control what variables (columns) make it into your output data 
  set. A subsetting if allows you to control what observations (rows) make it. 
  The syntax is simply</p>
<p class="InputCode">if <span class="Parameter">condition</span>;</p>
<p>The implicit "then" is usually described as "keep this observation" 
  and if the condition is not true then delete it. However, this is somewhat deceptive. 
  What really happens is that if the condition is true, the data step proceeds 
  as usual. If it is not, then SAS jumps back to the top of the data step without 
  writing any output. However, all code before the subsetting if is still executed. 
  Consider the following example:</p>
<p class="InputCode">data out3;<br/>
<span class="indent3">set 'ex1';</span><br/>
<span class="indent3">count1+1;</span><br/>
<span class="indent3">if x&gt;5;</span><br/>
<span class="indent3">count2+1;</span><br/>
  run;</p>
<p><span class="InputCode">proc print data=out3;<br/>
  run;</span><br/>
</p>
<p>Put this in its own file (<span class="InputCode">example3.sas</span>) and 
  run it. The output should look like this:</p>
<pre>Obs     x    y    count1    count2

 1      6    5       6         1  
 2      7    4       7         2  
 3      8    3       8         3  
 4      9    2       9         4  
 5     10    1      10         5  
</pre>
<p>So why are <span class="InputCode">count1</span> and <span class="InputCode">count2</span> 
  so different? Both are initialized to zero because they use the sum operator. 
  Then the first observation is loaded (x=1), and <span class="InputCode">count1</span> 
  is increased by 1. However, because <span class="InputCode">x</span> is not 
  greater than 5, when SAS hits the subsetting if this observation is not written 
  to the output data set, nor is <span class="InputCode">count2</span> increased 
  by one. Instead SAS jumps back to the start of the data step, loading the second 
  observation and increasing <span class="InputCode">count1</span> by one again. 
  This continues until the sixth observation (<span class="InputCode">x=6</span>) 
  is loaded and <span class="InputCode">count1</span> increased to 6. At this 
  point <span class="InputCode">x</span> is greater than 5 and SAS proceeds through 
  the subsetting if. Now finally <span class="InputCode">count2</span> increases 
  from zero to one, and for the first time the observation is written to the output 
  data set. As the data step proceeds, <span class="InputCode">count1</span> and 
  <span class="InputCode">count2</span> both continue to increase, but <span class="InputCode">count1</span> 
  is always five ahead.</p>
<h3>Where</h3>
<p>The <span class="InputCode">where</span> statement provides a more efficient
	method of subsetting. If you change <span class="InputCode">if x&gt;5;</span> to
	<span class="InputCode">where x&gt;5;</span> then SAS will check to see if x&gt;5
	in the next observation before it even loads it. If it is not, SAS moves
	on to the next observation.</p>
<p>Change <span class="InputCode">if x&gt;5;</span> to <span class="InputCode">where
		x&gt;5;</span> in
	your program and then run it again. This time <span class="InputCode">count1</span> is
	the same as <span class="InputCode">count2</span>. That's because SAS didn't
	even load the first five observations and thus didn't increment <span class="InputCode">count1</span>.</p>
<p>If you need to get some information out of the observations you drop before
	you drop them, a subsetting <span class="InputCode">if</span> will allow you
	to do that. Otherwise <span class="InputCode">where</span>	is usually the better
	method. </p>
<h3>_N_</h3>
<p>While we're talking about counters, SAS has one that is built in. <span class="InputCode">_N_</span> 
  is an internal variable that starts at one and is increased every time SAS goes 
  back to the top of the data step. Thus it is almost the observation number. 
  But consider what happens after the last observation is written: SAS goes back 
  to the top of the data step and _N_ is incremented again, so now it is one greater 
  than the number of observations. SAS stops only when it reaches the set statement 
  and realizes there are no more variables.</p>
<h2><a></a><a id="ProgramFlow" name="ProgramFlow"></a>Program Flow</h2>
<p>We've already seen how a subsetting if interrupts the flow of your program, 
  sending SAS back to the top of the data step if a condition is not met. But 
  you can also control the flow explicitly, executing some of your code many times 
  or not at all, depending on your data.</p>
<h3>If</h3>
<p>The basic syntax for <span class="InputCode">if</span> is just</p>
<p class="InputCode">if <span class="Parameter">condition</span> then <span class="Parameter">statement</span>;</p>
<p>The <span class="Parameter">statement</span> will be executed only if the <span class="Parameter">condition</span> 
  is true. For example</p>
<p class="InputCode">if x=5 then y=1;</p>
<p>Note that the equals sign has two distinct meanings here. In the first case 
  it is a test: is <span class="InputCode">x</span> equal to 5? In the second 
  case it is a command: make <span class="InputCode">y </span>equal to 1. Make 
  sure you know which one you mean to use. There are several other logical operators:</p>
<table align="center" border="1" width="206">
<tr valign="top">
<th scope="col" width="97">Symbol</th>
<th scope="col" width="97">Meaning</th>
</tr>
<tr align="center" valign="top">
<td class="InputCode">=</td>
<td valign="top">equal</td>
</tr>
<tr align="center" valign="top">
<td valign="top"><span class="InputCode">^= </span>or<span class="InputCode"> 
	  ~=</span></td>
<td>not equal</td>
</tr>
<tr align="center" valign="top">
<td class="InputCode" valign="top">&gt;</td>
<td>greater than</td>
</tr>
<tr align="center" valign="top">
<td class="InputCode" valign="top">&lt;</td>
<td>less than</td>
</tr>
<tr align="center" valign="top">
<td class="InputCode" valign="top">&amp;</td>
<td>logical AND</td>
</tr>
<tr align="center" valign="top">
<td valign="top"><span class="InputCode">| </span>or<span class="InputCode"> 
	  !</span></td>
<td>logical OR</td>
</tr>
</table>
<p>If you're used to other languages, note that <span class="InputCode">!=</span> 
  cannot be used for not equals. The logical AND and OR connect two conditions. 
  Logical AND means the result is true only if both conditions are true; logical 
  OR means the result is true if either condition is true. For example, suppose 
  x=5 and y=3.</p>
<p class="InputCode">if x=5 &amp; y=2</p>
<p>will be false--the first condition is true but not the second.</p>
<p class="InputCode">if x=5 | y=2</p>
<p>will be true.</p>
<p>Often logical OR is  used to see if a variable takes on one of several 
  values, but SAS has an easier alternative:</p>
<p class="InputCode">if x in(1,3,5)</p>
<p>will be true if <span class="InputCode">x</span> is 1, 3, or 5. You could do 
  the same thing with</p>
<p class="InputCode">if x=1 | x=3 | x=5</p>
<p>but this is longer to type and harder to read.</p>
<h3>Else</h3>
<p>An <span class="InputCode">else</span> tells SAS what to do if the condition 
  is not true. The syntax is:</p>
<p class="InputCode">if <span class="Parameter">condition</span> then <span class="Parameter">statement1</span>;<br/>
  else <span class="Parameter">statement2</span>;</p>
<p>If the <span class="Parameter">condition</span> is true, then <span class="Parameter">statement1</span> 
  will execute. If it is not, <span class="Parameter">statement2</span> will execute. 
  Note that <span class="Parameter">statement2</span> can also include an if, 
  which allows you to deal with many possibilities. For example,</p>
<p class="InputCode">if x&gt;0 then positive=1;<br/>
  else if x&lt;0 then negative=1;<br/>
  else zero=1;</p>
<p>Here <span class="InputCode">positive</span>, <span class="InputCode">negative</span>, 
  and <span class="InputCode">zero</span> are indicator variables, which will 
  contain a one if x is respectively positive, negative, or zero.</p>
<h3>Do Groups</h3>
<p>But what if you want to do more than one thing if a condition is true? Fortunately 
  you don't have to write the same if over and over. Instead you can group statements 
  such that SAS will treat them like one. A do group begins with <span class="InputCode">do;</span> 
  and ends with <span class="InputCode">end;</span>.</p>
<p class="InputCode">if x&gt;5 then do;<br/>
<span class="indent3">y=3;</span><br/>
<span class="indent3">z=1;</span><br/>
  end;</p>
<p>Note the indentation: SAS doesn't care but it will make it much easier for 
  you to figure out what is going on.</p>
<h3>Do Loops</h3>
<p>Do loops (for loops in most other languages) actually have very little to
	do with do groups, other than using one. They are an easy way to do something
	a  certain number of times. The syntax is </p>
<p class="InputCode">do <span class="Parameter">var</span>=<span class="Parameter">i</span> 
  to <span class="Parameter">j</span>;<br/>
<span class="indent3">{do stuff}</span><br/>
  end;</p>
<p><span class="Parameter">var</span> is just a utility variable called a loop 
  counter. It keeps track of how many times you've done the loop. Normally it 
  has no use whatsoever once the loop is done, but remember to drop it unless 
  you really want it to be in the output data set. <span class="InputCode">i</span> 
  and <span class="InputCode">j</span> are integers, with <span class="InputCode">i</span>&lt;<span class="InputCode">j</span> 
  if you want the loop to actually do anything.</p>
<p>When SAS first encounters your do loop, it sets the loop counter to <span class="InputCode">i</span>. 
  It then executes commands until it hits the corresponding <span class="InputCode">end;</span>. 
  When it sees that, it increases the loop counter by one. If at that point the 
  counter is greater than <span class="InputCode">j</span>, it proceeds. If not, 
  it goes back to the <span class="InputCode">do</span> statement.</p>
<p>Try the following (<span class="InputCode">example4.sas</span>):</p>
<p class="InputCode">data out4;<br/>
<span class="indent3">do i=1 to 10;</span><br/>
<span class="indent3"><span class="indent3">x=i;</span></span><br/>
<span class="indent3">end;</span><br/>
  run;</p>
<p class="InputCode">proc print data=out4;<br/>
  run;</p>
<p>Note that there is no input data set, and no <span class="InputCode">set</span> 
  statement. That means the code is executed just once, except for what's in the 
  loop. That also means just one observation is written to the output. But why 
  is <span class="InputCode">i</span> different from <span class="InputCode">x</span>?</p>
<pre>Obs     i     x
 1     11    10</pre>
<p>Recall that the loop counter is incremented at the end of the loop, and then 
  SAS decides whether to go back or not. So when <span class="InputCode">i</span> 
  was 10, SAS repeated the loop, and set <span class="InputCode">x</span> to 10. 
  Then <span class="InputCode">i</span> was increased to 11, SAS realized the 
  loop was done, and it proceeded to the end of the data step. That's when the 
  current values of <span class="InputCode">x</span> and <span class="InputCode">i</span> 
  were written to the output.</p>
<h3>Output</h3>
<p>Normally SAS inserts an implicit command at the end of the data step to write 
  the current tables of the PDV to the output data set. However, you can take 
  control of this process with the <span class="InputCode">output</span> command. 
  The output command tells SAS to write the PDV to the output data set immediately. 
  Furthermore, if you include an explicit output command, SAS will not add an 
  implicit one to the end of the data step. This allows you to write an observation 
  more than once, or not at all.</p>
<p>As an example, add an output statement inside the do loop of your last program 
  (<span class="InputCode">example5.sas</span>):</p>
<p class="InputCode">data out5;<br/>
<span class="indent3">do i=1 to 10;</span><br/>
<span class="indent3"><span class="indent3">x=i;</span></span><br/>
<span class="indent3"><span class="indent3">output;</span></span><br/>
<span class="indent3">end;</span><br/>
  run;</p>
<p class="InputCode">proc print data=out5;<br/>
  run;</p>
<p>We now have ten separate observations. Furthermore, the final value of <span class="InputCode">i</span> 
  changed. Why?</p>
<pre>Obs     i     x

  1     1     1
  2     2     2
  3     3     3
  4     4     4
  5     5     5
  6     6     6
  7     7     7
  8     8     8
  9     9     9
 10    10    10
</pre>
<p>Previously, when <span class="InputCode">i</span> was set to 11 the do loop 
  ended, SAS reached the end of the data step, and the observation was written. 
  Now that you have included an explicit <span class="InputCode">output</span> 
  statement, the implicit output at the end of the data step is removed. <span class="InputCode">i</span> 
  is still set to 11, but we never see it because it only happens after the 
  last <span class="InputCode">output</span> statement.</p>
<h3>Arrays</h3>
<p>One of the most common uses for do loops is to do the same thing to many variables. 
  However, to do this we need a way to refer to a collection of variables by number. 
  SAS does this by defining arrays. An array in SAS is different from any other 
  programming language. It is not used to store information; it is not a variable. 
  Rather, it is another way of referring to existing variables--a way that is 
  highly convenient for do loops.</p>
<p>To define an array, the syntax is</p>
<p class="InputCode">array <span class="Parameter">name</span>(<span class="Parameter">n</span>) 
  <span class="Parameter">variable1</span> <span class="Parameter">variable2</span>...;</p>
<p>For example:</p>
<p class="InputCode">array vars(3) x y z;</p>
<p>Once we've done this, <span class="InputCode">vars(1)</span> is just another 
  name for <span class="InputCode">x</span>, <span class="InputCode">vars(2)</span> 
  for <span class="InputCode">y</span> and <span class="InputCode">vars(3)</span> 
  for <span class="InputCode">z</span>.</p>
<p>Let's double the values of all the variables in our data set (<span class="InputCode">example6.sas</span>).</p>
<p class="InputCode">proc print data='ex1';<br/>
  run;</p>
<p class="InputCode">data out6;<br/>
<span class="indent3">set 'ex1';</span><br/>
<span class="indent3">array vars(2) x y;</span><br/>
<span class="indent3">do i=1 to 2;</span><br/>
<span class="indent3"><span class="indent3">vars(i)=vars(i)*2;</span></span><br/>
<span class="indent3">end;</span><br/>
  run;</p>
<p class="InputCode">proc print data=out6;<br/>
  run;</p>
<p>Now in this case setting up the array and the do loop was a good bit more work 
  than just writing</p>
<p class="InputCode">x=x*2;<br/>
  y=y*2;</p>
<p>But suppose you had a hundred variables--then the advantage would be obvious.</p>
<p>Note that array definitions only last for the duration of the data step. 
  But they are easy to copy and paste from one data step to another.</p>
<h3>Variable Lists</h3>
<p>On the other hand, writing out the names of all one hundred variables would 
  get pretty tedious. Fortunately SAS has some shortcuts for writing out lists 
  of variables. They can be used in more than just array definitions (you can 
  use them in <span class="InputCode">retain</span>, <span class="InputCode">drop</span>, 
  and <span class="InputCode">keep</span> statements for example), but they are 
  particularly useful in array definitions.</p>
<p>If you have variables with some sort of stem and then a number (<span class="InputCode">var1</span>, 
  <span class="InputCode">var2</span>, <span class="InputCode">var3</span>, etc.) 
  you can use a number list. Just put a dash between the first and last variables 
  (<span class="InputCode">var1-var3</span>).</p>
<p>You can always use a position list. Suppose you had variables <span class="InputCode">a</span>, 
  <span class="InputCode">b</span>, <span class="InputCode">c</span>, <span class="InputCode">x</span>, 
  <span class="InputCode">y</span>, <span class="InputCode">z</span>, in that 
  order. You could refer to them all by putting a double dash between <span class="InputCode">a</span> 
  and <span class="InputCode">z</span> (<span class="InputCode">a--z</span>). 
  Just remember that the variables must be in the proper order for this to work--recall 
  our discussion of how SAS decides what order to put variables in.</p>
<p>There are also several special purpose lists you can designate by name. These 
  include <span class="InputCode">_all_</span> for all variables, <span class="InputCode">_numeric_</span> 
  for all numeric variables, and <span class="InputCode">_character_</span> for 
  all character variables.</p>
<p>Finally you can use a wildcard. The colon (<span class="InputCode">:</span>) 
  will match anything, or nothing. For example, <span class="InputCode">var:</span> 
  would include <span class="InputCode">var</span>, <span class="InputCode">var1</span>, 
  <span class="InputCode">var2</span>, <span class="InputCode">variable</span>, 
  <span class="InputCode">variety</span>, and anything else that starts with <span class="InputCode">var</span>.</p>
<p>These kinds of shortcuts can sometimes make it less than obvious just how many 
  elements your array has. In your array definition you can just put an asterisk 
  (<span class="InputCode">*</span>) in the parenthesis and SAS will give the 
  array as many elements as there are variables in your list. You can also use 
  the <span class="InputCode">dim() </span>function to find out how many elements 
  an array has, for example to figure out how many times a do loop needs to execute. 
  Try the following changes (<span class="InputCode">example7.sas</span>--just 
  save <span class="InputCode">example6.sas</span> with the new file name and 
  then make the changes):</p>
<p class="InputCode">proc print data='ex1';<br/>
  run;</p>
<p class="InputCode">data out7;<br/>
<span class="indent3">set 'ex1';</span><br/>
<span class="indent3">array vars(*) _all_;</span><br/>
<span class="indent3">do i=1 to dim(vars);</span><br/>
<span class="indent3"><span class="indent3">vars(i)=vars(i)*2;</span></span><br/>
<span class="indent3">end;</span><br/>
  run;</p>
<p><span class="InputCode">proc print data=out7;<br/>
  run;</span><br/>
</p>
<p>Note that <span class="InputCode">i</span> was not doubled. Why?</p>
<pre>Obs     x     y    i

  1     2    20    3
  2     4    18    3
  3     6    16    3
  4     8    14    3
  5    10    12    3
  6    12    10    3
  7    14     8    3
  8    16     6    3
  9    18     4    3
 10    20     2    3</pre>
<p>Remember that SAS works through the code line by line in compile phase. So 
  when it saw the array definition, it had not yet seen any reference to the variable 
  <span class="InputCode">i</span>. Thus <span class="InputCode">i</span> was 
  not yet in the PDV, and <span class="InputCode">_all_</span> consisted solely 
  of <span class="InputCode">x </span>and <span class="InputCode">y</span>. This 
  can be a good thing--it can be really confusing if you're trying to loop over 
  an array that contains the loop counter.</p>
<p>A puzzle for you: if <span class="InputCode">i</span> had been defined before 
  the array (say, with a <span class="InputCode">retain</span> statement), what 
  value would it have in the output data set?</p>
<p>The answer is 7. Can you see why?</p>
<h3>By, First, and Last</h3>
<p>Often data sets have some sort of group structure. For example, individuals
	 may live in households. To be honest, SAS data steps don't handle this kind
	 of situation very well, because they only have one observation in memory
	at a time. If you are planning to work with this kind of data, you should
	consider learning either proc sql or Stata. But the tools SAS does have are
	important to learn.</p>
<p>The first step is to identify what makes up a group. You do this with the <span class="InputCode">by</span> 
  statement. The syntax is just:</p>
<p class="InputCode">by <span class="Parameter">variable1</span> <span class="Parameter">variable2</span>...;</p>
<p>For example, if <span class="InputCode">hhid</span> was a household id,</p>
<p class="InputCode">by hhid;</p>
<p>This allows you to use first and last. These are conditions that will be true 
  if SAS currently has the first or last observation of the group in memory. The 
  syntax is <span class="InputCode">first.</span><span class="Parameter">variable</span> 
  or <span class="InputCode">last.</span><span class="Parameter">variable</span>, 
  as in</p>
<p class="InputCode">if first.hhid then <span class="Parameter">(do something)</span>;<br/>
  else if last.hhid then <span class="Parameter">(do something else)</span>;</p>
<p>There is one additional requirement for using <span class="InputCode">by</span>, 
  and that is the data must be sorted by the <span class="InputCode">by</span> 
  variables. Which leads us to...</p>
<h3>Proc Sort</h3>
<p>Proc sort is a utility proc that sorts data. The syntax is </p>
<p class="InputCode">proc sort data=<span class="Parameter">input</span> out=<span class="Parameter">output</span>;<br/>
<span class="indent3">by <span class="Parameter">variables</span>;</span><br/>
  run;</p>
<p>where <span class="Parameter">input</span> is an existing data set and <span class="Parameter">output</span> 
  is a data set that will be created. For example,</p>
<p class="InputCode">proc sort data=first out=second;<br/>
<span class="indent3">by x;</span><br/>
  run;</p>
<p>If you list more than one variable, the data set will first be sorted by the 
  first variable in the list, then ties will be sorted by the second variable, 
  etc. If you need to sort in descending order, just add the word <span class="InputCode">descending</span> 
  before that variable. For example:</p>
<p class="InputCode">proc sort data=first out=second;<br/>
<span class="indent3">by x descending y;</span><br/>
  run;</p>
<h2><a id="ExampleWorkingwithHouseholds" name="ExampleWorkingwithHouseholds"></a>Example: Working with Households</h2>
<p>We're now going to do an example. As we work through it, try to 
  think of your own solutions, but don't be discouraged if you nothing workable 
  comes to mind. Learning to think like SAS is important but it takes time. As you'll see later there's an easier way to do this task using a proc, but it's important to know how to do such things yourself for those times when you need to calculate something that isn't built into a proc.</p>
<p>Start by taking a look at the tables of <span class="InputCode">ex2.sas7bdat</span>. 
  You should have no problem writing a program that will allow you to do so, so 
  try before you read on.</p>
<p>The solution, of course, is just a proc print:</p>
<p class="InputCode">proc print data='ex2';<br/>
  run;</p>
<p>We have here a data set of individuals, each living in households. You are 
  given the income of each individual, but your task is to create a new variable 
  containing the total household income of each household. Before proceeding, 
  try to describe how to do this in English. The trick is to remember that SAS 
  only knows about one observation at a time.</p>
<p>The basic procedure will be to add up the income from each individual. But 
  this means the calculation won't be complete until we reach the last individual 
  in each household. So the second step will be to reverse the order of the observations 
  and then take that correct value of household income from the last observation 
  and copy it to all the other observations (remember information can only move 
  forwards).</p>
<p>As a first try at the first part, try the following.</p>
<p class="InputCode">data step1;<br/>
<span class="indent3">set 'ex2';</span><br/>
<span class="indent3">hhinc+income;</span><br/>
  run;</p>
<p class="InputCode">proc print data=step1;<br/>
  run;</p>
<p> What is wrong? What's needed to fix it?</p>
<pre>Obs    hhid    id    income     hhinc

  1      1      1     30000     30000
  2      1      2     45000     75000
  3      1      3         0     75000
  4      2      4     60000    135000
  5      2      5     55000    190000
  6      3      6     42000    232000
  7      4      7     90000    322000
  8      4      8     15000    337000
  9      4      9         0    337000
 10      5     10     25000    362000</pre>
<p>The problem is that the <span class="InputCode">hhinc</span> variable is ending 
  up with a running sum of all incomes, not just the incomes of the people in 
  each household. What we need is a way to "start over" when we start 
  a new household. Try to write it before reading the following:</p>
<p class="InputCode">data step1;<br/>
<span class="indent3">set 'ex2';</span><br/>
<span class="indent3">by hhid;</span><br/>
<span class="indent3">if first.hhid then hhinc=0;</span><br/>
<span class="indent3">hhinc+income;</span><br/>
  run;</p>
<p class="InputCode">proc print data=step1;<br/>
  run;</p>
<p>The output will be:</p>
<pre>Obs    hhid    id    income     hhinc

  1      1      1     30000     30000
  2      1      2     45000     75000
  3      1      3         0     75000
  4      2      4     60000     60000
  5      2      5     55000    115000
  6      3      6     42000     42000
  7      4      7     90000     90000
  8      4      8     15000    105000
  9      4      9         0    105000
 10      5     10     25000     25000</pre>
<p>So now you have the correct household income, but only for the last individual 
  in the household (actually, the last person with a non-zero income and everyone 
  after them). Now you need to make that last observation first. Obviously this 
  will require proc sort, but try to write it yourself.</p>
<p class="InputCode">proc sort data=step1 out=step2;<br/>
<span class="indent3">by hhid descending hhinc;</span><br/>
  run;</p>
<p>This sort doesn't necessarily reverse the order of observations in each household, 
  but it does guarantee that someone with the correct household income will be 
  first in each household. Now you just need to give every person in each household 
  the same value for household income as the first person in that household. The 
  easiest way involves creating a new variable and then dropping our current <span class="InputCode">hhinc</span>. 
  See if you can take it from there before proceeding.</p>
<p class="InputCode">data final;<br/>
<span class="indent3">set step2;</span><br/>
<span class="indent3">by hhid;</span><br/>
<span class="indent3">retain hhincome;</span><br/>
<span class="indent3">if first.hhid then hhincome=hhinc;</span><br/>
<span class="indent3">drop hhinc;</span><br/>
  run;</p>
<p class="InputCode">proc print data=final;<br/>
  run;</p>
<p>Note that <span class="InputCode">hhincome</span> is retained. This means it 
  is only changed when we explicitly change it. When we reach the first observation 
  in a new household, we set <span class="InputCode">hhincome</span> to their 
  <span class="InputCode">hhinc</span> variable (recall that this value is correct 
  for the first observation in each household). For the second and subsequent 
  observations, <span class="InputCode">hhincome</span> simply stays the same. 
  Add a proc print so you can see the results and you're done.</p>
<pre>Obs    hhid    id    income    hhincome

  1      1      2     45000      75000 
  2      1      3         0      75000 
  3      1      1     30000      75000 
  4      2      5     55000     115000 
  5      2      4     60000     115000 
  6      3      6     42000      42000 
  7      4      8     15000     105000 
  8      4      9         0     105000 
  9      4      7     90000     105000 
 10      5     10     25000      25000 </pre>
<p>For an alternative way of doing the same task, see the example under merging.</p>
<h2><a id="ExampleReshapingData" name="ExampleReshapingData"></a>Example: Reshaping Data</h2>
<p>Any data that has groups and subgroups (for example, individuals living in 
  households) can be presented in two forms. In the long form, each subgroup has 
  its own observation--the data set used in the last example was in this form. 
  In the wide form, each group is just one observation, and there is a separate 
  set of variables for each subgroup. The dataset <span class="InputCode">whh.sas7bdat</span> 
  is in this form. For whatever reason the wide form seems to be more common with 
  data sources. However, the long form is usually more useful for analysis. So 
  it is a common task to have to reshape data from the wide form to the long. 
  We'll also learn how to convert long to wide, just in case.</p>
<p>In the long form you will have just one age and one sex variable for each individual, 
  not the four age and sex variables per observation you have now (note that sex 
  is stored as an indicator variable). You will also be creating multiple observations 
  from each currently existing observation. This calls for putting an output statement 
  inside a do loop. Since you're using a do loop, you will have a loop counter 
  variable telling you which observation you're writing--you can also use this 
  to pick which age and sex to write by putting them all in an array. Consider 
  this as a first try:</p>
<p class="InputCode">data long;<br/>
<span class="indent3">set 'ex3';</span><br/>
<span class="indent3">keep hhinc hhid age sex;</span><br/>
<span class="indent3">array ages(4) age1-age4;</span><br/>
<span class="indent3">array sexes(4) sex1-sex4;</span><br/>
<span class="indent3">do i=1 to 4;</span><br/>
<span class="indent3"><span class="indent3">age=ages(i);</span></span><br/>
<span class="indent3"><span class="indent3">sex=sexes(i);</span></span><br/>
<span class="indent3"><span class="indent3">output;</span></span><br/>
<span class="indent3">end;</span><br/>
  run;</p>
<p class="InputCode">proc print data=long;<br/>
  run;</p>
<p>Here <span class="InputCode">i</span> is your loop counter, but it also tells 
  you which observation you're writing. When <span class="InputCode">i</span> 
  is one, you are writing the first individual in the household, and thus set 
  <span class="InputCode">age</span> to <span class="InputCode">age1</span> and 
  <span class="InputCode">sex</span> to <span class="InputCode">sex1</span>. When 
  <span class="InputCode">i</span> is 2, we are working with the second individual 
  and use <span class="InputCode">age2</span> and <span class="InputCode">sex2</span>, 
  etc. There's just one problem with the result. Can you see it?</p>
<pre>Obs    HHID    HHINC    age    sex

  1      1     50000     30     0 
  2      1     50000     28     1 
  3      1     50000      3     0 
  4      1     50000      .     . 
  5      2     80000     45     0 
  6      2     80000     47     1 
  7      2     80000     12     1 
  8      2     80000      8     0 
  9      3     40000     25     1 
 10      3     40000      .     . 
 11      3     40000      .     . 
 12      3     40000      .     . </pre>
<p>Because every observation must have all variables, our original data has ages 
  and sexes defined for four people in each household. However, they are all needed 
  only in household two. Household one has three members, and household three 
  has just one. But our program creates four observations per household regardless.</p>
<p>The solution is to add an if condition before the output statement. We will
		 only output an observation if either <span class="InputCode">sex</span> or <span class="InputCode">age</span> 
  is non-missing. If both variables are missing, we assume the person does not
   actually exist. This is not an entirely innocuous assumption. It does not
  distinguish 
  between a household with less than four people and a household containing a
   person whose sex and age really weren't determined. However, it is usually
  unavoidable. 
  In the wide form, the number of variables is determined by the largest group,
   so in real data sets there may be room for twenty or more individuals in each
  
  household. Leaving them all in your analysis is probably not an option.</p>
<p>The appropriate modification is:</p>
<p class="InputCode">data long;<br/>
<span class="indent3">set 'ex3';</span><br/>
<span class="indent3">keep hhinc hhid age sex;</span><br/>
<span class="indent3">array ages(4) age1-age4;</span><br/>
<span class="indent3">array sexes(4) sex1-sex4;</span><br/>
<span class="indent3">do i=1 to 4;</span><br/>
<span class="indent3"><span class="indent3">age=ages(i);</span></span><br/>
<span class="indent3"><span class="indent3">sex=sexes(i);</span></span><br/>
<span class="indent3"><span class="indent3">if age~=. | sex~=. output;</span></span><br/>
<span class="indent3">end;</span><br/>
  run;</p>
<p class="InputCode">proc print data=long;<br/>
  run;</p>
<p>And the result will be:</p>
<pre>Obs    HHID    HHINC    age    sex

 1       1     50000     30     0 
 2       1     50000     28     1 
 3       1     50000      3     0 
 4       2     80000     45     0 
 5       2     80000     47     1 
 6       2     80000     12     1 
 7       2     80000      8     0 
 8       3     40000     25     1 </pre>
<p>Now let's convert it back. This time, you need to combine multiple observations 
  into one observation. But you won't need to write a loop: SAS is already looping 
  over observations. What you will need to do is keep track of which observation 
  in the household you are working with, and then write the result when you are 
  all done. "All done" means you've read the last observation, so that's 
  a job for <span class="InputCode">by</span> and <span class="InputCode">last</span>. 
  Keeping track of which observation you're on is a job for a loop counter, so 
  we'll create one for ourselves even though SAS is doing the looping. Add the 
  following to your code.</p>
<p class="InputCode">data wide;<br/>
<span class="indent3">set long;</span><br/>
<span class="indent3">array ages(4) age1-age4;</span><br/>
<span class="indent3">array sexes(4) sex1-sex4;</span><br/>
<span class="indent3">by hhid;</span><br/>
<span class="indent3">if first.hhid then n=1;</span><br/>
<span class="indent3">ages(n)=age;</span><br/>
<span class="indent3">sexes(n)=sex;</span><br/>
<span class="indent3">if last.hhid then output;</span><br/>
<span class="indent3">n+1;</span><br/>
<span class="indent3">drop n sex age;</span><br/>
  run;</p>
<p class="InputCode">proc print data=wide;<br/>
  run;</p>
<p>Try running this. What's wrong?</p>
<pre>Obs    HHID    HHINC    age1    age2    age3    age4    sex1    sex2    sex3    sex4

 1       1     50000      .       .       3       .       .       .       0       . 
 2       2     80000      .       .       .       8       .       .       .       0 
 3       3     40000     25       .       .       .       1       .       .       . 
</pre>
<p>The last person in each household is being stored properly, but the others 
  are missing. That's because the age and sex variables are not retained. Thus 
  SAS resets them to missing every time it loads a new observation. So when we 
  get to the last observation in each household, all the previous information 
  is gone. The solution is just to add a retain statement:</p>
<p class="InputCode">data wide;<br/>
<span class="indent3">set long;</span><br/>
<span class="indent3">retain age1-age4 sex1-sex4; </span><br/>
<span class="indent3">array ages(4) age1-age4;</span><br/>
<span class="indent3">array sexes(4) sex1-sex4;</span><br/>
<span class="indent3">by hhid;</span><br/>
<span class="indent3">if first.hhid then n=1;</span><br/>
<span class="indent3">ages(n)=age;</span><br/>
<span class="indent3">sexes(n)=sex;</span><br/>
<span class="indent3">if last.hhid then output;</span><br/>
<span class="indent3">n+1;</span><br/>
<span class="indent3">drop n sex age;</span><br/>
  run;</p>
<p class="InputCode">proc print data=wide;<br/>
  run;</p>
<p>Try running it again. Now what's wrong?</p>
<pre>Obs    HHID    HHINC    age1    age2    age3    age4    sex1    sex2    sex3    sex4

 1       1     50000     30      28       3       .       0       1       0       . 
 2       2     80000     45      47      12       8       0       1       1       0 
 3       3     40000     25      47      12       8       1       1       1       0 </pre>
<p>The problem is household three. It should have just one individual living in 
  it, but our data set lists four. The other three came from household two. Retain 
  doesn't do anything special as a result of <span class="InputCode">by</span> 
  groups, so when we moved from household two to household three, all the age 
  and sex variables stayed the same. <span class="InputCode">age1</span> and <span class="InputCode">sex1</span> 
  were then overwritten by the actual person living in household three, but the 
  other variables were not.</p>
<p>We need to tell SAS to set all the ages and sexes to missing when we are ready 
  to move on to a new household. This is easy to do:</p>
<p class="InputCode">data wide;<br/>
<span class="indent3">set long;</span><br/>
<span class="indent3">retain age1-age4 sex1-sex4;</span><br/>
<span class="indent3">array ages(4) age1-age4;</span><br/>
<span class="indent3">array sexes(4) sex1-sex4;</span><br/>
<span class="indent3">by hhid;</span><br/>
<span class="indent3">if first.hhid then n=1;</span><br/>
<span class="indent3">ages(n)=age;</span><br/>
<span class="indent3">sexes(n)=sex;</span><br/>
<span class="indent3">if last.hhid then do;</span><br/>
<span class="indent3"><span class="indent3">output;</span></span><br/>
<span class="indent3"><span class="indent3">do i=1 to 4;</span></span><br/>
<span class="indent3"><span class="indent3"><span class="indent3">ages(i)=.;</span></span></span><br/>
<span class="indent3"><span class="indent3"><span class="indent3">sexes(i)=.;</span></span></span><br/>
<span class="indent3"><span class="indent3">end;</span></span><br/>
<span class="indent3">end;</span><br/>
<span class="indent3">n+1;</span><br/>
<span class="indent3">drop i n sex age;</span><br/>
  run;</p>
<p class="InputCode">proc print data=wide;<br/>
  run;</p>
<p>Note how the indentation makes it easy to see the logic of the program, even 
  though we have several different layers. Your output should be:</p>
<pre>Obs    HHID    HHINC    age1    age2    age3    age4    sex1    sex2    sex3    sex4

 1       1     50000     30      28       3       .       0       1       0       . 
 2       2     80000     45      47      12       8       0       1       1       0 
 3       3     40000     25       .       .       .       1       .       .       . </pre>
<h2>Data Set Options</h2>
<p>SAS can do some work with an input data set before your data step ever sees 
  it, or with an output data set after your data step is done with it. You control 
  this by setting various data set options. These are statements in parenthesis 
  immediately following the data set name--either the name of the output data 
  set in the <span class="InputCode">data</span> statement, or the name of the 
  input data <span class="InputCode">set</span> in the set statement. They can 
  also be used in procs. For example:</p>
<p class="InputCode">proc print data=bigDataSet (obs=20);<br/>
  run;</p>
<p>This will print just the first 20 observations from <span class="InputCode">bigDataSet</span>, 
  so you can look them over.</p>
<p>Some of the more commonly used options include:</p>
<p class="InputCode">(obs=<span class="Parameter">n)</span></p>
<p>This causes SAS to stop processing after n observations. This is extremely 
  useful in testing your code. You can have SAS run your program on just the first 
  100 observations to make sure it works, or have SAS print just some of the observations 
  so you can look at them, as in the above example.</p>
<p class="InputCode">(where=(<span class="Parameter">condition</span>))</p>
<p>This has the same function as the <span class="InputCode">where</span> statement.
	Observations which do not meet the condition are never even loaded. The differences
	are where it goes (right after the data set as opposed to its own line) and
	the equals sign. </p>
<p class="InputCode">(drop=(<span class="Parameter">variables</span>))</p>
<p class="InputCode">(keep=(<span class="Parameter">variables</span>))</p>
<p>These are similar to the <span class="InputCode">keep</span> and <span class="InputCode">drop</span> 
  commands inside a data step (again note the equals sign), but if applied
  	to  the input data set the variables not selected are never loaded. Again,
  	it as  if they didn't exist.</p>
<p class="InputCode">(rename=(oldName1=newName1 oldName2=newName2))</p>
<p>This option allows you to rename variables, and if applied to input the name
	 is changed before the data is even loaded.</p>
<p>If you want to apply more than one option, they go in the same set of parentheses: </p>
<p class="InputCode">proc print data=bigDataSet (obs=20 where=(x&gt;10));<br/>
run;</p>
<p>Note that your code will be run more quickly if it has to work with less data.
	If you will be cutting down the number of observations or variables at some
	point, doing it with using data set options on the input data set where possible
	will be the most efficient.</p>
<h2>Combining Data Sets</h2>
<p>Combining data sets is a very common task in SAS. Often the data come in pieces 
  or from multiple sources, or you may generate a data set you need to combine 
  with the original data. SAS has a couple different tools for combining data 
  sets, depending on how they need to go together.</p>
<h3>Appending Data Sets</h3>
<p><img alt="Appending two data sets is like stacking them on top of each other." height="288" hspace="0" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-18/4-18_1.png" vspace="0" width="432"/></p>
<p>If you just need to add the observations from two data sets together, this 
  is called appending. For example if you had one data set of domestic cars and 
  another of foreign cars, you could append them to make a single data set of 
  all cars. Normally you would only do this if the two data sets have the same 
  (or almost the same) variables. If one data set has a variable that the second 
  data set doesn't, all the observations from the second data set will be assigned 
  missing values for that variable.</p>
<p>Appending data sets if very simple in SAS: simply list all the data sets you 
  wish to append in the set statement. Consider the following:</p>
<p class="InputCode">data combined;<br/>
<span class="indent3">set set1 set2 set3;</span><br/>
  run;</p>
<p>The output data set, <span class="InputCode">combined</span>, will contain 
  all the observations from <span class="InputCode">set1</span>, then all the 
  observations from <span class="InputCode">set2</span>, and finally all the observations 
  from <span class="InputCode">set3</span>. It will have all the variables used 
  by any of these data sets, and if any of the input data sets are missing a variable 
  it will be missing in that data set's observations.</p>
<h3>Merging</h3>
<p><img alt="Merging two data sets is like setting them side by side." height="432" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-18/4-18_2.png" width="432"/></p>
<p>If two data sets have the same (or almost the same) observations but different 
  variables, you combine them with a merge. For example, if one data set had car 
  names and prices, and another had car names, weights, and fuel efficiency, you 
  could merge them to create a singe data set with all the data available. Note 
  that if a car appeared in one data set but not the other, it will have missing 
  values for all the variables from the other data set.</p>
<p>Note that in my example, name appeared in both data sets. This is important 
  because it will be the identifier used to link observations. Assuming every 
  car has a unique name, this is an example of a one-to-one merge. But suppose 
  you had one data set of individuals including the state they live in, and another 
  data set containing welfare benefit levels for each state. You could perform 
  a merge that creates a data set of individuals and the welfare benefits available 
  to them, but each state would be merged with many individuals. This is an example 
  of a one-to-many merge. Logically it is also possible to have many-to-many merges, 
  but these are more likely to be the result of logical errors or problems with 
  the data sets.</p>
<p>The syntax for a merge is the same no matter what kind it is:</p>
<p class="InputCode">data combined;<br/>
<span class="indent3">merge set1 set2;</span><br/>
<span class="indent3">by matchvar;</span><br/>
  run;</p>
<p>Here <span class="InputCode">matchvar</span> is the variable that will be
		used to link the observations. In our first example, it would be the
		name of	the
  car; in the second the name of the state. It is possible to link by  multiple
		 variables. In that case observations will be merged only if they have
		the	same
		values for all the match variables.</p>
<p>Sometimes it's important to know whether an observation was successfully matched 
  between the two data sets. For example, you may want to get rid of observations 
  that are incomplete (be careful though, as this could bias your analysis). You 
  can tell SAS to create a new variable indicating whether a data set contributed 
  to an observation with the <span class="InputCode">in</span> data set option. 
  The syntax is just <span class="InputCode">in=variable</span>, but  the 
  variable thus created is only temporary. It's gone even before you can use it 
  in data set options for the output data set. So if you need to keep those values, 
  store them in another variable. Here's another version of the last example, 
  but one which only keeps observations that exist in both data sets:</p>
<p class="InputCode">data combined (drop=in1 in2 where=(in1=1 &amp; in2=1));<br/>
<span class="indent3">merge set1 (in=temp1) set2 (in=temp2);</span><br/>
<span class="indent3">by matchvar;</span><br/>
<span class="indent3">in1=temp1;</span><br/>
<span class="indent3">in2=temp2; </span><br/>
  run;</p>
<h2>Example: Households Again</h2>
<p>An alternative way to find household incomes is let proc means do all the hard 
  work and then merge in the results. See the <a href="http://support.sas.com/onlinedoc/912/getDoc/proc.hlp/a000146728.htm">SAS
  documentation</a> for more details 
  about proc means. We will use it to create a data set containing just the household 
  incomes for each household:</p>
<p class="InputCode">proc means data='ex2';<br/>
<span class="indent3">by hhid;</span><br/>
<span class="indent3">var income;</span><br/>
<span class="indent3">output out=households sum(income)=hhincome;</span><br/>
  run;</p>
<p class="InputCode">proc print data=households;<br/>
  run;</p>
<p>The households data set will contain the following:</p>
<pre>Obs    hhid    _TYPE_    _FREQ_    hhincome

 1       1        0         3        75000 
 2       2        0         2       115000 
 3       3        0         1        42000 
 4       4        0         3       105000 
 5       5        0         1        25000 </pre>
<p>We have a couple extra variables we don't need, but we'll get rid of them later. 
  Now all we need to do is merge the household income data with the original data 
  set. Note that this is a one to many merge (one household matches with many 
  individuals) and that our match variable is <span class="InputCode">hhid</span>. 
  We'll also get rid of the extra variables proc means created.</p>
<p class="InputCode">data hhincomes;<br/>
<span class="indent3">merge 'ex2' households (drop=_TYPE_ _FREQ_);</span><br/>
<span class="indent3">by hhid;</span><br/>
  run;</p>
<p class="InputCode">proc print data=hhincomes;<br/>
  run;</p>
<p>You'll notice that this method is shorter and simpler than what you did before--which 
  is what you would expect since you used a pre-written tool (proc means) rather 
  than doing all the work yourself. The previous example was mostly intended as 
  a learning experience, though if you needed to calculate a function not covered 
  by proc means you might have to do something similar.</p>
<h2>Using your Log File</h2>
<p>In the unlikely event it hasn't happened already, be aware that quite often 
  your programs won't run properly the first time. Or the second. Or the third. 
  Debugging often takes as long as writing the program itself, or longer. In these 
  cases your best hope for understanding what SAS thinks your program means (as 
  opposed to what you think it means) is to look closely at your log file.</p>
<p>SAS puts a lot of information in your log file--sometimes too much. It can 
  be tempting to skip looking at it and jump straight to the output (the <span class="InputCode">.lst</span> 
  file). Resist this temptation. An error in your code can make your output meaningless. 
  One common scenario is that the program failed before reaching the commands 
  that generate output and as a result the <span class="InputCode">.lst</span> 
  file you're reading is from a previous, presumably even more buggy, run. Your 
  text editor can help you: do a search for the word ERROR. If it doesn't exist, 
  at least you know your program ran all the way through (though you don't know 
  for sure it did what you intended). If it does, you'll know where things went 
  wrong.</p>
<p>If you do find a syntax error, some of the most common causes are simple.</p>
<h3>Missing Semicolon</h3>
<p>This is undoubtedly the most common error. The problem here is that SAS will 
  attempt to interpret the next command as part of the last command. What makes 
  it particularly confusing is that SAS will blame the error on the command after 
  the missing semicolon, so you may miss the problem with the line above. Here's 
  an example from some code we've used previously:</p>
<p class="InputCode"> keep hhinc hhid age sex<br/>
  array ages(4) age1-age4;</p>
<p>Note that there should be a semicolon at the end of the first line. Here is 
  an excerpt from the log:</p>
<pre>4          data long;
5          	set 'whh';
6          	keep hhinc hhid age sex
7          	array ages(4) age1-age4;
                     _
                     22
                     76
ERROR 22-322: Syntax error, expecting one of the following: a name, -, :, ;, _ALL_, _CHARACTER_, _CHAR_, _NUMERIC_.  

ERROR 76-322: Syntax error, statement will be ignored.

8          	array sexes(4) sex1-sex4;
9          	do i=1 to 4;
10         		age=ages(i);
                 ____
                 68
ERROR 68-185: The function AGES is unknown, or cannot be accessed.
</pre>
<p>Note the line underneath the word <span class="InputCode">ages(4)</span>, with 
  two numbers underneath that. That indicates where SAS ran into a problem, and 
  the numbers direct you to the corresponding ERROR messages. SAS still thinks 
  it's working on a <span class="InputCode">keep</span> statement, so it's looking 
  for variables or lists of variables. <span class="InputCode">array</span> is 
  a perfectly good variable name (which is unfortunate in a some ways) but <span class="InputCode">ages(4)</span> 
  fails because of the parentheses.</p>
<p>The second error message arises because the array <span class="InputCode">ages()</span> 
  has not been defined. Thus SAS thinks it is a function. This is a common problem: 
  one error causes a cascade of error messages later in the code. Normally if 
  you can see and correct one error, it's worthwhile to run the program again 
  before spending any significant time trying to figure out any subsequent errors. 
  They may take care of themselves.</p>
<h3>Endless Quotes or Comments</h3>
<p>SAS uses quotes--single or double--to mark off text that should be treated 
  in a special way. If the end quote is missing, SAS will get very confused. Consider 
  the following:</p>
<p class="InputCode">set 'whh;</p>
<p>Note the missing single quote at the end of the file name. In the log you'd 
  see that SAS got to this point, and then the entire rest of the program will 
  be printed to the log without any indication SAS tried to execute it. Finally, 
  you'll see SAS complaining that it's not seeing what it's expecting and that 
  it can't open a data set.</p>
<p>The problem is that without an end quote, SAS thinks the entire rest of the 
  program is the file name for the input data set. And since it still doesn't 
  end with a quote and a semicolon, you finally get an error message at the end 
  of the program.</p>
<p>A related problem can occur with comments. SAS will ignore any text in between 
  <span class="InputCode">/*</span> and <span class="InputCode">*/</span>. This 
  allows you to write explanatory notes for yourself or others that read your 
  code--a very good idea. However, if you forget the <span class="InputCode">*/</span> 
  at the end, the rest of your program will be ignored completely.</p>
<p>TextPad and Emacs with ESS make it easy to catch these kinds of errors because 
  they put strings in quotes and comments in distinctive colors. If half your 
  program suddenly turns "comment green" that's a good indication that 
  you forgot to end a comment somewhere in the middle of it.</p>
<h3>Typos</h3>
<p>Obviously any typos in your code may cause problems. It's not as guaranteed 
  as you might think:</p>
<p class="InputCode">dat long;</p>
<p>will actually get you:</p>
<p class="InputCode">WARNING 14-169: Assuming the symbol DATA was misspelled as 
  dat.</p>
<p>As long as SAS is correct, this is good. Obviously there are limits:</p>
<p class="InputCode">da long;</p>
<p>gets you:</p>
<pre>4          da long;
           __
           180

ERROR 180-322: Statement is not valid or it is used out of proper order.

5          	set 'whh';
            ___
            180

ERROR 180-322: Statement is not valid or it is used out of proper order.

6          	keep hhinc hhid age sex;
            ____
            180


ERROR 180-322: Statement is not valid or it is used out of proper order.</pre>
<p>Note the cascading failure again here. Because SAS doesn't realize you're starting 
  a data step here, all the data step commands don't make sense. Change <span class="InputCode">da</span> 
  to <span class="InputCode">data</span>, and all the rest will go away.</p>
<p>Once again, syntax coloring can help you here. If you're trying to type a SAS 
  command and it doesn't turn "command blue," you know there's a problem.</p>
<p>You can run into more subtle problems if you mistype a variable. SAS does
		not  have any special syntax to create a variable. It is placed in the PDV
		as soon 
  as you mention it in the code. For example, if you accidentally type</p>
<p class="InputCode">keep hhinc hhid age srx;</p>
<p>where <span class="InputCode">srx</span> is meant to be <span class="InputCode">sex</span>, 
  the code still runs. The only indication of trouble is a warning in the log:</p>
<pre>WARNING: The variable srx in the DROP, KEEP, or RENAME list    has never been referenced.</pre>
<p>Then when you try to use <span class="InputCode">sex</span> later, in your 
  second data step, you get</p>
<pre>NOTE: Variable sex is uninitialized.</pre>
<p>It was supposed to come from the results of the first data set, but it was
		 dropped because it wasn't on the list of variables to keep. But a warning
		or 
  a note doesn't stop your program from running. It will proceed and do what
		SAS  thinks you intended. But the results will be nonsense. This demonstrates
		the 
  importance of looking carefully at your log even if the program ran to completion
		and gave you the output you expected.</p>
<h2>Learning More</h2>
<p>You now have a good background in how data steps work, but there's much more 
  to learn. The SSCC has a  variety of articles on specific topics in SAS--take 
  a look at our <a href="https://ssc.wisc.edu/sscc/pubs/home.htm">Knowledge Base</a>.</p>
<p>For a broad but somewhat shallow introduction to SAS, The Little SAS Book by 
  Delwiche and Slaughter is the standard, and is available in the CDE library. 
  The SAS online documentation of course can tell you everything you need to know, 
  but it can be a challenge to read.</p>
<p>Finally, the SSCC Help Desk will be happy to answer any questions you may
	 have about SAS. From 1-4 every afternoon the consultant on call will be
	someone familiar with SAS. But you can <a href="mailto:helpdesk@ssc.wisc.edu">email
	  the Help Desk</a> or call 262-9917 at any time and your question will be
	  referred to the person who can best answer it.</p>
<!-- #EndEditable -->

</kb_body>
<img_base_url>https://ssc.wisc.edu/sscc/pubs/screenshots/4-18/4-18_1.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-18/4-18_2.png</img_base_url>
</kb_document>
<kb_document>
<kb_title>Storing SAS Formats</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- #BeginEditable "Text" -->
<p>SAS implements value labels (e.g. 0 is male, 1 is female) by allowing you
					to define custom formats. The difficulty is that these formats
					are not saved as part of the data they label. This article
					will discuss ways of storing SAS formats such that they can
					be used in subsequent programs.</p>
<p>As an example, consider a fabricated data set of individuals. For
					each individual you have their gender, their age, and their
							income. You want to do three things with this data:
					read it in and prepare it for analysis, get basic summary
					statistics, and regress income on the other variables. Because
					you don't want to re-run all the previous steps as you debug
					the one you're working on, you put each step in a separate
					SAS	program.	However	you	want	to apply	the same
					value	labels to	gender in	all	three	programs, so
					you need a way to store the custom format between programs.</p>
<h2><a id="TheTask" name="TheTask"></a>The Task</h2>
<p>First let's go through what you want to accomplish, ignoring the issue
					of	formats for the moment.</p>
<p>Start by reading in the fabricated data. If this were actual data
					you'd probably use a combination of <span class="InputCode">infile</span> and <span class="InputCode">input</span>,
					but	we'll use <span class="InputCode">datalines</span> and
					put the data	right in the data step.</p>
<p class="InputCode">data 'incomedata';<br/>
<span class="indent3">input gender age income;</span><br/>
<span class="indent3">datalines;</span><br/>
<span class="indent3">0 50 60000</span><br/>
<span class="indent3">1 45 80000</span><br/>
<span class="indent3">1 30 25000</span><br/>
<span class="indent3">0 25 18000</span><br/>
<span class="indent3">1 72 40000</span><br/>
<span class="indent3">;</span><br/>
			run;</p>
<p>Note that the data is stored in a permanent data set (a file) so you can
					use it in later programs.</p>
<p>Next you want some basic summary statistics. So run <span class="InputCode">proc
					freq</span>			  and <span class="InputCode">proc means</span>:</p>
<p class="InputCode">proc freq data='incomedata';<br/>
					run;</p>
<p class="InputCode">proc means data='incomedata';<br/>
			run;</p>
<p>Of course in the real world you'd probably do something  more sophisticated.</p>
<p>Finally we'll run a regression.</p>
<p class="InputCode">proc reg data='incomedata';<br/>
<span class="indent3">model income=gender age;</span><br/>
run;</p>
<p>This is very simple as well--in reality something this easy could
					all go in one program, but we'll keep them separate for pedagogical
					purposes.</p>
<h2><a id="ReviewDefiningandUsingFormats" name="ReviewDefiningandUsingFormats"></a>Review: Defining and Using Formats</h2>
<p>Formats in SAS are defined using <span class="InputCode">proc format</span>, and are applied to variables
			using the <span class="InputCode">format</span> statement. So to apply a label to the <span class="InputCode">gender</span> variable,
					the first step is to define a format that associates 0 with
					male and 1 with female. We'll call it <span class="InputCode">genderformat</span>.</p>
<p class="InputCode">proc format;<br/>
value genderformat<br/>
<span class="indent3">0= 'male'</span><br/>
<span class="indent3">1= 'female'</span><br/>
<span class="indent3">;</span><br/>
run;</p>
<p>Next you need to associate that format with the gender
					variable:</p>
<p class="InputCode">format gender genderformat.;</p>
<p>This statement must of course be part of a data or proc step. This could
					be	a	separate	data step just to apply the format, or
					it	could	be added	to an existing data or proc step.</p>
<p>The difficulty is that <span class="InputCode">genderformat</span> goes away as soon as the program that
					defines it ends. So how can you use it in all three programs?</p>
<h2><a id="IncludingtheFormatDefinitionsinAllYourPrograms" name="IncludingtheFormatDefinitionsinAllYourPrograms"></a>Including the Format Definitions in All Your Programs</h2>
<p>One option is to simply include all the formatting code in every SAS program
					that	uses
					<span class="InputCode">genderformat</span>. The first program, the one
					that just reads in the data, produces no output (other than
					the data set) and	does	not need to know about the format.
					In fact, including the <span class="InputCode">format</span> statement in that data step
					would complicate things, as we'll see later. But the other
					two do need the format, and thus need the code that handles
					it. Here	is	the	complete	code	of those
					programs,	including	the	formatting.</p>
<p>Summary statistics:</p>
<p class="InputCode">proc format;<br/>
<span class="indent3">value genderformat</span><br/>
<span class="indent3">0= 'male'</span><br/>
<span class="indent3">1= 'female'</span><br/>
<span class="indent3">;</span><br/>
run;</p>
<p class="InputCode">data formatteddata;<br/>
<span class="indent3">set 'incomedata';</span><br/>
<span class="indent3">format gender genderformat.;</span><br/>
run;</p>
<p class="InputCode">proc freq data=formatteddata;<br/>
		run; </p>
<p class="InputCode">proc means data=formatteddata;<br/>
		run;</p>
<p>Regression:</p>
<p class="InputCode">proc format;<br/>
<span class="indent3">value genderformat</span><br/>
<span class="indent3">0= 'male'</span><br/>
<span class="indent3">1= 'female'</span><br/>
<span class="indent3">;</span><br/>
		run;</p>
<p class="InputCode">data formatteddata;<br/>
<span class="indent3">set 'incomedata';</span><br/>
<span class="indent3">format gender genderformat.;</span><br/>
		run;</p>
<p class="InputCode">proc reg data=formatteddata;<br/>
<span class="indent3">model income=gender age;</span><br/>
		run;</p>
<p>The disadvantage of this approach is obvious: the programs are now about
						three times as long. In reality it could be much worse--many
					data sets include pages and pages of value labels, making
					your programs extremely long and somewhat cumbersome to work
					with.	And	if	you	wanted	to	make	any	changes	to	a
					format,	you'd	have	to	change	the	copy	in	each
					program.	On	the other	hand,	this	method	is straightforward
					to	implement.</p>
<h2><a id="SavingFormatsinaCatalogFile" name="SavingFormatsinaCatalogFile"></a>Saving Formats in a Catalog File</h2>
<p>The alternative is to save the format in a separate file SAS calls a catalog.
					Then subsequent programs can refer to this	catalog when
					they need the format.</p>
<p>In order to save the format, you'll add a <span class="InputCode">library</span> statement to the <span class="InputCode">proc
					format</span>, telling SAS where to put it (you'll
					need to define the library first). This program will create
					a file called <span class="InputCode">gender.sas7bcat</span> in your current directory.
					You'll	also	need to tell SAS to look for formats in that
					catalog	file.	This is done with the <span class="InputCode">fmtsearch</span> option.
					Since <span class="InputCode">genderformat</span> is
					now permanent, you	can	make the association between <span class="InputCode">gender</span> and <span class="InputCode">genderformat</span> permanent
							by including the <span class="InputCode">format</span> statement in the	data
					step that	reads	in the	data.	Here's	the complete
					code for the	data preparation program:</p>
<p class="InputCode">libname dir ".";</p>
<p class="InputCode">proc format library=dir.gender;<br/>
<span class="indent3">value genderformat</span><br/>
<span class="indent3">0= 'male'</span><br/>
<span class="indent3">1= 'female'</span><br/>
<span class="indent3">;</span><br/>
		run;</p>
<p class="InputCode">options fmtsearch=(dir.gender);</p>
<p class="InputCode">data 'incomedata';<br/>
<span class="indent3">format gender genderformat.;</span> <br/>
<span class="indent3">input gender age income;</span><br/>
<span class="indent3">datalines;</span><br/>
<span class="indent3">0 50 60000</span><br/>
<span class="indent3">1 45 80000</span><br/>
<span class="indent3">1 30 25000</span><br/>
<span class="indent3">0 25 18000</span><br/>
<span class="indent3">1 72 40000</span><br/>
<span class="indent3">;</span><span class="indent3"><br/>
</span>run;</p>
<p>The payoff comes in the next two programs. When they load <span class="InputCode">incomedata</span>,
					the	file will tell them that <span class="InputCode">gender</span> should
					be	formatted using <span class="InputCode">genderformat</span>.
					They'll then look for <span class="InputCode">genderformat</span>, so you'll
					need to tell	them where to look using the <span class="InputCode">fmtsearch</span> option.
					But that's	it!</p>
<p>Summary Statistics:</p>
<p class="InputCode">libname dir ".";<br/>
			options fmtsearch=(dir.gender);</p>
<p class="InputCode">proc freq data='incomedata';<br/>
					run; </p>
<p class="InputCode">proc means data='incomedata';<br/>
					run;</p>
<p>Regression:</p>
<p class="InputCode">libname dir ".";<br/>
		options fmtsearch=(dir.gender);</p>
<p class="InputCode">proc reg data='incomedata';<br/>
<span class="indent3">model income=gender age;</span><br/>
		run;</p>
<p>Obviously this is much shorter than redefining the format in each program,
					especially if you've got a lot of formats. But there is a
					catch. SAS now knows that <span class="InputCode">gender</span> needs to be formatted using
					<span class="InputCode">genderformat</span>. And if <span class="InputCode">genderformat</span> is unavailable, it will
					refuse to load the data set at all. You'll need to make
					sure the catalog file stays with the data set, and that everyone
					who uses it knows how to set the <span class="InputCode">fmtsearch</span> option.</p>
<p>If you ever do get stuck with a data set that has been formatted using
					formats you don't have access to, the following trick can
					be useful:  tell SAS to change the format
					to nothing in the data step that first loads the data. The
					following	format	statement	will	clear	all	formats
					from a data	set.	The result	may not	be	pretty, but it
					will be usable:</p>
<p class="InputCode">format _ALL_;</p>
<p>So which method should you use? Most likely as you read about the two
					techniques	one or the other seemed easier to you. Whichever
					that was,	go with it. It really is just a matter of personal preference.</p>
<!-- #EndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>Saving SAS Graphs For Printing or Other Uses</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- #BeginEditable "Text" -->
<p>Normally SAS works with graphs in a proprietary format nothing else can use. 
  However, it can save files in a variety of standard formats. If you want to 
  do anything more than look at the graphs on the screen, putting the graph in 
  one of these other formats is probably essential.</p>
<h2><a id="ChoosingaFormat" name="ChoosingaFormat"></a>Choosing a Format</h2>
<p>This article will focus on three formats: PDF (Portable Document Format), 
  PostScript, and PNG (Portable Network Graphic). Each has its uses, and which 
  one you should use depends on what you want to do with the graph. The following 
  chart lists some recommendation. Note that these are only recommendations based 
  on what tools most of our users have and are familiar with. For example, if 
  you have Ghostview installed on your PC, you can easily use it to print PostScript 
  files.</p>
<p> </p>
<div align="center">
<table border="1" cellpadding="10">
<tr>
<th>What you want to do with the graph...</th>
<th>The format you should use...</th>
</tr>
<tr>
<td>Print it from Linux</td>
<td>PostScript</td>
</tr>
<tr>
<td>Print it from Windows</td>
<td>PDF</td>
</tr>
<tr>
<td>Share it with colleagues via email or the web</td>
<td>PDF</td>
</tr>
<tr>
<td>Put it in a Web page</td>
<td>PNG</td>
</tr>
<tr>
<td>Put it in a Word document</td>
<td>PostScript</td>
</tr>
<tr>
<td>Edit it with an image editor*</td>
<td>PNG</td>
</tr>
</table>
  * The SSCC does not provide or support image editing software. </div>
<h2><a name="ChoosingaFont"></a>Choosing a Font</h2>
<p>What fonts SAS makes available depends on the format you use. If you choose 
  PNG, SAS can only use one default font. If you choose PDF, SAS allows you to 
  choose from the following:</p>
<p class="InputCode">Courier<br/>
  Courier-Oblique<br/>
  Courier-Bold<br/>
  Courier-BoldOblique<br/>
  Times-Roman<br/>
  Times-Italic<br/>
  Times-Bold<br/>
  Times-BoldItalic<br/>
  Helvetica<br/>
  Helvetica-Oblique<br/>
  Helvetica-Bold<br/>
  Helvetica-BoldOblique<br/>
  Symbol<br/>
  ZapfDingbats</p>
<p>With PostScript you have all these and more. See <a href="#GettingMoreInformation">Getting 
  More Information</a> for instructions on getting a complete list.</p>
<p>Note that you can only choose one font for all the text in the graph.</p>
<h2><a name="TheCode"></a>The Code</h2>
<p>Once you have chosen a format and a font, it's time to put the code in your 
  program that tells SAS to use them. Put the following before the proc step that 
  creates the graph:</p>
<p class="InputCode">filename output "<span class="Parameter">file</span>";<br/>
  goptions reset=all device=<span class="Parameter">format</span> gsfname=output 
  gsfmode=replace ftext="<span class="Parameter">font</span>";</p>
<p>Replace <span class="Parameter"><span class="InputCode">file</span></span> 
  with the name you want to give the file. Give it an extension that matches the 
  file type you want: <span class="InputCode">.pdf</span> for PDF, <span class="InputCode">.ps</span> 
  for PostScript, or <span class="InputCode">.png</span> for PNG. This is especially 
  important if you want to use the file on a PC, as Windows will use the extension 
  to decide what kind of file it is.</p>
<p>Replace <span class="Parameter"><span class="InputCode">format</span></span> 
  with the name of the format you want. The names are <span class="InputCode">pdf</span> 
  for black and white PDF, <span class="InputCode">pdfc</span> for PDF files including 
  color, <span class="InputCode">ps</span> for PostScript, and <span class="InputCode">png</span> 
  for PNG.</p>
<p>Replace <span class="Parameter"><span class="InputCode">font</span></span> 
  with the name of the font you want. Copy the name exactly from the list above. 
  If you are using PNG, it doesn't matter what font you choose, you'll always 
  get the same one. However, a font name must be there and must not have any spaces.</p>
<p>If you want to create a second graph with the same options, put a second <span class="InputCode">filename</span> 
  line right before the proc that creates the second graph, with a different <span class="Parameter"><span class="InputCode">file</span></span>. 
  If the second graph should have a different format or font, include a second 
  <span class="InputCode">goptions</span> line as well.</p>
<h2>Running the Program</h2>
<p>Once these lines are inserted, your program can be run normally with one exception.
   For whatever reason if you choose to create a PNG file, SAS will briefly open
   an interactive session even if you run the program in batch mode. Thus you
  will  need to be able to display Linux graphics. On a PC this means X-Win32
  must be  running. See <a href="https://ssc.wisc.edu/sscc/pubs/5-2.htm">Connecting
  to SSCC Linux Computers using X-Win32</a> 
  for more information. What's more, SAS will fail to create a window if there
   is no other graphical application running. So start something like <span class="InputCode">xclock</span> 
  before running SAS if you're planning to make a PNG file.</p>
<h2>Inserting a PostScript File Into Word</h2>
<p>If you create a PostScript file you can easily insert it into a Word document. 
  Start Word and open the document. Then click <span class="MenuOutput">Insert</span>, 
  <span class="MenuOutput">Picture</span>, <span class="MenuOutput">From File</span>. 
  Go to the directory where you saved the PostScript file, set <span class="MenuOutput">Files 
  of Type:</span> to <span class="MenuOutput">All Files (*.*)</span>, and double 
  click on the file you want. Word will then ask what it should convert the file 
  from. Choose <span class="MenuOutput">Encapsulated PostScript</span>, click 
  <span class="MenuOutput">Okay</span>, and the graph will appear in your document.</p>
<h2><a id="GettingMoreInformation" name="GettingMoreInformation"></a>Getting More Information</h2>
<p>You can get a full list of available formats (SAS refers to them as devices) 
  by running the following program:</p>
<p class="InputCode">proc gdevice catalog=sashelp.devices nofs;<br/>
<span class="indent3">list;</span><br/>
  run;</p>
<p>You can then get more information about a particular format, including what 
  fonts SAS can use in that format, by running:</p>
<p class="InputCode">proc gdevice c=sashelp.devices nofs;<br/>
<span class="indent3">list <span class="Parameter">format</span>;</span><br/>
  run;</p>
<p>Just replace <span class="Parameter"><span class="InputCode">format</span></span> 
  with the format you want (<span class="InputCode">ps</span> for example).</p>
<!-- #EndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>A Simple Procedure for Producing Publication-Quality Graphs using SAS</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- #BeginEditable "Text" -->
<p>SAS introduced the Output Delivery System (ODS) in version 7 which 
              provides a way of redirecting and customizing tabular SAS output. 
              SAS has extended the capabilities of ODS in version 9.1 to include 
              graphics for some of its statistical procedures. Using ODS graphics, 
              a procedure automatically creates the graphs that are most commonly 
              needed for a particular analysis and eliminates the need to save 
              numerical results in an output data set, manipulate them with a 
              DATA step program, and display them with a graphics procedure.</p>
<p>This document illustrates how you can use ODS to:</p>
<ul>
<li>create statistical graphics in various formats including Rich 
                Text Format (RTF), PostScript (PS), or HTML (HTM) formatted files 
                for inclusion in other programs like Word, WordPerfect, Latex, 
                or Internet Explorer.</li>
<li>select and exclude components of the statistical graphics output</li>
<li>use styles and templates to customize the appearance of statistical 
                graphics. </li>
</ul>
<p> ODS for tabular output is documented in  
              <a href="https://www.ssc.wisc.edu/sscc/pubs/4-8.htm">Redirecting 
              and Customizing Tabular Output in SAS</a>.</p>
<h2>Procedures Supporting ODS Graphics</h2>
<p>ODS for statistical graphics is still under development and considered 
              "experimental." So far, the following procedures support 
              ODS graphics in SAS 9.1:</p>
<p> <strong>Base SAS:</strong> CORR</p>
<p> <strong>SAS/ETS:</strong> ARIMA, AUTOREG, ENTROPY, EXPAND, MODEL, 
              SYSLIN, TIMESERIES, UCM,<br/>
              VARMAX, X12</p>
<p> <strong>SAS/STAT:</strong> ANOVA, CORRESP, GAM, GENMOD, GLM, KDE, 
              LIFETEST, LOESS, LOGISTIC, MI, MIXED, PHREG, PRINCOMP, PRINQUAL, 
              REG, ROBUSTREG</p>
<p>To get an idea of what the graphics produced from these procedures 
              look like, visit <a href="http://support.sas.com/rnd/app/da/stat/odsgraph/gallery.html">SAS's 
              web site</a>.</p>
<h2>Creating Graphics Files</h2>
<p>The example below illustrates just how simple it is to generate 
              graphics. The following statements invoke the REG procedure and 
              fit a simple linear regression model.</p>
<pre>ods html; 
ods graphics on;</pre>
<pre>proc reg data=Class;
   model Weight = Height;
quit;</pre>
<pre>ods graphics off;
ods html close;

</pre>
<p>The ODS HTML statement specifies an HTML destination for the output. 
              The ODS GRAPHICS statement is specified to request ODS Graphics 
              in addition to the usual ODS tabular output. The ODS GRAPHICS OFF 
              statement disables the ODS Graphics, and ODS HTML CLOSE statement 
              closes the HTML destination.</p>
<p>In the case of the REG procedure, the graphical output produced 
              by ODS consists of a fit diagnostics panel, a residual plot, and 
              a fit plot. These are shown below. </p>
<p><img height="640" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-21/DiagnosticsPanel_default.gif" width="640"/></p>
<p><img height="480" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-21/ResidualPanel_default.gif" width="640"/></p>
<p><img height="480" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-21/Fit_default.gif" width="640"/></p>
<p>Note that these graphics are not displayed when you run your SAS 
              job. Rather, the files containing the plots are written to disk 
              in the directory from which you invoked SAS. For this example, SAS 
              wrote the three plots to GIF files - <span class="MenuOutput">DiagnosticsPanel0.gif</span>, 
              <span class="MenuOutput">Fit2.gif</span>, and <span class="MenuOutput">ResidualPanel11.gif</span>. 
              SAS also wrote an HTML file called <span class="MenuOutput">sashtml.sas</span> 
              for displaying both the tabular output and graphics on a single 
              web page. SAS names these files in such a way to make them recognizable. 
              Of course, using SAS options, you can change where SAS writes these 
              files. See <a href="http://support.sas.com/91doc/getDoc/statug.hlp/odsgraph_sect14.htm">Chapter 
              15 of the SAS/Stat Online User's Guide</a> for details.</p>
<p>These plots can easily be inserted in Word or WordPerfect documents.</p>
<p>Technical note: If you have written your graphic files to a directory 
              on Linux like your PUBLIC_web directory that you want others to 
              be able to view from a browser, check the file permissions to make 
              sure they are world-readable. Including the SAS command</p>
<pre>x "umask 022"; </pre>
<p>at the beginning of your SAS program will ensure that files written 
              for the duration of the SAS job are world-readable.</p>
<h3>Using ODS Graphics with Procedure Options</h3>
<p>Some SAS procedures, including REG, have their own options for 
              generating graphics. If you specify ODS GRAPHICS ON and specify 
              any of procedure options for graphs, ODS will automatically write 
              these graphs to files. For example, if the SAS statement</p>
<pre>plot r.*p.;</pre>
<p>were included in the REG code above, a fourth GIF file containing 
              a plot of residual vs. predicted values would be written to disk 
              automatically. </p>
<h3>Selecting and Excluding Graphs</h3>
<p>You can also control which graphs you want generated. This feature 
              is documented in <a href="https://www.ssc.wisc.edu/sscc/pubs/4-8.htm">Redirecting 
              and Customizing Tabular Output in SAS</a>.</p>
<h2>Specifying File Formats</h2>
<p>Whenever you use ODS Graphics, you must specify a destination file 
              format. In the above example, HTML was specified and SAS created 
              HTML and GIF formatted files. Other file types supported include 
              LATEX, PDF, PS, PCL, and RTF. For example, if you wanted files formatted 
              for PDF for use with Adobe Acrobat, you would specify:</p>
<pre>ods pdf;</pre>
<p>If you are using HTML or LATEX as the destination, your graphs 
              are individually produced in a specific image file type, such as 
              GIF or PostScript. If you are using PDF, PS, PCL, or RTF as the 
              destination, the graphs (and tables) are all written to one file. 
              In the case of RTF, this file can easily be opened in Word or WordPerfect. 
              You could then copy and paste individual graphs into a PowerPoint 
              presentation for example. In general, RTF output is convenient for 
              exchange of graphical results between Windows applications through 
              the clipboard. However, since GIF files can be directly inserted 
              in Office applications, it may be more convenient just to use the 
              HTML destination.</p>
<h2>Customizing The Appearance of Your SAS Output</h2>
<p>With ODS you can change the appearance of most of your SAS output. 
              To change the overall look of your output, use ODS styles. To further 
              customize the appearance and table of your output, you can change 
              the templates SAS uses to generate output or even create your own 
              templates. A brief overview of templates is provided in  <a href="https://www.ssc.wisc.edu/sscc/pubs/4-8.htm">Redirecting 
              and Customizing Tabular Output in SAS</a>. For more detailed information, 
              please refer to <a href="http://support.sas.com/documentation/onlinedoc/91pdf/sasdoc_91/base_ods_7032.pdf">SAS's 
              on-line manual</a>.</p>
<h3>ODS Styles</h3>
<p>ODS styles control the overall look of your output. A style definition 
              provides formatting information for specific visual aspects of your 
              SAS output. For ODS graphics, this includes the appearance of line 
              and marker properties in addition to font and color information.</p>
<p>You can specify a style using the style option in the ODS destination 
              statement. Each style produces output with the same table, but 
              with a somewhat different visual appearance. Of the SAS-supplied 
              styles, SAS recommends four for use with ODS Graphics: ANALYSIS, 
              DEFAULT, JOURNAL, and STATISTICAL. In the example below, the JOURNAL 
              style is specified:</p>
<pre>ods latex style=journal; 
ods graphics on;</pre>
<pre>proc reg data=Class;
   model Weight = Height;
quit;</pre>
<pre>ods graphics off;
ods latex close;

</pre>
<p>The output below illustrates our favorite style - journal:</p>
<p><img height="640" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-21/DiagnosticsPanel_journal.gif" width="640"/></p>
<p><img height="480" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-21/ResidualPanel_journal.gif" width="640"/></p>
<p><img height="480" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-21/Fit_journal.gif" width="640"/></p>
<p>Once you start using ODS you will quickly find that you need information 
              not contained in this overview document. SAS's comprehensive user 
              guide to ODS can be found online at <a href="http://support.sas.com/documentation/onlinedoc/91pdf/sasdoc_91/base_ods_7032.pdf">http://support.sas.com/documentation/onlinedoc/91pdf/sasdoc_91/base_ods_7032.pdf.</a></p>
<p> </p>
<p> </p>
<!-- #EndEditable -->

</kb_body>
<img_base_url>https://ssc.wisc.edu/sscc/pubs/screenshots/4-21/DiagnosticsPanel_default.gif, https://ssc.wisc.edu/sscc/pubs/screenshots/4-21/ResidualPanel_default.gif, https://ssc.wisc.edu/sscc/pubs/screenshots/4-21/Fit_default.gif, https://ssc.wisc.edu/sscc/pubs/screenshots/4-21/DiagnosticsPanel_journal.gif, https://ssc.wisc.edu/sscc/pubs/screenshots/4-21/ResidualPanel_journal.gif, https://ssc.wisc.edu/sscc/pubs/screenshots/4-21/Fit_journal.gif</img_base_url>
</kb_document>
<kb_document>
<kb_title>Making Predictions with Counter-Factual Data in Stata</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p class="intro">Note: this article has been superseded by the very useful <span class="InputCode"><a href="https://ssc.wisc.edu/sscc/pubs/stata_margins.htm">margins</a></span> command. It is kept here because <span class="InputCode">margins</span> cannot be used in some contexts, such as multiple imputation.</p>
<p>Social Science researchers often want to ask hypothetical questions:
          		How would the income distribution in my sample change if all
          		the black people were white? How would the household structure
          		in my sample be different if the demographics hadn't changed
          		since 1970? You can try to answer such questions by first estimating
          		a model, then seeing what that model predicts
          		when you give it counter-factual data.</p>
<p>If you're using a linear model it's just a matter of multiplying
          		the change in a dependant variable by its coefficient. But non-linear
          		models are more complicated. Fortunately Stata makes this kind
          		of work very easy, and this article will show you how. </p>
<h2>Example: Car Quality</h2>
<p>In the 1970's a perception arose that cars produced in the United
          		States were less reliable than cars produced in other countries
          		(especially Japan). Investigations into the cause of this difference
          		helped launch the "quality" movement which became a major
          		buzzword in the business community through the 80's and 90's.
          		We'll use the 1978 automobile data set that comes with Stata
          		to examine this difference and try to answer the question "If
          		all the cars in our sample had been built outside the United
          		States, how would that change their repair records?"</p>
<p>Start up Stata, then load the 1978 automobile data by typing </p>
<p class="InputCode">sysuse auto</p>
<p>Note that  <span class="InputCode">sysuse</span> loads data from
          		wherever Stata is installed. That means it's  only useful
          		for loading the sample automobile data, but it does allow us
          		to ignore the fact that different versions of Stata store it
          		in different locations.</p>
<p>The <span class="InputCode">rep78</span> variable is the measure
          		we'll use for car quality. It is a five point scale, with 5 being
          		the best. To see it type</p>
<p class="InputCode">tab rep78, missing</p>
<p>Several cars  have missing values for <span class="InputCode">rep78</span> which
          		makes them useless for our analysis. So we'll drop them:</p>
<p class="InputCode">drop if rep78==.</p>
<p>Of course if this were actual research we'd have to think about
          		whether this would bias our sample.</p>
<p>We also have a variable called <span class="InputCode">foreign</span>.
          		To see its values type</p>
<p class="InputCode">tab foreign</p>
<p class="InputCode">tab foreign, nolabel</p>
<p>Let's begin by seeing if there's any evidence for the hypothesis
          		that foreign cars are more reliable:</p>
<p class="InputCode">cor rep78 foreign</p>
<p class="InputCode">by foreign: sum rep78</p>
<p class="InputCode">tab rep78 foreign, chi2</p>
<p>Clearly there's some basis for the perception.</p>
<h2>Logit</h2>
<p>To examine this further, let's begin with a simple logistic regression.
          		Since logistic can handle just two outcomes, we'll condense the
          		five-point <span class="InputCode">rep78</span> scale into the indicator
          		variable <span class="InputCode">highQuality</span>:</p>
<p class="InputCode">gen highQuality=(rep78&gt;3)</p>
<p>This creates a variable which takes on the value one
          		for cars with <span class="InputCode">rep78</span>&gt;3 and zero
          		for others. Note that cars with missing values for <span class="InputCode">rep78</span> would
          		be counted as high quality with this code, which is one reason we
          		dropped them right away.</p>
<p>Now let's run a logistic regression with <span class="InputCode">highQuality</span> as
          		the dependant variable. Clearly we want <span class="InputCode">foreign</span> as
          		one of our independent variables. What else to include is a
          		difficult question, especially for non-engineers. One might expect
          		more expensive cars to be more reliable, so we'll include <span class="InputCode">price</span>.
          		Since most car problems involve the engine, characteristics of
          		the engine seem relevant. Thus we'll include <span class="InputCode">displacement</span> and <span class="InputCode">gear_ratio</span>,
          		along with <span class="InputCode">weight</span> as a measure of
          		the load on the engine. The command is:</p>
<p class="InputCode">logit highQuality foreign price displacement gear_ratio weight</p>
<p>add the <span class="InputCode">or</span> option if you prefer odds ratios to marginal effects. </p>
<p>The results are mostly negative (so much for expensive cars being
          		more reliable) but the coefficient on <span class="InputCode">foreign</span> is
          		significant.</p>
<p>How much difference would it make if the cars were all foreign?
          		To begin, we'll calculate and store the predicted probability
          		of each car being high quality under our model:</p>
<p class="InputCode">predict p</p>
<p>Type <span class="InputCode">help predict</span> for full details on the predict command, but
          		its basic function is to make predictions using whatever regression
          		model you ran last. </p>
<p>The mean of <span class="InputCode">p</span> will be the same as the proportion of cars which
          		are high quality. To see that type</p>
<p class="InputCode">sum p highQuality</p>
<p>But when <span class="InputCode">predict</span> runs it uses whatever
          		data are in memory at the time. It doesn't know or care if the
          		data have changed since the regression was run. This allows us
          		to set up a counter-factual scenario and then use <span class="InputCode">predict</span> to
          		see what our model  says about it.</p>
<p>We're going to change the value of foreign, but since we'll want
          		to change it back we'll store the real value in a separate variable
          		first:</p>
<p class="InputCode">gen realForeign=foreign</p>
<p>Then we'll pretend that all the cars are foreign by setting <span class="InputCode">foreign</span>          		to one:</p>
<p class="InputCode">replace foreign=1</p>
<p>Now  we simply run predict again to generate the predicted probability
          		for this counter-factual scenario:</p>
<p class="InputCode">predict cfp</p>
<p>Now compare the counter-factual prediction with reality by typing: </p>
<p class="InputCode">sum cfp highQuality</p>
<p>As you see, this model suggests that if all these cars were produced
          		overseas, the proportion which are high quality would increase
          		from 42% to 87%.</p>
<h2>Multinomial Logit </h2>
<p>By condensing the five point scale of <span class="InputCode">rep78</span> into
          		the indicator variable <span class="InputCode">highQuality</span> we
          		obviously threw away a lot of information. We can use <span class="InputCode">rep78</span> directly
          		if we use a multinomial logit to examine the probabilities of
          		all five outcomes.</p>
<p>We'll begin by estimating the model. Since we always want to estimate
          		the model using the real data, we need to set <span class="InputCode">foreign</span> back to
          		its actual values:</p>
<p class="InputCode">replace foreign=realForeign</p>
<p>Next we'll run the exact same regression as before, except that
          		we'll use <span class="InputCode">rep78</span> as our dependent variable
          		instead of <span class="InputCode">highQuality</span> and use multinomial
          		logit:</p>
<p class="InputCode">mlogit rep78 foreign price displacement gear_ratio weight</p>
<p>We now have four sets of coefficients, each describing how that
          		variable changes the probability of getting a given outcome compared
          		to the base outcome of <span class="InputCode">rep78</span>=3. We'll
          		also have five predicted probabilities, one for each outcome:</p>
<p class="InputCode">predict m1-m5</p>
<p>Now we're ready to do the counter-factual:</p>
<p class="InputCode">replace foreign=1</p>
<p class="InputCode">predict cfm1-cfm5</p>
<p class="InputCode">sum m1-m5 cfm1-cfm5</p>
<p>We see that the predicted proportion with <span class="InputCode">rep78</span>=4
          		and <span class="InputCode">rep78</span>=5 is
          		much higher with <span class="InputCode">foreign</span> set to one .
          		Note how the predicted proportion for <span class="InputCode">rep78</span>=3
          		is much lower. Just looking at the regression coefficients, you
          		might think that increasing <span class="InputCode">foreign</span> makes  <span class="InputCode">rep78</span>=1
          		and <span class="InputCode">rep78</span>=2
          		less likely compared to <span class="InputCode">rep78</span>=3 and
          		thus the proportion for <span class="InputCode">rep78</span>=3
          		should go up. But in fact the <span class="InputCode">rep78</span>=4
          		outcome is even more strongly affected, so <span class="InputCode">rep78</span>=3
          		ends up going down.</p>
<p>Of course in this case the coefficients for <span class="InputCode">foreign</span> and <span class="InputCode">rep78</span>=1
          		and <span class="InputCode">rep78</span>=2 are nonsense because no foreign cars in our sample
          		have <span class="InputCode">rep78</span>&lt;3. But it's a general principle that just looking
          		at marginal effects in a multinomial logit can be deceptive.</p>
<h2>Ordered Logit</h2>
<p>By using multinomial logit we threw away the information that that
          		the values of <span class="InputCode">rep78</span> have an implied
          		order. Ordered logit takes advantage of that information. The
          		<span class="InputCode">ologit</span> command does ordered regression,
          		and the syntax  is identical to using <span class="InputCode">mlogit</span>:</p>
<p class="InputCode">replace foreign=realForeign</p>
<p class="InputCode">ologit rep78 foreign price displacement
          			gear_ratio weight</p>
<p class="InputCode">predict o1-o5 </p>
<p class="InputCode">replace foreign=1 </p>
<p class="InputCode">predict cfo1-cfo5</p>
<p class="InputCode">sum o1-o5 cfo1-cfo5</p>
<p>Interestingly, ordered logit gives a much higher proportion in
          		<span class="InputCode">rep78</span>=5 with the counter-factual scenario
          		than multinomial logit. Which of these results to believe (if
          		any) is left as an exercise for the reader. </p>
<h2>Beyond Proportions</h2>
<p>Naturally you're not limited to looking at the means of predicted
          		probabilities and interpreting them as predicted proportions.
          		Each observation has a full set of predicted probabilities which
          		may be interesting in and of themselves.</p>
<p>Note however, that when we set <span class="InputCode">foreign</span> to
          		1 for all observations we reduced the variation in our sample.
          		This data has lots of quasi-continuous variables so there's not
          		much danger of creating duplicates. But if you have lots of categorical
          		variables, many reasonable counter-factual scenarios will make
          		all the observations which fall into a certain category or set of
          		categories identical. That's not necessarily a problem, but it is
          		an issue to be aware of.</p>
<p> For example, you may want to set up a counterfactual scenario
          		where each individual is assigned the mean income for
          		their gender, race, and state of residence in a different period.
          		However, having done so you could no longer talk about the variation
          		in income within a given gender/race/state combination. If you
          		did something similar with all the individual variables in your
          		data set, you'd then then have no variation whatsoever within
          		each gender/race/state combination, and you should  expect
          		that any predictions you make will also not vary within those
          		groups.</p>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>Using Stata Graphs in Documents </kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p>Stata can easily produce "publication quality" graphics,
          		but it takes a few more steps to actually put them in a publication.
          		This article will discuss how to save Stata graphs in various
          		formats. It will also show you step-by-step
          		how to insert a Stata graph into a Word document or PDF file.</p>
<h2>Saving a Graph </h2>
<p>When you create a graph in Stata, the result is simply a picture
          		on the screen. If you want to be able to view it after your current
          		program finishes, you'll need to save it.</p>
<h3>graph save</h3>
<p>The <span class="InputCode">graph save</span> command tells Stata
          		to save your current graph (the most recently created) in Stata's
          		<span class="InputCode">gph</span> format.  The
          		syntax is simply</p>
<p class="InputCode">graph save <span class="Parameter">filename</span>, replace</p>
<p>where <span class="Parameter"><span class="InputCode">filename</span></span> should
          		be replaced by the name you want Stata to give your file.   Stata
          		will add <span class="InputCode">.gph</span> to
          		the end of the filename automatically. The <span class="InputCode">replace</span> option
          		tells Stata to overwrite the current version of that graph if
          		one exists--without that your do file will fail if you try to
          		run it more than once.</p>
<p>The disadvantage of <span class="InputCode">graph save</span> is
          		that the <span class="InputCode">.gph</span> files it produces
          		can only be read by Stata. To create files usable by other programs
          		you'll need <span class="InputCode">graph export</span>. However, <span class="InputCode">graph
          		save</span> can be useful if
          		you want to move graphs between computers--for example from a
          		Linux server to a PC.</p>
<h3>graph use</h3>
<p>The <span class="InputCode">graph use</span> command  opens a <span class="InputCode">.gph</span>          		file previously saved on disk. The graph will be displayed, and it
          		also becomes the current graph that subsequent commands will act
          		on. The syntax is</p>
<p class="InputCode">graph use filename</p>
<p>The filename will be assumed to end in <span class="InputCode">.gph</span> if you don't include
          		an extension. </p>
<h3>graph export</h3>
<p>The <span class="InputCode">graph export</span>  command saves
          		your current graph in the format you choose. The syntax is</p>
<p class="InputCode">graph export <span class="Parameter">filename</span>.<span class="Parameter">extension</span>, replace</p>
<p>Again, <span class="Parameter"><span class="InputCode">filename</span></span> should
          		be replaced by the name you want.  The <span class="Parameter"><span class="InputCode">extension</span></span>          		you
          		choose will determine the file format. What formats are available
          		depends on how you're running Stata:</p>
<p> </p>
<table align="center" border="1" cellpadding="5">
<tr>
<th align="center" rowspan="2" scope="col">Extension</th>
<th align="center" rowspan="2" scope="col">File Format </th>
<th align="center" colspan="3" scope="col">Where Available </th>
</tr>
<tr>
<th align="center">Windows </th>
<th align="center">Linux (Interactive) </th>
<th align="center">Linux (Batch Mode) </th>
</tr>
<tr align="center">
<td align="center">.ps</td>
<td align="center">PostScript</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">.eps</td>
<td align="center">Encapsulated Postscript </td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">.tif</td>
<td align="center">Tagged Image Format </td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">.png</td>
<td align="center">Portable Network Graphic </td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">.wmf</td>
<td align="center">Windows Metafile </td>
<td align="center">Yes</td>
<td align="center">No</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">.emf</td>
<td align="center">Windows Enhanced Metafile </td>
<td align="center">Yes</td>
<td align="center">No</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">.pdf</td>
<td align="center">Portable Document Format</td>
<td align="center">Yes</td>
<td align="center">No</td>
<td align="center">No</td>
</tr>
</table>
<p>Stata's commands for creating graphs tend to take a lot of computing
          		power, so making a lot of graphs can take a long time. Keep
          		in mind that the fastest way to run a Stata job at the SSCC is
          		to submit it to Condor so it will be run using Stata/MP.  But
          		Condor jobs must be run in batch mode, and batch mode has the
          		fewest file format options. This is where <span class="InputCode">graph
          		save</span> comes
          		in: create your graphs using Condor, and save them using <span class="InputCode">graph
          		save</span>. Then you can open the resulting <span class="InputCode">.gph</span> files
          		in Windows Stata or interactive Linux Stata with <span class="InputCode">graph
          		use</span>,
          		and finally use <span class="InputCode">graph
          		export</span> to convert them to the format you need.</p>
<p>See <a href="https://ssc.wisc.edu/sscc/pubs/7-1.htm">An Introduction to Condor</a> for details
          		about submitting jobs to Condor.</p>
<h2>Inserting a Graph into a Word Document</h2>
<p>We've found that for best results in Word you generally want to
          		use emf (Enhanced Metafile) format. So first create your graph,
          		then save it in emf format using graph export:</p>
<p class="InputCode">graph export graph.emf, replace</p>
<p>Next open the document into which you want to insert the graph
          		using Word. Put the cursor at the desired location. Then click
          		<span class="MenuOutput">Insert</span>, <span class="MenuOutput">Picture</span>, <span class="MenuOutput">From
          		File</span>. Locate the directory where you saved
          		the graph, select it, and click <span class="MenuOutput">Insert</span>.</p>
<p><img alt="Inserting the Graph into Word" height="393" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-23/4-23_1.png" width="601"/> </p>
<h2>Inserting a Graph into a PDF file</h2>
<p>If you want to put your graph in a PDF file, PostScript works well.
          		Create your graph, then save it in ps format using graph export:</p>
<p class="InputCode">graph export graph.ps, replace</p>
<p>Next open Adobe Acrobat (not Adobe Reader, which only reads PDF
          		files--Adobe Acrobat is available on Winstat). If you
          		already have a PDF file and you want to add the graph to it,
          		open the file, then click <span class="MenuOutput">Document</span>, <span class="MenuOutput">Insert
          		Pages</span>. Set <span class="MenuOutput">Files
          		of Type</span> to <span class="MenuOutput">PostScript/EPS</span>.
          		Locate the proper directory, click on your graph, and click Select. </p>
<p><img alt="Inserting a Graph into a PDF file" height="438" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-23/4-23_2.png" width="563"/></p>
<p>If you want the graph to be a PDF file all by itself, click <span class="MenuOutput">File</span>,
          		<span class="MenuOutput">Create PDF</span>, <span class="MenuOutput">From
          		File</span>. Then locate and select your graph.</p>
<p>From Linux you can do the same thing using the <span class="InputCode">ps2pdf</span> program.
          		At the Linux prompt type:</p>
<p class="InputCode">ps2pdf graph.ps graph.pdf</p>
<h2>Using Graphs Elsewhere</h2>
<p>What format will work in other situations is difficult to
          		predict, and you may need to try several alternatives.</p>
<p>PostScript is a standard format for printing across all different
          		kinds of computers. This makes it a good choice for situations
          		that involve printing, or for use on computers other than PCs.</p>
<p>Enhanced Metafile is an excellent choice if you want to use the
          		graph in a Windows program, as tools for working with emf files
          		are embedded in Windows. However, computers that are not running
          		Windows will probably have no way to open emf files at all. </p>
<p>PNG is a standard picture format, but a relatively recent one.
          		Older programs may not recognize it (try TIF with those programs).
          		However, PNG is a great choice for web pages. It's also a good
          		format for just sending a graph to someone—most computers will
          		open it with some sort of picture viewer or editor.</p>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url>https://ssc.wisc.edu/sscc/pubs/screenshots/4-23/4-23_1.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-23/4-23_2.png</img_base_url>
</kb_document>
<kb_document>
<kb_title>An Introduction to Stata Graphics</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p>Stata includes a rich set of tools for creating publication-quality graphics. Between the wide variety of graphs you can make and the sheer number of details you can control in a graph, Stata graphics can be a daunting subject. However,  you'll probably only need to make a few different kinds of graphs, and in most cases Stata's default settings will be fine. What's more, Stata's Graphical User Interface (GUI) organizes the various graphing options in an intuitive way so you can find them when you need them without memorizing the syntax for each one. That doesn't mean you shouldn't put your graph commands in do files once you've created them, but it does mean that for complex graphs you can use the GUI to create the commands you'll store.</p>
<p>Stata 10 also added a graph editor which allows you to modify a graph after you've created it. This gives you even more control over your graph, but unlike the GUI for creating a graph the editor does not give you a command you can rerun later. If you later make any changes to your data, you'll have to start your graph over from scratch. Thus it's better to create the graph you want in the first place where possible, but the editor is still a very useful addition.</p>
<p>This article will discuss creating graphs using the Stata GUI, the structure of the graph command syntax (without dwelling too much on the details), some common types of graphs, and the graph editor.  The best way to use this article is to read it at the computer and actually carry out the steps described. The examples in this article will use the automobile dataset that comes with Stata, so begin by typing:</p>
<p class="InputCode">sysuse auto</p>
<p>to load it. Feel free to experiment as you go, especially with the settings we don't discuss (usually because they're either fairly obvious or rarely used). Creating a graph will never change your data, so the worst that can happen is that your graph turns out to be useless or just plain ugly.</p>
<h2><a id="CreatingGraphsUsingtheGraphicalUserInterface" name="CreatingGraphsUsingtheGraphicalUserInterface"></a>Creating Graphs Using the Graphical User Interface</h2>
<p>We'll start with a simple scatter plot with <span class="InputCode">weight</span> as the X variable and <span class="InputCode">mpg</span> as the Y variable. Stata refers to any graph which has a Y variable and an X variable as a <span class="MenuOutput">twoway</span> graph, so click <span class="MenuOutput">Graphics</span>, <span class="MenuOutput">Twoway graph</span>. The next step is to define a plot. In Stata terms, a <em>plot</em> is some specific  data visualized in a specific way, for example "a scatter plot of <span class="InputCode">mpg</span> on <span class="InputCode">weight</span>." A <em>graph</em> is an entire image, including axes, titles, legends, etc. Also, a single graph may contain multiple plots. The basic <span class="MenuOutput">twoway</span> dialog box will allow you to define as many plots as you need, plus control the other characteristics of the graph.</p>
<p><img alt="Twoway main dialog box" height="339" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_1.png" width="481"/></p>
<p>To define a plot, click <span class="MenuOutput">Create</span>. You'll then get a dialog box where you can describe the plot you want. Leave the category set to <span class="MenuOutput">Basic plots</span> and the type set to <span class="MenuOutput">Scatter</span>. For the <span class="MenuOutput">Y variable</span> select or type <span class="InputCode">mpg</span>, and for the <span class="MenuOutput">X variable</span> select or type <span class="InputCode">weight</span>. (Note: Linux Stata does not allow you to select variables so you'll need to type their names. In Windows Stata you can do either.)</p>
<p><img alt="Defining a scatter plot" height="409" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_2.png" width="621"/></p>
<p>If you  click <span class="MenuOutput">Submit</span>, the graph will be created without closing the dialog box. This allows you to look over the results and then easily make adjustments and try again. Click <span class="MenuOutput">Submit</span> now and you should get a simple but professional looking scatter plot.</p>
<p><img alt="Basic Scatter Plot" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_33.png" width="684"/></p>
<h3><a id="AddingMoreVariables" name="AddingMoreVariables"></a>Adding More Variables</h3>
<p>If you want to add a second Y variable to the scatterplot, the easiest way is to type its name into the <span class="MenuOutput">Y variable</span> box after the one you've already selected. Stata does not allow you to select multiple variables from the list with the mouse, but it has no trouble understanding  multiple variables in the <span class="MenuOutput">Y variables</span> box as long as you put them there yourself.</p>
<p>To make a sensible graph with two Y variables (without having multiple scales) we need variables with similar values. The <span class="InputCode">trunk</span> variable qualifies, so type it in the <span class="MenuOutput">Y variable</span> box after <span class="InputCode">mpg</span> and click <span class="MenuOutput">Submit</span> again.</p>
<p><img alt="Defining a scatterplot with two Y variables" height="409" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_3.png" width="621"/></p>
<p> The result will be a scatter plot with both variables. Note how Stata automatically puts the two variables in different colors and adds a legend explaining which is which. The legend text is drawn from the variable labels, but you could override all these default behaviors if you so desired.</p>
<p><img alt="Scatter Plot with Two Variables" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_34.png" width="684"/></p>
<h3><a id="PlottingaSubsetoftheData" name="PlottingaSubsetoftheData"></a>Plotting a Subset of the Data</h3>
<p>If you only want to include certain observations, you can specify which ones by clicking on the <span class="MenuOutput">if/in</span> tab. You can then type a condition in the <span class="MenuOutput">If</span>: box, and only observations that meet the condition will be included in the plot. Do not type the word <span class="InputCode">if</span>, as that is assumed.</p>
<p>To only plot foreign cars, type <span class="InputCode">foreign</span> in the <span class="MenuOutput">If</span>: box.</p>
<p><img alt="Adding an if condition" height="409" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_9.png" width="621"/></p>
<p> Recall that in Stata one is true and zero is false, and <span class="InputCode">foreign</span> is coded accordingly. Thus <span class="InputCode">if foreign</span> is equivalent to <span class="InputCode">if foreign==1</span>. Click <span class="MenuOutput">Submit</span> and you'll get a much sparser graph.</p>
<p><img alt="Scatter Plot with just foreign cars" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_35.png" width="684"/></p>
<p> You can also use more complicated expressions. For example, type <span class="InputCode">foreign &amp; price&lt;10000</span> and you'll get just the cars which are both foreign and cost less than $10,000 (in 1978 dollars).</p>
<p><img alt="Plotting a subset of the data" height="409" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_4.png" width="621"/></p>
<p><img alt="Scatter plot with a more complicated if" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_36.png" width="684"/></p>
<h3><a id="ControllingtheMarkers" name="ControllingtheMarkers"></a>Controlling the Markers</h3>
<p>By default Stata marks each point with a small dot, but you can change this. First click on the <span class="MenuOutput">Plot</span> tab again, and for best results set the <span class="MenuOutput">Y variable</span> back to just <span class="InputCode">mpg</span>. Then click <span class="MenuOutput">Marker Properties</span>. Set <span class="MenuOutput">Symbol</span> to <span class="MenuOutput">Hollow circle</span>. Next check <span class="MenuOutput">Add labels to markers</span> and set the <span class="MenuOutput">Variable</span> to <span class="InputCode">make</span>, then click <span class="MenuOutput">Submit</span>.</p>
<p><img alt="Marker Properties" height="449" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_28.png" width="381"/></p>
<p><img alt="Scatter plot with labels" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_37.png" width="684"/></p>
<p> As you see, each point is now a hollow circle with the name of the car printed next to it, but many of the names overlap. You can improve the situation somewhat by changing <span class="MenuOutput">Label angle</span> to <span class="MenuOutput">45 degrees</span>, but in general you can only put useful labels on a scatter plot if it has a small number of observations and they're spread out.</p>
<p><img alt="Scatter plot with angled labels" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_38.png" width="684"/></p>
<h3><a id="OverlayingPlots" name="OverlayingPlots"></a>Overlaying Plots</h3>
<p>Next we'll combine multiple plots. Uncheck <span class="MenuOutput">Add labels to markers</span>. Click <span class="MenuOutput">Accept</span> to  accept these settings for <span class="MenuOutput">Marker properties</span> and go back to the <span class="MenuOutput">Plot 1</span> window, then click <span class="MenuOutput">Accept</span> again to accept the plot as it is and go back to the main <span class="MenuOutput">twoway</span> window. Click <span class="MenuOutput">Create</span> to add another plot to the graph. This time we'll make a line plot. Set the plot type to <span class="MenuOutput">Line</span>, and again choose <span class="InputCode">mpg</span> and <span class="InputCode">weight</span> as the Y and X variables. Click <span class="MenuOutput">Submit</span> to see the result.</p>
<p><img alt="Adding a line graph" height="409" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_5.png" width="621"/></p>
<p><img alt="Scatter plot and line plot, but with a problem" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_39.png" width="684"/></p>
<p>It's probably not what you expected--in fact it looks like a scribble. That's because by default Stata draws the line from observation one to observation two to observation three and so forth. What you want is a line from the observation with the lowest weight to the one with the next lowest weight, etc. That's why Stata included the checkbox <span class="MenuOutput">Sort on x variable</span>. This does not change the actual order of the observations in your data set, just the order in which they are connected in your line plot. Check it and click <span class="MenuOutput">Submit</span> again. This time you should get the graph you expected.</p>
<p><img alt="Setting the line graph to be sorted" height="409" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_6.png" width="621"/></p>
<p><img alt="Scatter and line, now sorted" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_40.png" width="684"/></p>
<p>Note that while the line connects all the points in the scatter plot, it goes to a lot of points that the scatter plot does not include. That's because you didn't set an <em>if</em> condition for the line plot, so it's plotting all the observations in the data. The ability to set different <em>if</em> conditions for different plots is very useful, though you'll note that the <span class="MenuOutput">twoway</span> window has its own <span class="MenuOutput">if/in</span> tab which applies to all the plots.</p>
<h3><a id="Lineproperties" name="Lineproperties"></a>Line properties</h3>
<p>You can control what the line looks like by clicking <span class="MenuOutput">Line Properties</span>. The most commonly used option here is <span class="MenuOutput">Pattern</span>. By default Stata distinguishes different line plots by color, but that doesn't help if the graph needs to be printed in black and white. So instead you can set a pattern for each line. (Alternatively you can choose a <a href="#OverallOptions">scheme</a> designed for printing). To see it in action set <span class="MenuOutput">Pattern</span> to <span class="MenuOutput">Dash</span>. Also try setting <span class="MenuOutput">Connecting method</span> to <span class="MenuOutput">Stairstep</span>.</p>
<p><img alt="Line properties" height="243" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_27.png" width="341"/></p>
<p><img alt="Dashed line and stairstep" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_41.png" width="684"/></p>
<h3><a id="PlottingSubsamples" name="PlottingSubsamples"></a>Plotting Subsamples</h3>
<p>Let's go back to just plotting <span class="InputCode">mpg</span> vs. <span class="InputCode">weight</span>, but this time let's make the foreign cars one color and the domestic cars another. You can do this by creating two plots, one for the foreign cars and one for the domestic cars, each having an <em>if</em> condition that limits it to the proper subpopulation. Then Stata will make them different colors automatically.</p>
<p>Begin by resetting everything. Click <span class="MenuOutput">Accept</span> twice to get back to the main <span class="MenuOutput">twoway</span> window, then click the <span class="MenuOutput">R</span> button (<img alt="Reset button" height="21" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_10.png" width="20"/>) in the lower left to reset the plots. Next click <span class="MenuOutput">Create</span>, leave the type as <span class="MenuOutput">Scatter</span>, set the <span class="MenuOutput">Y variable</span> to <span class="InputCode">mpg</span> and set the <span class="MenuOutput">X variable</span> to <span class="InputCode">weight</span>. Then click <span class="MenuOutput">if/in</span> and in the <span class="MenuOutput">If</span>: box type <span class="InputCode">!foreign</span>. The exclamation mark is Stata for "not" so this means "not foreign" and is equivalent to <span class="InputCode">foreign==0</span>. Thus this plot will only include the domestic cars.</p>
<p> Click <span class="MenuOutput">Accept</span> to get back to the main <span class="MenuOutput">twoway</span> window, then click <span class="MenuOutput">Create</span> again and repeat the entire process with one vital difference: this time in the <span class="MenuOutput">If</span>: box just type <span class="InputCode">foreign</span>. This plot will include only the foreign cars. Click <span class="MenuOutput">Submit</span> to see the result.</p>
<p><img alt="Plotting two subpopulations in separate plots" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_42.png" width="684"/></p>
<p>The resulting graph very nicely makes the domestic cars blue and the foreign cars red. However, the legend gives you no indication which is which. To do that you'll need to take control of the legend yourself.</p>
<h2><a id="ControllingtheAppearanceofaGraph" name="ControllingtheAppearanceofaGraph"></a>Controlling the Appearance of a Graph</h2>
<p>You haven't seen any options for controlling the legend, because thus far we've been focused on the properties of individual plots. The legend is not associated  with a particular plot because it potentially contains information from all the plots. Thus to get to it you need to click <span class="MenuOutput">Accept</span> and get back to the <span class="MenuOutput">twoway</span> window. This is where you control aspects of the graph as a whole, including the legend. </p>
<h3><a id="Legends" name="Legends"></a>Legends</h3>
<p>Click on the <span class="MenuOutput">Legend</span> tab. The <span class="MenuOutput">Legend behavior</span> just controls whether the legend is shown or not. Since Stata thinks our graph should have one and we agree, we can leave it set to <span class="MenuOutput">Default</span>. On the other hand, the default keys don't provide any useful information for this graph, so we need to override them. Check <span class="MenuOutput">Override default keys</span>. Then in the box below you need to type the number of each plot followed by how you want it to be labeled (in quotation marks). For this graph type: </p>
<p class="InputCode">1 "Domestic Cars" 2 "Foreign Cars"</p>
<p><img alt="Controlling the legend" height="339" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_7.png" width="481"/></p>
<p>Now click <span class="MenuOutput">Submit</span> and you'll get a graph with a useful legend. Note that the order in which you list the plots is the order in which they'll appear in the legend: if you typed <span class="InputCode"> 2 "Foreign Cars"</span> <span class="InputCode">1 "Domestic Cars"</span> the legend would put the foreign cars first.</p>
<p><img alt="Plot with a useful legend" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_43.png" width="684"/></p>
<p>The <span class="MenuOutput">Organization / Appearance</span> button opens up a dialog box with all sorts of options relating to how the legend looks. Click the <span class="MenuOutput">Organization</span> tab and set <span class="MenuOutput">Rows/Columns</span> to <span class="MenuOutput">Columns</span> (leaving it set to just one column).</p>
<p> </p>
<p><img alt="Organizing the Legend" height="389" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_31.png" width="481"/></p>
<p>The <span class="MenuOutput">Labels</span> and <span class="MenuOutput">Region</span> tabs allow you to control the appearance of the legend text and the entire legend box  respectively. The various options like sizes and colors are  self-explanatory, but these same options appear in many different contexts so it's worth taking a moment to experiment and see how they work. Choose some different colors and such just to see how they work. Then click <span class="MenuOutput">Accept</span> to get back to the main <span class="MenuOutput">twoway</span> window.</p>
<p><img alt="Choosing sizes and colors" height="389" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_32.png" width="481"/></p>
<p>The <span class="MenuOutput">Placement</span> button allows you to control where the legend is placed in the graph. To understand how locations are specified, imagine putting the face of an analog clock over your graph: 12 o'clock is the top, 6 o'clock the bottom, 3 o'clock the right side, etc. You can also specify that the legend goes inside the plot region rather than in the border area around it--just make sure it doesn't cover up anything important.</p>
<p>Try setting the <span class="MenuOutput">Position</span> to <span class="MenuOutput">12 o'clock</span> and check <span class="MenuOutput">Place legend inside  plot region</span>, then click <span class="MenuOutput">Submit</span> to see the results.</p>
<p><img alt="Legend positions" height="318" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_8.png" width="481"/></p>
<p><img alt="Plot after changing the legend's appearance" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_44.png" width="684"/></p>
<h3><a id="Titles" name="Titles"></a>Titles</h3>
<p>You can add a title to the legend using the <span class="MenuOutput">Title</span> tab of the in the <span class="MenuOutput">Legend organization and appearance properties</span> window, but you're much more likely to want to add a title to the graph itself. To do so click <span class="MenuOutput">Accept</span> to get back to the main <span class="MenuOutput">twoway</span> window again, and then click on its <span class="MenuOutput">Titles</span> tab. This gives you four boxes where you can put text: the <span class="MenuOutput">Title</span>, <span class="MenuOutput">Subtitle</span>, <span class="MenuOutput">Caption</span> and <span class="MenuOutput">Note</span>. The easiest way to see what each one means is to try them out, so type <span class="InputCode">Title</span>, <span class="InputCode">Subtitle</span>, <span class="InputCode">Caption</span> and <span class="InputCode">Note</span> in their respective boxes, and click <span class="MenuOutput">Submit</span> to see the result.</p>
<p><img alt="Adding titles" height="339" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_11.png" width="481"/></p>
<p><img alt="Plot with titles" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_45.png" width="684"/></p>
<p>As you see, <span class="MenuOutput">Title</span> and <span class="MenuOutput">Subtitle</span> go at the top, while <span class="MenuOutput">Caption</span> and <span class="MenuOutput">Note</span> go in the bottom left. Each also has a particular font size associated with it. However, these are simply defaults. Click on the <span class="MenuOutput">Properties</span> button associated with each one and you can change its position and format. (Legend titles work in the same way, but they appear inside the legend box.)</p>
<p>If you want the text to be split across multiple lines, put each line in quotes. To see this in action, replace <span class="InputCode">Title</span> with <span class="InputCode">"First Line" "Second Line"</span> and click <span class="MenuOutput">Submit</span>.</p>
<p><img alt="Title with multiple lines" height="339" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_25.png" width="481"/></p>
<p><img alt="Plot with a multi-line title" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_46.png" width="684"/></p>
<h3><a id="Axes" name="Axes"></a>Axes</h3>
<p>Next we'll consider the  axes of the graph. Click on the <span class="MenuOutput">Y axis</span> tab (the <span class="MenuOutput">X axis</span> tab is identical) and the first thing you'll see is the <span class="MenuOutput">Title</span> box. If a plot has just one Y variable, the default title for the Y axis is that variable's label if it has one, or else simply its name. If all the plots have multiple Y variables, the default is no title at all. However, you can override the default by typing something here, and control its format by clicking <span class="MenuOutput">Properties</span>. Type in <span class="InputCode">Miles Per Gallon</span> and click <span class="MenuOutput">Submit</span> to see the effect.</p>
<p><img alt="Setting an axis title" height="339" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_14.png" width="481"/></p>
<p><img alt="Plot with a custom Y axis title" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_47.png" width="684"/></p>
<p>Major ticks are the marks along the axis with numbers by them that we've been seeing all along, but by clicking <span class="MenuOutput">Major tick/label properties</span> you can control how many there are and where they are placed. This is done by choosing one of several rules. <span class="MenuOutput">Use the default rule</span> allows Stata to choose, which it usually does pretty well. <span class="MenuOutput">Suggest # of ticks</span> leaves most of the control to Stata but allows you to set roughly how many ticks there will be. <span class="MenuOutput">Min Max</span> puts ticks  at just the bottom and top of the axis. <span class="MenuOutput">Range/Delta</span> gives you complete control as long as you want the ticks to follow a regular rule. For example, select <span class="MenuOutput">Range/Delta</span>, set the <span class="MenuOutput">Minimum value</span> to 0, the <span class="MenuOutput">Maximum value</span> to 40, and the <span class="MenuOutput">Delta</span> to 5, then click <span class="MenuOutput">Submit</span> to see the results.</p>
<p><img alt="Controlling ticks  with Range/Delta" height="364" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_12.png" width="441"/></p>
<p><img alt="Plot with more ticks on the Y axis" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_48.png" width="684"/></p>
<p><a id="NoTruncate" name="NoTruncate"></a>The result is a Y axis that starts at zero and has ticks every five units, but note that the graph continues up to 41 because one car got 41 miles per gallon. You can extend a graph by extending an axis (remember the default version of this graph started at ten) but you cannot truncate it. Stata will always make the graph big enough to plot all the observations in your data. If you really wanted the graph to stop at 40 you'd have to add an <em>if</em> condition like <span class="InputCode">mpg&lt;=40</span>.</p>
<p><span class="MenuOutput">Custom</span> rules allow you to place ticks anywhere you like and have them say whatever you like. The syntax is simply a list of numbers and associated labels. For example, select Custom and in the <span class="MenuOutput">Custom rule</span> box type <span class="InputCode">10 "Terrible" 20 "Mediocre" 30 "Very Good"</span>.</p>
<p><img alt="Custom tick rule" height="364" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_13.png" width="441"/></p>
<p><img alt="Plot with labeled ticks" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_49.png" width="684"/></p>
<p>The result is a less informative but more eloquent graph. You could accomplish the same thing by putting value labels on the variable. If you already have value labels assigned just click on the <span class="MenuOutput">Labels</span> tab and check <span class="MenuOutput">Use value labels</span>.</p>
<p> Every tick does not need a text label. For example, you could set the custom rule to <span class="InputCode">10 "Terrible" 15 20 "Mediocre" 25 30 "Very Good" 35 40</span> and get ticks every five units with labels at just 10, 20 and 30. However, this will cause the labels to overlap, or at least crowd each other. To fix that, click on the <span class="MenuOutput">Labels</span> tab and set <span class="MenuOutput">Angle</span> to <span class="MenuOutput">Horizontal</span>. Since this will force Stata to expand the margin to the left of the plot in order to make room for the labels, set the <span class="MenuOutput">Size</span> to <span class="MenuOutput">v. Small</span>.</p>
<p><img alt="Formatting labels" height="364" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_17.png" width="441"/></p>
<p><img alt="Plot with some ticks labeled and others not" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_50.png" width="684"/></p>
<p> However, the text labels don't include the numbers 10, 20 or 30, which looks odd since the other tick marks do have numbers. To make those numbers appear, add them to the end of their respective text labels: <span class="InputCode">10 "Terrible 10" 15 20 "Mediocre 20" 25 30 "Very Good 30" 35 40</span>. That way they'll line up with the other numbers.</p>
<p><img alt="Plot with text labels that include numbers" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_51.png" width="684"/></p>
<p><span class="MenuOutput">Minor tick/label properties</span> controls smaller ticks that go in between major ticks. They follow the same rules as major ticks, but the rules apply to the spaces between the major ticks rather than the whole axis. Obviously the default size is smaller as well, but they are otherwise similar.</p>
<p><span class="MenuOutput">Axis line properties</span> controls the appearance of the axis itself, while <span class="MenuOutput">Axis scale propertie</span>s controls its scale. This includes the ability to change it to a logarithmic scale, to reverse the scale, and to extend the scale (but not to truncate it--see <a href="#NoTruncate">the discussion above</a>).</p>
<h3><a id="UsingBywithGraphs" name="UsingBywithGraphs"></a>Using By with Graphs</h3>
<p>Using <em>by</em> in a graph does not give you a completely separate graph for each subpopulation, but it does give you a separate plots within a single graph.</p>
<p>The graph we have been working with has become unwieldy, so start by clicking the reset button (<img alt="Reset Button" height="21" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_10.png" width="20"/>). Then set up a scatter plot of <span class="InputCode">mpg</span> on <span class="InputCode">weight</span> just like we have made before. Click <span class="MenuOutput">Accept</span> to go back to the <span class="MenuOutput">twoway</span> window, then click on the <span class="MenuOutput">By</span> tab. Check the box for <span class="MenuOutput">Draw subgraphs for unique values of variables</span> and in the <span class="MenuOutput">Variables</span> box type or select <span class="InputCode">foreign</span>.</p>
<p><img alt="Setting up By" height="339" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_18.png" width="481"/></p>
<p>Click <span class="MenuOutput">Submit</span> and you'll see two scatter plots side-by-side, one for domestic cars and one for foreign cars.</p>
<p><img alt="Subpopulations plotted side-by-side using By" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_52.png" width="684"/></p>
<p>Now replace foreign with <span class="InputCode">rep78</span>. This variable takes on five values, plus it has some missing values. Check the boxes for <span class="MenuOutput">Add a graph with totals</span> and <span class="MenuOutput">Add graphs for missing values</span> and click <span class="MenuOutput">Submit</span>.</p>
<p><img alt="Setting up a more complex By" height="339" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_19.png" width="481"/></p>
<p><img alt="Plot using By with more values" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_53.png" width="684"/></p>
<p>The resulting graph has seven plots: one for each of the five standard values taken by <span class="InputCode">rep78</span>, one for observations which are missing <span class="InputCode">rep78</span>, and one for all observations. However, the default arrangement of these plots is not particularly attractive, so click on <span class="MenuOutput">Subgraph organization</span>.</p>
<p>One option would be to put all the plots on one row for easy comparison: set <span class="MenuOutput">Style</span> to <span class="MenuOutput">Compact, Rows/Columns</span> to <span class="MenuOutput">Rows</span> and then the number of rows to <span class="InputCode">1</span>. Click <span class="MenuOutput">Submit</span> to see the result--obviously if you wanted to use this you'd have to do something about the X axis labels, but you know how to do that.</p>
<p><img alt="Reorganizing the plots" height="368" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_20.png" width="441"/></p>
<p><img alt="Many By plots in a row" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_54.png" width="684"/></p>
<p>Another possibility would be to go back to the original format, but move the <span class="MenuOutput">Total</span> graph to the center of the bottom row. First set the <span class="MenuOutput">Style</span> back to <span class="MenuOutput">Default</span> and <span class="MenuOutput">Rows/Columns</span> back to <span class="MenuOutput">Default</span>, and click <span class="MenuOutput">Submit</span> to take another look. This arrangement has room for nine plots in three rows with three plots each, and Stata numbers them left to right and then top to bottom. The <span class="MenuOutput">Total</span> graph is currently in the seventh position. If we tell Stata to leave the seventh position blank, it will automatically move to <span class="MenuOutput">Total</span> graph to the eighth position, which is in the center of the bottom row. To do so, check <span class="MenuOutput">Force holes in the placement of graphs</span> and in the <span class="MenuOutput">Holes</span> box type <span class="InputCode">7</span>. Note that you could put multiple numbers in this box if you wanted to leave multiple holes. Click <span class="MenuOutput">Submit</span> to see the result.</p>
<p><img alt="Leaving holes in by plots" height="368" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_21.png" width="441"/></p>
<p><img alt="Many By plots with the last one centered" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_55.png" width="684"/></p>
<p>Now click Accept to get back to the <span class="MenuOutput">twoway</span> window. The <span class="MenuOutput">Subgraph titles</span> and <span class="MenuOutput">Subgraph regions</span> are all about controlling appearance and are similar to what you've seen before. <span class="MenuOutput">Subgraph axes</span> are a little more interesting. One problem with our last graph is that Stata tried to reduce clutter by only putting one set of axes per row and column, but given the layout it looks random. You can fix that by clicking <span class="MenuOutput">Subgraph axes</span> and then under <span class="MenuOutput">Show Axes</span> set both <span class="MenuOutput">Y axes</span> and <span class="MenuOutput">X axes</span> to <span class="MenuOutput">Yes</span>. While you're here, also set <span class="MenuOutput">Rescale axes</span> to <span class="MenuOutput">Yes</span> for for both axes. This tells Stata to choose the scale for each subgraph  based on the points it contains rather than choosing one scale for all of them. This makes each subgraph look nicer, but makes it impossible to compare them (which may be the entire point of the graph).</p>
<p><img alt="Controlling the axes on each By plot" height="348" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_22.png" width="621"/></p>
<p><img alt="Many By plots, all with different scales" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_56.png" width="684"/></p>
<h3><a id="OverallOptions" name="OverallOptions"></a>Overall Options</h3>
<p>Finally click on the <span class="MenuOutput">Overall</span> tab to see some general-purpose options for the whole graph.</p>
<p>Schemes are stored sets of defaults. For example, the <span class="MenuOutput">Economist</span> scheme implements the graphics guidelines of the journal <em>The Economist</em>. The two monochrome schemes (<span class="MenuOutput">s1 monochrome</span> and <span class="MenuOutput">s2 monochrome</span>) are particularly useful if you need to print your graph in black and white. Feel free to experiment. It's also possible to create your own schemes. Try setting Scheme to <span class="MenuOutput">s1 monochrome</span> and then click Submit.</p>
<p><img alt="Choosing a Scheme" height="339" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_57.png" width="481"/></p>
<p><img alt="Monochrome plot" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_58.png" width="684"/></p>
<p><span class="MenuOutput">Graph size</span> can be confusing because when you're working with the graph in Stata, Stata will fit the graph in whatever size window you choose. However, when it comes to printing or exporting the graph Stata will make it match the size you set here.</p>
<p><span class="MenuOutput">Region properties</span> refers to the <span class="MenuOutput">Plot region</span> (everything inside a plot) and the <span class="MenuOutput">Graph region</span> (everything outside a plot). This is where you can make global changes to the appearance of your graph like changing background colors.</p>
<h2><a id="SavingaGraph" name="SavingaGraph"></a>Saving a Graph</h2>
<p>Once you've created the graph you want, you can save it by clicking <span class="MenuOutput">File</span>, <span class="MenuOutput">Save As</span> in the graph's window. However, you should choose what type of file to save it as carefully. The default, Stata Graph format (.gph), has the advantage of allowing you to make further changes to the graph with the graph editor. However, .gph files cannot be placed in other files like Word documents or web pages. If you want to put your graph in a Word document use <span class="MenuOutput">Enhanced Metafile</span> format (.emf) or for web pages we suggest <span class="MenuOutput">Portable Network Graphics</span> (.png).</p>
<p><img alt="Saving a graph and choosing a file format" height="412" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_24.png" width="563"/></p>
<p>For much more information see <a href="https://ssc.wisc.edu/sscc/pubs/4-23.htm">Using Stata Graphs in Documents</a>.</p>
<h2><a id="CreatingGraphsUsingCommands" name="CreatingGraphsUsingCommands"></a>Creating Graphs Using Commands</h2>
<p>As you worked through the previous sections you've probably noticed that Stata pasted a command into the Results window every time you created a graph. Stata used everything you clicked on to formulate the command, but it's the command that actually created the graph. As you can see, the commands to create graphs are often very complicated. If you write the commands yourself you may be able to make them somewhat simpler, but not much.</p>
<p>So why learn how to create graphs using commands at all? First of all, for simple graphs it can be much faster. For example, you can create your basic scatter plot of <span class="InputCode">mpg</span> on <span class="InputCode">weight</span> simply by typing</p>
<p class="InputCode">scatter mpg weight</p>
<p>Second, even if you've created a graph using the graphical user interface you may want to modify it by recalling the  command and  making changes. Third, there are a very few things that cannot be done using the graphical user interface.</p>
<p>On the other hand, there's little point in trying to learn the proper syntax for every graph option. Let the graphical user interface help you with details like choosing text sizes and colors. What you  need to know is the basic syntax structure, and that's what we'll discuss.</p>
<p>No matter how you created your graph, you should store the  command in a do file. This allows you to recreate the graph later, if needed. It also serves as a record of how you created the graph.</p>
<h3><a id="GraphCommands" name="GraphCommands"></a>Graph Commands</h3>
<p>All graph commands really come down to one command: <span class="InputCode">graph</span>. It is followed by either a type of graph (e.g. <span class="InputCode">graph bar</span>) or a family of graphs followed by a type of graph (e.g. <span class="InputCode">graph twoway scatter</span>). Then comes whatever information is needed to create the graph itself. However,  the most common graph types and families were also made standalone commands, which is why you can just type <span class="InputCode">scatter mpg weight</span>.</p>
<p>For the ubiquitous <span class="InputCode">twoway</span> family (basically graphs with a Y axis and an X axis) what follows is a <span class="italic">varlist</span>. The last variable in the list is taken to be the X variable, and all the others are Y's--similar to how <span class="InputCode">regress</span> handles a <em>varlist</em> but in the opposite way.</p>
<p>Graph commands can use <em>if</em> and <em>in</em> just like regular Stata commands: they go at the end of the command but before any options.</p>
<h3><a id="CombiningPlots" name="CombiningPlots"></a>Combining Plots</h3>
<p>If you want to include multiple plots in a graph, they must be separated either by putting them in parentheses or by putting two pipe characters between them (<span class="InputCode">||</span>). Thus to create a graph containing two scatter plots of <span class="InputCode">mpg</span> on <span class="InputCode">weight</span>, one for foreign cars and one for domestic cars, you can type either:</p>
<p class="InputCode">scatter mpg weight if foreign || scatter mpg weight if !foreign</p>
<p>or</p>
<p class="InputCode">twoway (scatter mpg weight if foreign) (scatter mpg weight if !foreign)</p>
<p>Note how in the second case you had to start with <span class="InputCode">twoway</span>. That's because a Stata command can't start with a parenthesis, but once you put it in the context of a twoway graph Stata will understand what you mean.</p>
<h3><a id="By" name="By"></a>By</h3>
<p>Graph commands cannot use the standard <em>by:</em> prefix, but most allow a <span class="InputCode">by</span> <em>option</em> that does the same thing:</p>
<p class="InputCode">scatter mpg weight, by(foreign)</p>
<h3><a id="Options" name="Options"></a>Options</h3>
<p>Graph options follow the general <em>option</em> rule of going at the end of the command following a comma, but by that definition a single graph can contain several "commands." For example, the <span class="MenuOutput">Sort on x variable</span> checkbox for line plots translates into the <span class="InputCode">sort</span> <em>option</em>, but it has to stay with the line plot if the graph has more than one. Thus if you typed:</p>
<p class="InputCode">line mpg weight || scatter mpg weight, sort</p>
<p>the sort option would be applied to the scatter plot, where it would do little good. Instead you should type</p>
<p class="InputCode">line mpg weight, sort || scatter mpg weight</p>
<p>Things like titles are also options:</p>
<p class="InputCode">scatter mpg weight, title(MPG vs Weight)</p>
<p>Note that the text of the title does not have to go in quotes--unless it has a comma in it. You can use quotes to separate lines, just like when you typed it in the <span class="MenuOutput">Title</span> box.</p>
<p>But what really makes life interesting is when your options have options. Suppose you wanted the title to be merely medium large (<span class="InputCode">medlarge</span>) rather than the default very large (<span class="InputCode">vlarge</span>), and also a dark red (specifically, <span class="InputCode">cranberry</span>). You can make it so with the <span class="InputCode">size</span> and <span class="InputCode">color</span> options, but to make it clear what they are controlling the size and color of they have to go inside the title's parentheses. Yet they still follow a (single) comma. Thus the command becomes:</p>
<p class="InputCode">scatter mpg weight, title(MPG vs Weight, size(medlarge) color(cranberry))</p>
<p>Of course it's at this point that it becomes attractive to let the graphical user interface keep track of the proper placement of such things for you, not to mention letting you know that <span class="InputCode">medlarge</span> and <span class="InputCode">cranberry</span> are among the available options.</p>
<p>For the rest of this article we'll type out the graph commands rather than using the graphical user interface, partially for practice but mostly because we'll be making fairly simple graphs and that's the quickest way to do so.</p>
<h2><a id="OtherTypesofGraphs" name="OtherTypesofGraphs"></a>Other Types of Graphs</h2>
<p>Stata can create dozens of different kinds of graphs--for a much larger sampling, see the <a href="http://www.stata.com/support/faqs/graphics/gph/statagraphs.html">Visual Overview on Stata's web site</a>. This section will discuss a few more that are fairly commonly used at the SSCC.</p>
<h3><a id="FitLines" name="FitLines"></a>Fit Lines</h3>
<p>Stata can plot several different kinds of fit lines automatically. The most common are <span class="InputCode">lfit</span> (linear fit), <span class="InputCode">qfit</span> (quadratic fit), <span class="InputCode">lfitci</span> (linear fit with confidence intervals) and <span class="InputCode">qfitci</span> (quadratic fit with confidence intervals. They're not very interesting by themselves--usually they're overlaid on a scatter plot. The syntax is just like any other twoway graph. Type:</p>
<p class="InputCode">scatter mpg weight || lfit mpg weight</p>
<p>(Or if you prefer, set up the scatter plot in the graphical user interface as usual, then add a second plot setting the <span class="MenuOutput">plot category and type</span> to <span class="MenuOutput">Fit plots</span> and choosing <span class="MenuOutput">Linear prediction</span>--but typing it will be a whole lot faster.)</p>
<p><img alt="Setting up a linear fit" height="409" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_26.png" width="621"/></p>
<p><img alt="Scatter plot with a fit line" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_59.png" width="684"/></p>
<p>The versions that show  confidence intervals need a little care because they can cover things up. Try:</p>
<p class="InputCode">scatter mpg weight || qfitci mpg weight</p>
<p><img alt="Fit line with a shaded confidence interval covering up part of a scatter plot" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_60.png" width="684"/></p>
<p>Any points within the confidence interval are covered up by the shaded region. You can fix that by reversing the order of the plots in the command. However, <span class="InputCode">qfitci</span> is not one of the plot types that is recognized by itself, so you need to start with <span class="InputCode">twoway</span>:</p>
<p class="InputCode">twoway qfitci mpg weight || scatter mpg weight</p>
<p><img alt="Plot with the scatter plot over the shaded confidence interval" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_61.png" width="684"/></p>
<p>Now all the points are shown. Think of a Stata graph as a painting done with completely opaque paints. If you have multiple plots each plot is a layer of paint, and layers that are added later cover up what was there before. Thus plots that cover areas should be listed first, and anything that needs to go on top should be listed last.</p>
<p>However, all these plots do is regress Y on X (or Y on X and X^2) and plot the predicted values for Y. If you want to run a more complicated regression there's no automatic command to plot the predicted values. On the other hand, you can easily store the predicted values in a new variable and plot it.</p>
<p>Suppose you wanted to plot the predicted probabilities you got from a logit of <span class="InputCode">foreign</span> on <span class="InputCode">mpg</span> (a clear case of reversing cause and effect, but the methodology doesn't care). No graph command will do this for you, but you can do it yourself:</p>
<p class="InputCode">logit foreign mpg<br/>
            predict phat<br/>
            line phat mpg,sort</p>
<p><img alt="Plot of predicted probability against mpg" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_62.png" width="684"/></p>
<p>The result looks reasonable, but try it as a scatter plot:</p>
<p class="InputCode">scatter phat mpg</p>
<p><img alt="Scatter plot of predicted probability vs. mpg" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_63.png" width="684"/></p>
<p>This demonstrates that the only values of <span class="InputCode">mpg</span> represented in the graph are those represented in your data set (and keep in mind many observations have the same value of <span class="InputCode">mpg</span>). That may or may not be a problem, but if you wanted to plot a smooth curve over the full range of <span class="InputCode">mpg</span> you could replace the actual values of <span class="InputCode">mpg</span> with made-up numbers that are evenly distributed from 14 to 41:</p>
<p class="InputCode">gen realMPG=mpg<br/>
              replace mpg=(41-14)*(_n-1)/(_N-1)+14<br/>
            predict phat2<br/>
            scatter phat2 mpg<br/>
            replace mpg=realMPG</p>
<p><img alt="Smoother plot of phat vs. mpg" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_64.png" width="684"/></p>
<p>See <a href="https://ssc.wisc.edu/sscc/pubs/4-22.htm">Making Predictions with Counter-Factual Data in Stata</a> for more explanation of how this method works.</p>
<p>Note that with multivariate regressions if you want to plot the effect of one variable you will probably need to set the others to their means before making predictions. Otherwise the line will jump all over due to the effects of the other variables.</p>
<h3><a id="BarPlots" name="BarPlots"></a>Bar Plots</h3>
<p>Stata does two very different kinds of bar plots. <span class="InputCode">twoway bar</span> is just a variation on what we've seen before:</p>
<p class="InputCode">twoway bar mpg weight</p>
<p><img alt="Bar plot of mpg vs. weight" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_65.png" width="684"/></p>
<p>But there's also <span class="InputCode">graph bar</span> which is not part of the <span class="InputCode">twoway</span> family. It plots summary statistics (the default is mean) rather than values, and is normally used to compare between variables or between groups. Variables are simply listed, and the group variable is specified using the <span class="InputCode">over</span> option. For example:</p>
<p class="InputCode">graph bar weight price, over(foreign)</p>
<p><img alt="Bar graph with means of weight and price over foreign" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_66.png" width="684"/></p>
<p><span class="InputCode">hbar</span> is almost identical--it just turns everything sideways.</p>
<p class="InputCode">graph hbar weight price, over(foreign)</p>
<p><img alt="Horizontal bar plot" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_67.png" width="684"/></p>
<p>If you want to compare something other than the mean, put that statistic in parentheses before the list of variables:</p>
<p class="InputCode">graph hbar (median) weight price, over(foreign)</p>
<p><img alt="Bar plot comparing medians" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_68.png" width="684"/></p>
<h3><a id="Histograms" name="Histograms"></a>Histograms</h3>
<p>Histograms are very simple to create:</p>
<p class="InputCode">hist mpg</p>
<p><img alt="Histogram of mpg" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_69.png" width="684"/></p>
<p><br/>
              Note that by default Stata does not put frequency on the Y axis, but probability density. This fits with the idea of a histogram being an approximation to the probability density function, but probably isn't how you were taught to make histograms back in grade school. You can have it plot frequencies using the <span class="InputCode">frequency</span> option (<span class="InputCode">percent</span> is another that is frequently used).</p>
<p>If you don't like Stata's default bins you can take control by either setting the number of bins (<span class="InputCode">bin</span> option) or the width of a bin (<span class="InputCode">width</span> option). You can get the same results either way. The <span class="InputCode">mpg</span> variable goes from 12 to 41, for a total range of 29. Stata chose eight bins, which means each had a width of 29/8=3.625. If you wanted 10 bins, you could type:</p>
<p class="InputCode">hist mpg, bin(10) frequency</p>
<p><img alt="Histogram of mpg with more bins" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_70.png" width="684"/></p>
<p>But you'll get the exact same graph from</p>
<p class="InputCode">hist mpg, width(2.9) frequency</p>
<p>If you have discrete data, the discrete option tells Stata to choose bins accordingly. For example, if you just type:</p>
<p class="InputCode">hist rep78</p>
<p>Stata will choose eight bins even though <span class="InputCode">rep78</span> only has five values. The result is a confusing histogram of fairly simple data.</p>
<p><img alt="Histogram with too many bins" height="549" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_83.png" width="625"/></p>
<p>However, if you add the discrete option Stata creates five bins for the five values:</p>
<p class="InputCode">hist rep78, discrete</p>
<p>The result is a much clearer graph.</p>
<p><img alt="Histogram with the right number of bins" height="549" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_84.png" width="625"/></p>
<h3><a id="KernelDensities" name="KernelDensities"></a>Kernel Densities</h3>
<p>You can overlay a kernel density on your histogram just by adding the <span class="InputCode">kdensity</span> option (there's also a <span class="InputCode">normal</span> option to add  a normal density).</p>
<p class="InputCode">hist mpg, width(2.9) frequency kdensity</p>
<p><img alt="Histogram of mpg with an overlaid kernel density plot" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_71.png" width="684"/></p>
<p>You can also create an independent kernel density plot with the <span class="InputCode">kdensity</span> command:</p>
<p class="InputCode">kdensity mpg</p>
<p><img alt="Kernel density plot of mpg" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_72.png" width="684"/></p>
<p>The most commonly used option for kernel densities is <span class="InputCode">bwidth</span>, which sets the bandwidth. Compare:</p>
<p class="InputCode">kdensity mpg, bwidth(5)</p>
<p><img alt="Kernel density with bandwidth=5" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_73.png" width="684"/></p>
<p>with:</p>
<p class="InputCode">kdensity mpg, bwidth(1)</p>
<p><img alt="Kernel density with bandwidth=1" height="641" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_74.png" width="684"/></p>
<h2><a id="TheGraphEditor" name="TheGraphEditor"></a>The Graph Editor</h2>
<p>Stata includes a graph editor that can be used to modify a graph after it has been created. Its big disadvantage is that it doesn't give you a command you can save in a do file and use to recreate the graph at will. However, it does allow you to make changes very simply and easily.</p>
<p>To see it in action, make a simple scatter plot:</p>
<p class="InputCode">scatter mpg weight</p>
<p>Then click <span class="MenuOutput">File</span>, <span class="MenuOutput">Start Graph Editor</span>. You're now ready to make changes to this graph.</p>
<p><img alt="The Stata Graph Editor" height="501" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_29.png" width="688"/></p>
<p>On the left are several buttons that place the graph editor in a particular mode. The top button, the arrow, puts it in pointer mode, which allows you to select an item on the graph to edit. For example, if you click on the plot part of the graph (i.e. inside the axes) you'll be able to edit the plot region. <span class="MenuOutput">Color</span> and <span class="MenuOutput">Margin</span> will appear in the tool bar at the top, but if you click <span class="MenuOutput">More</span> you'll be able to change many more properties.</p>
<p><img alt="Editing the plot region" height="504" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_81.png" width="695"/></p>
<p> If you then click on a particular point you can change the plot itself. Now the immediate options are <span class="MenuOutput">Plottype</span>, <span class="MenuOutput">Color</span>, <span class="MenuOutput">Size</span>, and <span class="MenuOutput">Symbol</span>, but you can again click <span class="MenuOutput">More</span> to see other things.</p>
<p><img alt="Editing a plot" height="504" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_82.png" width="695"/></p>
<p>As you do, note the <span class="MenuOutput">Object Browser</span> on the right. Stata keeps track of the various parts of a graph in a sort of tree structure, and as you click on things it will highlight the object you've selected. You can also select an object directly. For example, click <span class="MenuOutput">title</span> and you can add a title by typing it in the <span class="MenuOutput">Text</span> box.  Type in <span class="InputCode">MPG vs. Weight (1978 Cars)</span> and press <span class="InputCode">Enter</span> to see the results.</p>
<p><img alt="Graph editor, setting a title" height="504" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_75.png" width="695"/></p>
<p>The next three buttons (the large <span class="MenuOutput">T</span>, the diagonal line, and the circle with a plus sign) allow you to add text, draw lines and place new points anywhere you need them. As an example, let's add the  Toyota Prius for comparison (46 mpg and about 3000 pounds for a 2008 four-door). The smart way would be to add it to the dataset before making the graph, but we'll do it using the graph editor as an exercise.</p>
<p>The first problem is that the graph ends at 42 mpg. To fix that select <span class="MenuOutput">yaxis1</span> in the <span class="MenuOutput">Object Browser</span> and click <span class="MenuOutput">More</span>. Then set the <span class="MenuOutput">Axis rule</span> to <span class="MenuOutput">Range/Delta</span> with a <span class="MenuOutput">Minimum value</span> of <span class="InputCode">10</span>, a <span class="MenuOutput">Maximum value</span> of <span class="InputCode">50</span> and a <span class="MenuOutput">Delta</span> of <span class="InputCode">5</span>. Click <span class="MenuOutput">OK</span> and the graph will be rescaled--and more ticks will be added so we have a better chance at marking 46 accurately.</p>
<p><img alt="Editing the Y axis" height="519" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_76.png" width="481"/></p>
<p><img alt="Plot with rescaled Y axis" height="504" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_77.png" width="695"/></p>
<p>Now click the circle with a plus sign on the left and then click as best you can at the location mpg=46 (just above the line) and weight=3000. This will create a hollow circle at that location by default, but note that you could change its appearance at will. Seeing the point on the graph makes it clearer that the real advantage of a Prius over a 1978 VW Diesel (the 1978 car with 41 MPG) is not the Prius' somewhat higher MPG, but the fact that it gets that MPG despite being a much heavier car.</p>
<p><img alt="Plot with a point added" height="504" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_78.png" width="695"/></p>
<p>Now click on the <span class="MenuOutput">T</span> to add text and then click to the right of the new point. This will give you the <span class="MenuOutput">Textbox properties</span> window. In the <span class="MenuOutput">Text</span> box type <span class="InputCode">2008 Toyota Prius for comparison</span> and set the <span class="MenuOutput">Size</span> to <span class="MenuOutput">Small</span>. Then click <span class="MenuOutput">OK</span>.</p>
<p><img alt="Addind a textbox" height="319" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_79.png" width="341"/></p>
<p><img alt="Plot with a label for the added point" height="504" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_80.png" width="695"/></p>
<p>The bottom button on the left is the "grid editor." This allows you to make drastic changes to your graph, like rearranging the parts. Use with discretion, and saving your graph before changing anything is highly recommended.</p>
<p>This is a good time to mention why you might want to save graphs in Stata format: while it's true that you can't put them into documents that way, you can make changes to them in the graph editor. Thus you might want to keep two copies of important graphs, one in Stata graph format in case you need to make changes, and one in something like .emf format that you can insert into your paper.</p>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url>https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_1.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_2.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_33.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_3.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_34.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_9.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_35.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_4.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_36.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_28.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_37.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_38.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_5.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_39.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_6.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_40.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_27.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_41.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_10.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_42.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_7.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_43.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_31.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_32.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_8.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_44.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_11.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_45.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_25.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_46.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_14.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_47.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_12.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_48.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_13.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_49.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_17.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_50.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_51.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_10.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_18.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_52.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_19.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_53.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_20.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_54.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_21.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_55.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_22.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_56.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_57.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_58.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_24.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_26.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_59.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_60.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_61.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_62.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_63.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_64.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_65.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_66.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_67.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_68.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_69.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_70.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_83.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_84.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_71.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_72.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_73.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_74.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_29.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_81.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_82.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_75.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_76.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_77.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_78.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_79.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-24b/4-24_80.png</img_base_url>
</kb_document>
<kb_document>
<kb_title>Including Calculated Results In Stata Graphs </kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p>Sometimes you want to include a result you've calculated
          		in a Stata graph. For example, you might want to have a
          		note give the mean of a variable. One option of course is to
          		find out the mean ahead of time and just type it in. But what
          		if your data change? Like all Stata commands, <span class="InputCode">graph</span> commands
          		can include macros. So if you have Stata find the number you
          		want and then store it as a macro, you can then use the macro
          		to put that number in your graph.</p>
<p>If you're not familiar with macros, please read  the Local
          		Macros section of <a href="https://www.ssc.wisc.edu/sscc/pubs/stata_prog1.htm">Stata Programming Essentials</a> before continuing. </p>
<p>As an example, load the automobile data set. Then create
          		a scatter plot of mpg vs. weight with a linear fit line overlaid
          		on it, with confidence intervals:</p>
<p class="InputCode">sysuse auto<br/>
            twoway (lfitci mpg weight) (scatter mpg weight)</p>
<p>Be sure to  put the linear fit first so the points from
          		the scatter plot can overlay the shaded 95% confidence interval.</p>
<p><img alt="Scatterplot MPG vs. Weight" height="447" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-25/4-25_1.png" width="640"/></p>
<p>Next add a note giving the R-squared of the implied regression.
          		Find it with:</p>
<p class="InputCode">regress mpg weight</p>
<p>which gives:</p>
<pre>      Source |       SS       df       MS              Number of obs =      74
-------------+------------------------------           F(  1,    72) =  134.62
       Model |   1591.9902     1   1591.9902           Prob &gt; F      =  0.0000
    Residual |  851.469256    72  11.8259619           R-squared     =  0.6515
-------------+------------------------------           Adj R-squared =  0.6467
       Total |  2443.45946    73  33.4720474           Root MSE      =  3.4389

------------------------------------------------------------------------------
         mpg |      Coef.   Std. Err.      t    P&gt;|t|     [95% Conf. Interval]
-------------+----------------------------------------------------------------
      weight |  -.0060087   .0005179   -11.60   0.000    -.0070411   -.0049763
       _cons |   39.44028   1.614003    24.44   0.000     36.22283    42.65774
------------------------------------------------------------------------------
			</pre>
<p>You could just  add a note with that value:</p>
<p class="InputCode">twoway (lfitci mpg weight) (scatter mpg weight), note(R-squared=.6515)</p>
<p><img alt="Scatterplot with note that R-squared=.6515" height="447" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-25/4-25_2.png" width="640"/></p>
<p>But why not let Stata do the work? After a regression, the R-squared is
				stored as <span class="InputCode">e(r2)</span> . You can store that
				in a macro and put the macro in your graph instead of typing
				the number yourself.</p>
<p>(To see a full list of the stored values
				available to you, type <span class="InputCode">ereturn
					list</span> after an estimation command like this one, or <span class="InputCode">return
					list</span> after a basic command like <span class="InputCode">summarize</span>.)</p>
<p class="InputCode">local r2=e(r2)<br/>
            twoway (lfitci mpg weight) (scatter mpg weight), note(R-squared=`r2')</p>
<p><img alt="Scatterplot with note that R-sqared=.6515312529087511" height="447" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-25/4-25_3.png" width="640"/></p>
<p>It works, but it's rather ugly because the r2 macro contains all sixteen
				digits. Four was much better. Fortunately there's a way to format
				a number before it's stored in a macro. It's done by calling
				on  the <span class="InputCode">display</span> command:</p>
<p class="InputCode">local r2: display %5.4f e(r2)</p>
<p>Here we use a colon (<span class="InputCode">local r2:</span>) to indicate
				we're going to store the results of a <span class="InputCode">display</span> command  in
				the local macro <span class="InputCode">r2</span>. <span class="InputCode">%5.4f</span> is
				the format we'll use: it specifies that the number be displayed
				with no more than five characters (including the decimal point)
				and no more than four digits to the right of the decimal point.
				As a result <span class="InputCode">r2</span> contains .6515 rather than
				.6515312529087511, giving a much nicer result when you create
				the graph.</p>
<p>The complete code to create the nice graph is:</p>
<p class="InputCode">sysuse auto<br/>
            reg mpg weight<br/>
            local r2: display %5.4f e(r2)<br/>
            twoway (lfitci mpg weight) (scatter mpg weight), note(R-squared=`r2')</p>
<p><img alt="Scatterplot with note that R-squared=.6515" height="447" src="https://ssc.wisc.edu/sscc/pubs/screenshots/4-25/4-25_4.png" width="640"/></p>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url>https://ssc.wisc.edu/sscc/pubs/screenshots/4-25/4-25_1.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-25/4-25_2.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-25/4-25_3.png, https://ssc.wisc.edu/sscc/pubs/screenshots/4-25/4-25_4.png</img_base_url>
</kb_document>
<kb_document>
<kb_title>An Introduction to Mata </kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p>Mata is a matrix language built into Stata, similar in many ways
          		to R, Matlab or GAUSS. It does have some unique and intriguing
          		features however. One is that it is a compiled language rather
          		than interpreted, which improves performance. It also has been
          		parallelized in Stata/MP (available on all the SSCC Linux servers
          		and Condor) which dramatically improves performance.  </p>
<p>Mata is not a replacement for Stata, nor is it intended to be a
          		stand-alone statistical package. It is a tool which is best used
          		as a supplement to Stata, for doing those things
          		Stata does not do well on its own. In particular, Mata does not work
          		in the context of a single data set, giving it additional flexibility.
          		But you should not try to learn Mata unless you are already
          		familiar with Stata or another statistical package. </p>
<p> Mata is a relatively "low level" language. Much of your
          		time in Stata (or SAS or SPSS) is spent using built-in programs,
          		finding just the right combination of options to get Stata
          		to do what you want. In Mata you will take direct control, telling
          		Mata what you want to do step-by-step. (The Mata optimizer, which
          		we will discuss at length, is a notable exception.) That means
          		doing simple things is usually more cumbersome in Mata than in
          		Stata, but Mata has fewer constraints. </p>
<p>This article is primarily written for people who have significant
          		experience using Stata, SAS or SPSS syntax, but no other programming
          		languages. Thus there will be a lot of emphasis on learning how
          		to do useful things by manipulating matrices, and many of the
          		examples are designed to give experience doing so as well as
          		illustrating a particular concept. Matlab and GAUSS veterans
          		may find they can skim these sections, focusing on what is new
          		to them. C programmers will find that Mata imitates C whenever
          		it can, so they can probably skim the sections on standard programming
          		constructs like loops. But no matter what your background, you
          		will learn far more if you read this article at the computer,
          		with Stata running, and actually type in the examples. </p>
<p>Mata runs within Stata, so in order to use Mata you'll need to
          		know how to run a Stata program, called a do file. If you've
          		never used Stata, please read the section on do files in <a href="https://ssc.wisc.edu/sscc/pubs/intro_stata/intro_stata4.htm">An
          		Introduction to Stata</a>. Interactive Stata (i.e. start it up and
          		type in commands) is a great way to learn and that's how you'll
          		do the examples in this article. But for real work you'll
          		want to write everything in do files.</p>
<p>There are several example files associated with this article.
          		There are links to them in the text as they are used. However,
          		if you're using an SSCC Linux server you may want to copy them
          		all ahead of time. To do so type the following at the Linux prompt:</p>
<p class="InputCode">mkdir mataclass<br/>
          	cd mataclass<br/>
          		cp /usr/global/web/sscc/pubs/files/4-26/* . </p>
<p>Most of the commands you'll type as you read are also  contained
          		in <a href="https://ssc.wisc.edu/sscc/pubs/files/4-26/mataclass.do">mataclass.do</a>. The two
          		major examples are found in <a href="https://ssc.wisc.edu/sscc/pubs/files/4-26/ex1.do">ex1.do</a> and
       		  <a href="https://ssc.wisc.edu/sscc/pubs/files/4-26/ex2.do">ex2.do</a>.</p>
<h2>Mata Basics</h2>
<p>To start Mata, first start up Stata and then type </p>
<p class="InputCode">mata</p>
<p>in the command window. Stata will then switch to "Mata mode." It's
          		easy to forget which mode you're in, but if you look carefully
          		at the bottom of the review window, where you normally see a
          		period you'll now see a colon. Of course when you first start
          		Mata there's a big horizontal line that says <span class="MenuOutput">mata</span> but that won't
          		be visible for long. That bar also reminds you of another useful
          		command: to get out of Mata mode, type</p>
<p class="InputCode">end</p>
<p>While Stata is organized around commands, Mata is organized around
          		"statements." For example, you can simply type</p>
<p class="InputCode">2+2</p>
<p>and Mata will return</p>
<p class="InputCode">4</p>
<p>Storing the results in a variable is just as easy:</p>
<p class="InputCode">x=2+2</p>
<p>Note that there was no output this time. If you want to see the
          		value of x, simply type:</p>
<p class="InputCode">x</p>
<p>and you'll get <span class="InputCode">4</span> back.</p>
<h2>Matrix Operators</h2>
<p>In our earlier examples, the plus sign acted as an operator: Mata
          		recognized it as saying "take the thing before the plus sign
          		and the thing after the plus sign  and sum them." Mata
          		also defines matrix operators which carry out matrix manipulations.</p>
<h3>Column and Row Join </h3>
<p>The comma is defined as the "column join" operator, or
          		"take the things before and after the comma and put them next
          		to each other." That means</p>
<p class="InputCode">1,2</p>
<p>is interpreted by Stata as a matrix with one row and two columns.
          		In fact, type it and the output will be:</p>
<pre>       1   2
    +---------+
  1 |  1   2  |
    +---------+
</pre>
<p>The backslash (<span class="InputCode">\</span> not<span class="InputCode"> /</span>,
          		which is division) is the "row join" operator, or "take the thing
          		before the backslash and stack it on top of the thing after it."
          		Thus</p>
<p>1\2</p>
<p>is a matrix with two rows and one column:</p>
<pre>       1
    +-----+
  1 |  1  |
  2 |  2  |
    +-----+
</pre>
<p>The things to be operated on are not limited to scalars, so you
          		can construct matrices.</p>
<p class="InputCode">1,2\3,4</p>
<p>gives</p>
<pre>
       1   2
    +---------+
  1 |  1   2  |
  2 |  3   4  |
    +---------+ </pre>
<h3>Error Messages </h3>
<p>There are limits:</p>
<p class="InputCode">1,2\3\4</p>
<p>gets you</p>
<p> <span class="MenuOutput">&lt;istmt&gt;: 3200 conformability error<br/>
          		r(3200);</span><br/>
<br/>
								 You	can't	make	a matrix whose first
								 row has two columns but whose second and third
								 rows have one column. Stata calls this as a
								 conformability error, a class which also includes
								 things like trying to multiply matrices where
								 the number of columns of the first matrix is different from the number
			    of rows of the second.</p>
<p>This is also a "runtime" error. When you give Mata a
          		statement, the first thing it does is compile the statement into
          		byte code. At that point Mata isn't looking at the specific quantities
          		to be manipulated. All it sees is "put something next to something
          		else, then stack that on top of two other things." That makes
          		sense, so the statement compiles successfully. Only when the
          		code runs does Mata notice that the things to be stacked have
          		different numbers of columns.</p>
<p>A compile time error is generated when the statement doesn't make
          		sense no matter what quantities you plug into it. For example,</p>
<p class="InputCode">1,\3\4</p>
<p>Gets you </p>
<p><span class="MenuOutput">invalid expression<br/>
          		r(3000);</span></p>
<p>Compile time errors are always error code 3000, and don't include
          		<span class="MenuOutput">&lt;istmt&gt;</span>. Noting whether an
          		error is a compile time error or a runtime error can help you
          		in finding the problem. If it was runtime, you know Mata at least
          		understood your code (though there's no guarantee it understood
          		it to mean the same thing you understand it to mean) and it was
          		something about the specific quantities  it was working with
          		that caused the problem. If it's compile time, the code doesn't
          		even make sense to Mata.</p>
<h3>Parentheses</h3>
<p>As you're putting together matrices you're welcome to include parentheses
          		to help clarify things. It's mostly for your benefit:</p>
<p class="InputCode">1,2\3,4<br/>
          		(1,2\3,4)<br/>
          		(1,2)\(3,4)</p>
<p>are all the same to Mata, but if one of them looks clearer to you
          		by all means use that style in all your programs. (I happen to be
          		a fan of the third.) </p>
<h3>Range Operators </h3>
<p>Another set of handy tools for creating matrices are the range
          		operators. The <span class="InputCode">..</span> operator creates
          		a series starting from the number on the left up to the number
          		on the right and makes them into a row vector. The <span class="InputCode">::</span> operator
          		does the same but puts them in a column vector.</p>
<p class="InputCode">1..3<br/>
          	1::3</p>
<p>It's not limited to integers, however:</p>
<p class="InputCode">1.2..3.5</p>
<p>Note that number on the right is not guaranteed to be part of the
          		resulting series.</p>
<h3>Variables</h3>
<p>The results of matrix statements can of course be saved in variables
          		just like other statements. For example:</p>
<p class="InputCode">x=3,4<br/>
          	y=5,6<br/>
          	z=(1,2)\x\y<br/>
          	z</p>
<p>Note how the definition of z looks a lot like the statement we
          		tried earlier that gave a runtime error. It runs now because
          		x and y both have two columns. That's why it was a runtime error
          		and not a compile time error: given the right inputs the statement
          		can work.</p>
<h3>Arithmetic Operators </h3>
<p>The standard arithmetic operators recognize when one or both of
          		their arguments is a matrix, and act accordingly. This includes
          		addition and subtraction, scalar times matrix, and full matrix
          		multiplication.</p>
<p>However, there are also "colon" operators which work element by
          		element. For addition and subtraction it makes no difference,
          		since they're element by element anyway. But it makes a great
          		deal of difference with multiplication. Consider the following:</p>
<p class="InputCode">x=(1,2)\(3,4)<br/>
          	y=(1,2)\(3,4)<br/>
          	x*y<br/>
          	x:*y</p>
<h3>Logical Operators </h3>
<p>Logical operators such as greater than, less than, and equal to
          		are also defined  in both matrix and colon versions (note that
          		the equals operator is ==, as opposed to = for assignment). However,
          		Mata does not have a boolean variable type. Thus (as in Stata)
          		logical operators return one for true and zero for false.</p>
<p>If you compare two matrices using standard greater than, less than
          		or equals, Mata returns one if and only if the condition is true
          		for all the elements of the two matrices. Otherwise it returns
          		zero </p>
<p class="InputCode">x==y<br/>
          		x&gt;y<br/>
          		x&lt;y<br/>
          	z=(1,2)\(3,5)<br/>
          	x==z<br/>
          	x&gt;z<br/>
          	x&lt;z<br/>
          	x&lt;=z</p>
<p>These operators can only work on matrices of the same size. </p>
<p>In their colon form, the result is a matrix containing all of the
          		element-by-element comparisons.</p>
<p class="InputCode">x:==y<br/>
          		x:==z<br/>
       			x:&lt;z</p>
<p>The colon form allows more flexibility about the sizes of the matrices
          		to be compared. If one argument is a scalar, row vector, or
          		column vector, it will be duplicated as needed so as to match
          		the other matrix.</p>
<p class="InputCode">x:==2 <br/>
          		x:==(1,2)<br/>
          		x:==(1\3)<br/>
</p>
<p>The transpose operator is the right single quote ('). It works
          		on just one object, the one to its left, and returns its transpose:</p>
<p class="InputCode">x'</p>
<p>There is no inverse operator, however. Inversion is carried out
          		by functions. </p>
<h2>Subscripts</h2>
<p>To reference a particular element of a matrix, put the row and
          		column number in square brackets after the matrix name. Given
          		the matrix <span class="InputCode">x</span> defined above, <span class="InputCode">x[1,1]</span> is <span class="InputCode">1</span>, <span class="InputCode">x[1,2]</span> is <span class="InputCode">2</span>,
          		etc. Subscripts can be used on either side of an equals sign:</p>
<p class="InputCode">z=x[1,1]<br/>
          	z<br/>
          	x[1,1]=5<br/>
x</p>
<p>If a matrix is a row or column vector, you can use just one subscript. </p>
<p class="InputCode">y=1,2,3<br/>
          		y[2]<br/>
          			y=1\2\3<br/>
       			y[2]</p>
<p>"Missing" for the row or column number is taken to mean
          		all the rows or columns. You can use either the standard period
          		for missing or simply leave the number out. Thus</p>
<p class="InputCode">x[.,1]<br/>
          	x[1,]</p>
<p>You can also replace either number with a row or column vector
          		(and Stata doesn't care which one you use). However, this time
          		parentheses are required so Mata knows where the list of rows
          		ends and the columns begin.</p>
<p class="InputCode">a=(1,2,3)\(4,5,6)\(7,8,9)<br/>
          	a[(1,3),.]</p>
<p>You can repeat rows or columns, mix up the order, or even create
          		matrices bigger than the original.</p>
<p class="InputCode">a[(3,2,1),(3,2,1)]<br/>
          		a[(3,1,2,2,1,3),.]          	</p>
<p>Pre-defined vectors are also just fine:</p>
<p class="InputCode">b=(3,1,1)<br/>
          	a[.,b]</p>
<p>Note that using  vector subscripts like this will be  faster
          		than multiplying by a permutation matrix.</p>
<h3>Subscripting Ranges </h3>
<p>Mata refers to the subscripts we've used thus far as "list" subscripts.
          		Every element we wanted was listed explicitly (well, except for
          		missing meaning "all"). But you'll often want  to specify
          		a range of rows and columns.</p>
<p>There's not much need for ranges with small matrices, so begin
          		by creating a bigger matrix: </p>
<p class="InputCode">x1=1..10<br/>
          	x2=(1::10)*10<br/>
          	x=x1[(1,1,1,1,1,1,1,1,1,1),.]+x2[.,(1,1,1,1,1,1,1,1,1,1)]<br/>
          	x</p>
<p>Take a moment to try to figure out how this worked before reading
          		further. </p>
<p>The first line defines <span class="InputCode">x1</span> as a row
          		vector using the range operator. The second defines a <span class="InputCode">x2</span> column
          		vector, again using the range operator but multiplying the result
          		by ten. The third then defines x as ten copies of x1 stacked
          		on top of each other plus ten copies of x2 placed next to each
          		other. The result is a ten by ten matrix that goes from 11 to
          		110, which will make it easy to tell which rows and columns we've
          		extracted in the next few examples. (Yes, there are easier ways
          		to do this using functions and/or loops, but we haven't covered
          		them yet.)</p>
<p>One method of extracting a range of rows and columns from x is
          		to use the range operators within list subscripts. Thus to get
          		rows 3-7 and columns 4-8 you could do:</p>
<p class="InputCode">x[(4..7),(3..8)]</p>
<p>This is exactly equivalent to typing out: </p>
<p class="InputCode">x[(4,5,6,7),(3,4,5,6,7,8)]</p>
<p>True range subscripts, however, are different. For one thing, they
          		are contained in square brackets and the pipe character (shift-backslash).
          		There are two elements, separated by a backslash: the row and
          		column of the upper left corner of the desired range, and the
          		lower right corner of the desired range. Thus the equivalent
          		to</p>
<p class="InputCode">x[(4..7),(3..8)]</p>
<p>is</p>
<p class="InputCode">x[|4,3\7,8|]</p>
<p>Think of it as replacing "rows four through seven and columns three
          		through eight" with "everything between row four, column three
          		and row seven, column eight, inclusive."</p>
<p>Missing can mean several things in range subscripts. If used
          		in specifying the upper left corner, it means either the first
          		row or the first column. If used in specifying the lower right
          		corner, it means either the last row or the last column. Thus</p>
<p class="InputCode">x[|.,.\.,.|]</p>
<p>is simply all of <span class="InputCode">x</span>.
          		There's also no rule that says the upper left and bottom right
          		corners can't be on the same row or column.</p>
<p class="InputCode">x[|3,3\3,.|]          		</p>
<p>This means "row three, from the third column to the end." </p>
<h2>Getting your Data from Stata to Mata</h2>
<p>Most of the time you won't be creating matrices by hand. Instead
          		you'll want to make matrices containing the data you already
          		have in Stata. You're also likely to want to take your Mata results
          		and copy them to your Stata data set.</p>
<p>The first question you need to answer is whether you want to make
          		a fresh copy of your data, or whether you want to have Mata work
          		with the Stata data directly. Mata can define matrices which
          		are actually "views" of your Stata data. Think of a view
          		as just giving your Stata data a name Mata can use. Views use
          		a trivial amount of memory even if your data are very large.
          		If you  change the tables of a view matrix, the Stata
          		data are also changed. If you make a copy of the data instead
          		you can make changes and keep the original intact, however you'll
          		use twice as much memory.</p>
<h3>st_data</h3>
<p>To make copies of your data you'll use the <span class="InputCode">st_data</span> family
          		of functions. The simplest and the fastest is <span class="InputCode">_st_data</span>.
          		It is used to get a single number from your data set. It takes
          		two arguments: an observation number and a variable number. Think
          		of your data set as a matrix already, and the variable number
          		is simply the column number of the variable you want.</p>
<p>To see this in action, first end Mata by typing <span class="InputCode">end</span>, load
          		the automobile example data set, list observation one, and go
          		back into Mata: </p>
<p class="InputCode">end<br/>
          	sysuse auto<br/>
          	l in 1 <br/>
          	mata</p>
<p>Now get the price of the first car by typing:</p>
<p class="InputCode">_st_data(1,2)</p>
<p>The result will be 4099, which matches what you just listed. Try
          		some other variables to make sure you've got the idea. Note that
          		if you try to get the first column you'll get a missing value.
          		That's because <span class="InputCode">_st_data</span> is only for numeric data. For strings,
          		use <span class="InputCode">_st_sdata</span> which works in pretty much the same way.</p>
<p class="InputCode">_st_sdata(1,1)</p>
<p>Mata can look up the column numbers for you using the <span class="InputCode">st_varindex</span>          		function.
          		It takes the name of the variable you want and returns the index.
          		However, that process will slow things down slightly. Note that
          		you're welcome to use the output of one function as an argument
          		for another function: </p>
<p class="InputCode">_st_data(1,st_varindex("mpg"))</p>
<p>If you want more than  one value, use <span class="InputCode">st_data</span>.
          		<span class="InputCode">st_data</span> can be used just like <span class="InputCode">_st_data</span> (though
          		in that case <span class="InputCode">_st_data</span>          		is
          		faster). However, <span class="InputCode">st_data</span> is more
          		flexible about the arguments it will accept.</p>
<p>The row number can be missing, in which case all observations are
          		returned. It can also be a column vector, in which case only
          		the specified observations are returned. It can also be a matrix
          		with two columns. Each row then represents a range of observations.
          		A missing in this case is interpreted as the last observation. </p>
<p>The column number  can also be missing (all variables) or a vector
          		listing the variables desired. It can also accept the names of
          		the variables rather than their numbers, though this will be
          		slower. It does not allow you to specify ranges like you can
          		for rows.</p>
<p>Like <span class="InputCode">_st_data</span>, <span class="InputCode">st_data</span> cannot handle strings. But there is an equivalent
          		<span class="InputCode">st_sdata</span>. </p>
<p>Try the following:</p>
<p class="InputCode">st_data(.,.)<br/>
          	st_data((1,3),2)<br/>
          	st_data(1,(2,4))<br/>
          	st_data(1,("price","rep78"))<br/>
          	st_sdata(.,1)</p>
<p>Naturally all these results could be stored in matrices for future
          		use.</p>
<p class="InputCode">x=st_data(1,(2,4))<br/>
          	x</p>
<p><span class="InputCode">st_data</span> can also take a third argument:
          		a selection variable. This can be either the index or the name
          		of a variable, and if it is specified then only observations
          		where that variable is not equal to zero are returned. Choosing
          		0 as the select variable has a special meaning: in that case
          		observations will be excluded if they have a missing value for
          		any variable specified.</p>
<p class="InputCode">st_sdata(.,1,"foreign")</p>
<h3>st_view</h3>
<p><span class="InputCode">st_view</span> makes views onto your data
          		rather than copying them, but you can select rows and
          		variables using the exact same methods as <span class="InputCode">st_data</span>.
          		However, <span class="InputCode">st_view</span> gives you the results
          		in a different way. With
          		<span class="InputCode">st_data</span>, the matrix you wanted was
          		what the <span class="InputCode">st_data</span>          		function
          		returned. You could then store the results or simply let them
          		 be displayed on the screen. With <span class="InputCode">st_view</span>,
          		 the function itself returns nothing. Instead you need to pass
          		 in a matrix which will be replaced with the view you select.</p>
<p class="InputCode">st_view(x,.,.)<br/>
          	x</p>
<p>One catch is that the matrix has to exist before you pass it in.
          		It doesn't matter how big it is--in fact it will be completely
          		replaced--but if you try to pass a matrix to st_view that hasn't
          		been defined somehow you'll get a runtime error. One easy way
          		is to simply set the matrix you want to use to zero before passing
          		it in. You can even do that inside your function call: </p>
<p class="InputCode">          	st_view(n=0,1,(2,4))<br/>
          	n</p>
<p><span class="InputCode">x</span> and <span class="InputCode">n</span> now
          		look like a regular matrices, but keep in mind that they are
          		in fact  views. If your objective in using a view is to save
          		memory, you have to be careful not to make copies of it.</p>
<p class="InputCode">y=x</p>
<p>does not create a new view. It creates a new matrix containing
          		the values of <span class="InputCode">x</span>; a copy. More subtly,</p>
<p class="InputCode">x[.,j]</p>
<p>creates a  copy of the jth column of x. If you need a particular
          		column out of x, you can just create a new view:</p>
<p class="InputCode">st_view(xj,.,j) </p>
<p>There's no limit to the number of different views you can set up
          		for the same data.</p>
<h3>Getting your Data from Mata to Stata</h3>
<p>If all you want to do is change the values of existing variables,
          		make a view and change at will. But if you want to add new variables
          		you'll need a couple more functions.</p>
<p><span class="InputCode">st_addvar</span> adds a new variable. It takes two arguments: the variable
          		type and the variable name. It returns the index of the variable,
          		though storing that for future use is optional.</p>
<p>Let's create a new variable: weight*mpg (so, pound-miles per gallon,
          		a unit only an engineer could love).</p>
<p class="InputCode">          	st_view(mpg=0,.,"mpg")</p>
<p>Note that the matrix called <span class="InputCode">mpg</span> is now a view of all rows of the
          		<span class="InputCode">mpg</span> variable.</p>
<p class="InputCode">          	st_view(weight=0,.,"weight")<br/>
          	pmg=weight:*mpg<br/>
          	st_addvar("long","pmg")<br/>
          	st_store(.,"pmg",pmg)</p>
<p>To explore this new variable using the Stata tools you're familiar
          		with, type <span class="InputCode">end</span>. Of course this is
          		an extraordinarily clumsy replacement for</p>
<p class="InputCode">gen long pmg=mpg*weight</p>
<p>This leads to a general principle: use Mata for what it's
          		good at, and Stata for what it's good at.</p>
<p>There are a wide variety of other functions you can use to communicate
          		between Mata and Stata, including adding observations and getting
          		or setting local macros, e() and r() vectors, and much more.
          		See the manual for details. </p>
<h2>Saving and Loading Mata Data</h2>
<p>Most often the goal of a Mata program is to take your Stata
          		data, find a result, and then either display it or put it back
          		into your Stata data. However, you can save Mata matrices themselves
          		if you need to.</p>
<p>To save a matrix, type</p>
<p class="InputCode">mata matsave <span class="Parameter">filename</span> <span class="Parameter">matrixlist</span></p>
<p>Replace <span class="Parameter"><span class="InputCode">filename</span></span> with
          		the name of the file you want to create. Stata will add <span class="InputCode">.mmat</span> to
          		the filename automatically. Replace <span class="Parameter"><span class="InputCode">matrixlist</span></span> with
          		one or more matrices you want to save (separating them with spaces)
          		or with an asterisk (<span class="InputCode">*</span>) to save all
          		the matrices currently in memory.</p>
<p>To load the matrices you've saved previously, type</p>
<p class="InputCode">mata matuse <span class="Parameter">filename</span></p>
<p>This will load all the matrices stored in <span class="Parameter"><span class="InputCode">filename</span></span>. </p>
<p>Both commands will accept the <span class="InputCode">replace</span> option.
          		For <span class="InputCode">matsave</span>, this allows Mata to overwrite
          		the existing file on disk. For <span class="InputCode">matuse</span>,
          		this allows Mata to overwrite existing matrices in memory with
          		the same names as matrices in the file. </p>
<p>These commands are intended for interactive use and cannot be
          		used in functions. If you need to save matrices within a function,
          		check out <span class="InputCode">fopen</span>, <span class="InputCode">fputmatrix</span>, <span class="InputCode">fgetmatrix</span>,
          		and <span class="InputCode">fclose</span>.</p>
<h2>Hierarchical Data</h2>
<p>Hierarchical data has always been a bit awkward to work with in
          		Stata, or any other statistical program that uses a single data matrix.
          		A typical example would be individuals living in households: should
          		each household be one observation, or each individual? Either way
          		there are inefficiencies. In Mata you can have it both ways: one
          		matrix of individuals and one matrix of households. The key is linking
          		them together, but subscripts make that easy.</p>
<p>As an example, take a look at the <a href="https://ssc.wisc.edu/sscc/pubs/files/4-26/hh.dta">hh
          			Stata data set</a>, which is in Stata format. It consists of six individuals
          		living in three households. <span class="InputCode">hh</span> is
          		the household ID, <span class="InputCode">hhType</span> is the type
          		of household, and <span class="InputCode">hhInc</span> is the household
          		income. <span class="InputCode">age</span> and <span class="InputCode">female</span> are
          		individual variables. This data is in the long form, with one
          		observation for each individual, which means that the household
          		variables must be duplicated.</p>
<p class="InputCode">end<br/>
          	use hh,replace<br/>
          		l</p>
<p>Now enter mata and load the <a href="https://ssc.wisc.edu/sscc/pubs/files/4-26/hh.mmat">hh
          			Mata data set</a>.</p>
<p class="InputCode">mata<br/>
          		mata matuse hh<br/>
          	hh<br/>
          	ind</p>
<p>It contains two matrices, <span class="InputCode">ind</span> and <span class="InputCode">hh</span>.          		 <span class="InputCode">hh</span> contains the household level variables (<span class="InputCode">hhType</span>          		and <span class="InputCode">hhInc</span>). <span class="InputCode">ind</span> contains the individual variables (<span class="InputCode">age</span> and <span class="InputCode">female</span>)
          		plus the household ID. Note however, that <span class="InputCode">hh</span> does not contain an
          		ID: the row number is an implicit ID.</p>
<p>For example, if you wanted to know what type of household person
          		number two lives in, you'd use:</p>
<p class="InputCode">hh[ind[2,3],1] </p>
<p><span class="InputCode">ind[2,3]</span> is the household ID of
          		the second person, or the row in the hh matrix. Column one of
          		<span class="InputCode">hh</span> is the household type.</p>
<p>Of course a regression model may need a single matrix just like
          		Stata does. You can easily recreate the matrix as Stata views it
          		with:</p>
<p class="InputCode">x=ind,hh[ind[.,3],.]</p>
<p>Here <span class="InputCode">ind[.,3]</span> is a column vector
          		listing which row we want from <span class="InputCode">hh</span> for
          		each row of ind<span class="InputCode">.</span> The resulting rows
          		from <span class="InputCode">hh</span> are then placed next to <span class="InputCode">ind</span> to
          		create <span class="InputCode">x</span>.</p>
<h2>Matrix Functions</h2>
<p>Mata has a very large number of matrix functions built into it.
          		This section will hit some of the most useful.</p>
<h3>Creating Matrices</h3>
<p>The <span class="InputCode">I</span> function can take one or two arguments. If it is given one
          		argument, it will return an identity matrix of size equal to
          		the argument it was given. If it is given two arguments, it will
          		return a matrix with that number of rows and columns which is
          		full of zeroes except for ones along the principal diagonal.</p>
<p class="InputCode">I(3)<br/>
          	I(4,3)</p>
<p>The J function creates a matrix of constants. It takes three arguments:
          		the number of rows of the matrix to be created, the number of
          		columns, and what to put in the matrix. The last argument can
          		be of any type.</p>
<p class="InputCode">J(3,3,0)<br/>
          		J(2,3,"a")</p>
<p>The <span class="InputCode">e</span> function creates unit vectors:
          		row vectors with a one in one column and zeroes everywhere else.
          		It takes two arguments: the location of the one, and the size
          		of the row vector.</p>
<p class="InputCode">e(1,3)</p>
<p>Thus you could create an identity matrix by combining <span class="InputCode">e</span>'s,
          		though the <span class="InputCode">I</span> function would of course
          		be much easier.</p>
<p class="InputCode">e(1,3)\e(2,3)\e(3,3)</p>
<p>The <span class="InputCode">uniform</span> function returns a matrix
          		filled with random numbers distributed uniform(0,1). The size
          		is specified in the same way as with the J function.</p>
<p class="InputCode">uniform(5,5)</p>
<p>If you're putting together a  matrix which will be symmetric, the <span class="InputCode">makesymmetric</span>          		function
          		can take care of half the work for you. You put together the
          		lower triangle, and makesymmetric will copy it to the upper triangle
          		(replacing what was there before). It takes one argument, a matrix,
          		and returns the symmetric version.</p>
<p class="InputCode">x=(1,2)\(3,4)<br/>
          		y=makesymmetric(x)<br/>
          	y</p>
<p>There's a second version, _makesymmetric which returns nothing
          		but changes the input matrix instead:</p>
<p class="InputCode">_makesymmetric(x)<br/>
          	x</p>
<h3>Sorting</h3>
<p>The <span class="InputCode">sort</span> function returns a sorted
          		matrix. It takes two arguments: the matrix to sort, and the column(s)
          		to sort by.</p>
<p class="InputCode">x=(2,1)\(1,3)\(1,2)<br/>
          	sort(x,1)</p>
<p>Note that sort is not a "stable" sort. If there are any
          		ties, they will be resolved randomly. Repeat sort(x,1)
          		enough times and you should see some cases when the original
          		second row becomes the first row and others where it 
          		stays the second row. </p>
<p>If the second argument is a row vector, the matrix will be sorted
          		by the first column listed, then ties resolved by the second
          		column, etc. </p>
<p class="InputCode">sort(x,(1,2))</p>
<p><span class="InputCode">sort</span> does not change the matrix
          		it is given--it returns a copy. If you'd prefer to sort the original
          		matrix without making a copy, use <span class="InputCode">_sort</span>.</p>
<p class="InputCode">x<br/>
          	_sort(x,(1,2))<br/>
          	x</p>
<p><span class="InputCode">jumble</span> and <span class="InputCode">_jumble</span> are
          		the opposite of <span class="InputCode">sort</span> and <span class="InputCode">_sort</span>.
          		They take just one argument, a matrix, and put its rows in a random
          		order. </p>
<h3>Sizes of Matrices</h3>
<p><span class="InputCode">rows</span>, <span class="InputCode">cols</span>,
          		and <span class="InputCode">length</span> all take one argument,
          		a matrix. They return the number of rows, the number of columns,
          		and the total number of elements (rows*columns) in that matrix
          		respectively.</p>
<p class="InputCode">rows(x)<br/>
          	cols(x)<br/>
          	length(x)</p>
<p>These can be very useful in for loops where you want to loop over
          		your entire matrix but don't know ahead of time what size it
          		will be.</p>
<p>Of course matrices can have missing values just like ordinary Stata
          		data sets. If you need to know the number of missing values in
          		the whole matrix, a row, or a column, use <span class="InputCode">missing</span>, <span class="InputCode">rowmissing</span>          		or <span class="InputCode">colmissing</span> respectively.
          		<span class="InputCode">missing</span> returns a scalar, rowmissing
          		returns a column vector (one value for each row in the matrix),
          		and colmissing returns a row vector (one value for each column
          		in the matrix).</p>
<p class="InputCode">y=(1,2,.)\(4,.,6)\(7,8,.)<br/>
          	missing(y)<br/>
          	rowmissing (y)<br/>
          	colmissing(y) </p>
<p>To get the number of non-missing
          		values, using <span class="InputCode">nonmissing</span>, <span class="InputCode">rownonmissing</span>,
          		or <span class="InputCode">colnonmissing</span>.</p>
<h3>Descriptive Statistics</h3>
<p>Mata has a set of functions for calculating  descriptive
          		statistics, though by design it's not as rich as Stata's. In
          		their simplest and most commonly used forms, all these functions
          		take a single matrix as their argument.</p>
<p>Sums may be stretching the definition of "descriptive statistic"
          		but they are very useful. There are three main sum functions:
          		<span class="InputCode">sum</span>, <span class="InputCode">rowsum</span>,
          		and <span class="InputCode">colsum</span>. <span class="InputCode">sum</span> adds
          		up the whole matrix, returning a single number. <span class="InputCode">rowsum</span> adds
          		up each row, returning a column vector. <span class="InputCode">colsum</span> adds
          		up each column, returning a row vector.</p>
<p class="InputCode">sum(x)<br/>
          	rowsum(x)<br/>
          	colsum(x)</p>
<p><span class="InputCode">max</span> and <span class="InputCode">min</span> simply return the largest or smallest element of the
          		matrix.</p>
<p class="InputCode">max(x)<br/>
          	min(x)</p>
<p> <span class="InputCode">rowmax</span> and <span class="InputCode">rowmin</span> return a column vector containing the largest
          		or smallest element of each row. Likewise, colmax and colmin
          		return a row vector.</p>
<p class="InputCode">rowmax(x)<br/>
          	colmin(x)</p>
<p>You can get the largest and smallest elements with the <span class="InputCode">minmax</span> functions,
          		including <span class="InputCode">minmax</span>, <span class="InputCode">rowminmax</span>,
          		and <span class="InputCode">colminmax</span>. They return both
          		the min and the max in either two columns or, in the case of <span class="InputCode">colminmax</span>,
          		two rows.</p>
<p class="InputCode">minmax(x)<br/>
          	colminmax(x)</p>
<p>Sometimes you're more interested in <em>where</em> the min or max is than
          		<em>what</em> it is. If so, check out <span class="InputCode">minindex</span> and <span class="InputCode">maxindex</span>. </p>
<p>The <span class="InputCode">mean</span> function returns a row vector containing the column means
          		of the matrix.</p>
<p class="InputCode">mean(x)</p>
<p>If you need  row means, you'll need to construct them yourself:</p>
<p class="InputCode">rowsum(x)/cols(x)</p>
<p>You can also get the variance matrix of your matrix with variance,
          		and the correlation matrix with correlation.</p>
<p class="InputCode">variance(x)<br/>
          	correlation(x)</p>
<h3>Matrix Characteristics</h3>
<p>Mata has functions for finding the most common matrix  characteristics.</p>
<p><span class="InputCode">diagonal</span> returns the principal diagonal
          		of a matrix as a row vector.</p>
<p class="InputCode">x=(1,2)\(3,4)<br/>
          		diagonal(x) </p>
<p> <span class="InputCode">trace</span> returns the sum of the diagonal elements.</p>
<p class="InputCode">trace(x)</p>
<p><span class="InputCode">det</span> returns the determinant (with some round-off error).</p>
<p class="InputCode">det(x)</p>
<p><span class="InputCode">rank</span> returns the rank of the matrix.</p>
<p class="InputCode">rank(x)</p>
<p>As a general rule, using rank to check that a matrix is full rank
          		because a subsequent calculation requires it is redundant--better
          		to let the subsequent calculation fail and handle the failure.
          		Also, when determining the rank of a matrix on a	computer
          		a certain tolerance is required for round-off error. Different
          		functions can use different tolerances, so they may disagree
          		with the <span class="InputCode">rank</span> function. </p>
<h3>Solvers, Inverters and Decomposition </h3>
<p>Matrix solvers are functions designed to solve the equation AX=B
          		for  X. Since inverting a matrix A can be done by solving the
          		equation AX=I, inverters and solvers are closely related. In
          		addition, the solvers and inverters generally work by doing some
          		sort of decomposition, and the decomposition methods can also
          		be accessed directly. Thus there are several families of three
          		related functions. Which family you'll choose depends on the
          		properties of your matrix. We'll focus on Cholesky methods, but the
          		others work in a very similar way. </p>
<p>The Cholesky Decomposition decomposes a symmetric, positive definite
          		matrix into a lower triangular matrix times its transpose. The
          		results can be used to solve matrix equations and find inverses
          		much more quickly than more general methods. To get an example
          		matrix we can work with, we can take advantage of the fact that
          		if x is of full rank, x'x is symmetric and positive definite--and
          		random matrices are all but certain to be full rank. So:</p>
<p class="InputCode">a=uniform(5,5)<br/>
          	a=a'*a</p>
<p>The <span class="InputCode">cholesky</span> function takes one argument, a matrix, and returns
          		 a lower triangular matrix which is its Cholesky Decomposition.</p>
<p class="InputCode">cholesky(a) </p>
<p>To verify that it works, note that</p>
<p class="InputCode">cholesky(a)*cholesky(a)'</p>
<p>is the same as a.</p>
<p>To illustrate solving a matrix equation, we need a right-hand side.   </p>
<p class="InputCode">b=uniform(5,1)</p>
<p>The <span class="InputCode">cholsolve</span> function takes two
          		arguments, both matrices. It them sets up and solves the equation
          		AX=B where A is the first matrix and B is the second, returning
          		X.</p>
<p class="InputCode">cholsolve(a,b)</p>
<p>To verify that it worked, note that</p>
<p class="InputCode">a*cholsolve(a,b)</p>
<p>gives b. </p>
<p>The <span class="InputCode">cholinv</span> function takes one argument, a matrix, and returns
          		its inverse:</p>
<p class="InputCode">cholinv(a)</p>
<p>Again, to verify it worked try</p>
<p class="InputCode">a*cholinv(a)</p>
<p>The result should be an identity matrix.   You'll notice that round-off
          		error makes some of the zeroes not quite zeroes, but it's as
          		close as you can get using a computer.</p>
<p>If your matrix is square but not symmetric, LU Decomposition can
          		do similar things (though it's slower than Cholesky).
          		The <span class="InputCode">lud</span> function
          		is equivalent to <span class="InputCode">cholesky</span>,
          		but more complex because it has to give back three results. Thus
          		the matrices to store the results have to be passed in, similar
          		to <span class="InputCode">st_view</span>.</p>
<p>LU Decomposition breaks a matrix into a lower triangular matrix
          		L, an upper triangular matrix U, and a permutation matrix P.
          		But Mata, instead of using a matrix P, gives a column vector p which
          		can be used with subscripting to do the same thing.</p>
<p class="InputCode">a=uniform(5,5)<br/>
          	lud(a,L=0,U=0,p=0)</p>
<p>Take look at <span class="InputCode">L</span>,<span class="InputCode">U</span>, and <span class="InputCode">p</span>. To verify that it worked, see that</p>
<p class="InputCode">(L*U)[p,.]</p>
<p>is <span class="InputCode">a</span>. Note how we're using subscripts
          		to pull rows from a result, not an existing matrix, and yet it
          		works just fine.</p>
<p><span class="InputCode">lusolve</span> and <span class="InputCode">luinv</span> are
          		much simpler--in fact the usage is identical to <span class="InputCode">cholsolv</span> and <span class="InputCode">cholinv</span>.
          		Try</p>
<p class="InputCode">a*lusolve(a,b)<br/>
          	a*luinv(a)</p>
<p>Similar functions exist for QR decomposition (<span class="InputCode">qrd</span>, <span class="InputCode">qrsolve</span>, <span class="InputCode">qrinv</span>).
          		Singular value decomposition has <span class="InputCode">svd</span> and <span class="InputCode">svsolve</span>, but the related
          		inverter is <span class="InputCode">pinv</span> (which returns the Moore-Penrose pseudoinverse). </p>
<p><span class="InputCode">invsym</span>, for inverting symmetric
          		matrices, has no related decomposition or solver functions. It
          		is, however, what Stata suggests for linear regression. </p>
<h2>Example: Linear Regression</h2>
<p>You're now prepared to do the most common matrix manipulation of
          		all, at least at the SSCC.</p>
<p>Since we have the automobile data set loaded, let's regress price
          		on mpg, rep78, foreign and weight to see which characteristics
          		American consumers were willing to pay for in 1978.</p>
<p>One complication is that rep78 is missing for some observations,
          		so you'll need to drop them from your regression. Of course you
          		could just drop them from the data set entirely, but let's assume
          		that you want to keep them for later use.</p>
<p>The first step is to mark the observations you can actually use.
          		Exit Mata by typing <span class="InputCode">end</span>, then create a new variable touse which
          		is one if all the variables are non-missing and zero otherwise.</p>
<p class="InputCode">gen touse=(price!=. &amp; mpg!=. &amp; rep78!=. &amp; weight!=. &amp; foreign!=.)</p>
<p>Of course in reality the only variable that is ever missing is
          		<span class="InputCode">rep78</span>, but we'll pretend we didn't
          		know that ahead of time. If you wanted to run a regression on
          		a subpopulation (say, just the foreign cars) you could add a
          		condition to mark the subsample too. </p>
<p>Now go back into Mata by typing <span class="InputCode">mata</span>.
          		Next make x a view onto all the independant variables and y a
          		view onto the dependant variable. <span class="InputCode">touse</span> is
          		the selection variable for both views: observations will only
          		be included if it is equal to one. </p>
<p class="InputCode">								st_view(x=0,.,("mpg","rep78","weight","foreign"), "touse")<br/>
								st_view(y=0,.,("price"), "touse")</p>
<p>To include a constant term in the regression you need to add a
          		column of ones to x. Use the J function to create it, then add
          		it to x with the comma (column join) operator. </p>
<p class="InputCode">x=x,J(rows(x),1,1)</p>
<p>Now you can find the betas:</p>
<p class="InputCode">b=invsym(x'*x)*x'*y</p>
<p>Of course they don't mean anything without standard errors. Start
          		by finding the residuals:</p>
<p class="InputCode">e=y-x*b</p>
<p>Then the variance-covariance matrix is</p>
<p class="InputCode">v=(e'*e)/(rows(x)-cols(x))*invsym(x'*x)</p>
<p>The standard errors for each beta can be extracted using the <span class="InputCode">diagonal</span>          		function, along with <span class="InputCode">sqrt</span>, which takes the (element by element)
          		square root.</p>
<p class="InputCode">se=sqrt(diagonal(v))</p>
<p>The t-statistic is the beta divided by the standard error, but
          		this is an element by element division so you need to use the
          		colon operator.</p>
<p class="InputCode">t=b:/se</p>
<p>To find the p-values requires the <span class="InputCode">ttail</span> function,
          		which takes as arguments the degrees of freedom and the t-statistic
          		and returns the probability. It is a single-tailed test however,
          		so you need to multiply by two.</p>
<p class="InputCode">p=2*ttail(rows(x)-cols(x),abs(t))</p>
<p>To put your results together in a readable form, try:</p>
<p class="InputCode">b,se,t,p</p>
<p>Now exit Mata again, and check your results against</p>
<p class="InputCode">reg price mpg rep78 weight foreign</p>
<p>They should be identical.</p>
<h2>If</h2>
<p>In regular Stata, <span class="InputCode">if</span> is almost always used to define
          		which observations a command should act on. It's the equivalent
          		to SQL's <span class="InputCode">where</span> clause. In Mata, <span class="InputCode">if</span> is only used to control program
          		flow. (Though Stata can use <span class="InputCode">if</span> in this way as well—see the
          		appropriate section of <a href="https://www.ssc.wisc.edu/sscc/pubs/stata_prog2.htm">Stata Programming
          		Tools</a>.)</p>
<p>The most basic form of <span class="InputCode">if</span> is simply</p>
<p class="InputCode">if (<span class="Parameter">condition</span>) <span class="Parameter">statement</span></p>
<p>If <span class="Parameter"><span class="InputCode">condition</span></span> is
          		true, then <span class="Parameter"><span class="InputCode">statement</span></span> is
          		executed. Otherwise it is skipped entirely. Note that the condition
          		must be in parentheses.</p>
<p>If you want to do more than one thing if the condition is true,
          		use the following syntax:</p>
<p class="InputCode">if (<span class="Parameter">condition</span>)<br/> 
          		{<br/>
<span class="indent3"><span class="Parameter">statements</span></span><br/>
          	}</p>
<p>You can also use <span class="InputCode">else</span> to specify things that should happen if the
          		condition is not true. Thus you can create fairly elaborate structures:</p>
<p class="InputCode">if (<span class="Parameter">condition1</span>)<br/> 
          		{<br/>
<span class="indent3"><span class="Parameter">statements1</span></span><br/>
          		}<br/>
          		else if (<span class="Parameter">condition2</span>)<br/> 
          		{<br/>
<span class="indent3"><span class="Parameter">statements2</span></span><br/>
          		}<br/>
          		else<br/> 
          		{<br/>
<span class="indent3"><span class="Parameter">statements3</span></span><br/>
          		}</p>
<p>Keep in mind that each condition has a single result, either true
          		or false. For example, If x is a matrix you can't write <span class="InputCode">if
          		(x&gt;5)</span>          		and then list things you want done
          		for those elements of x which are greater than 5. You can write
          		<span class="InputCode">if (x[1,1]&gt;5)</span> followed by <span class="InputCode">if
          		(x[1,2]&gt;5)</span> etc. but of course the easy way to do that is
          		using a loop. </p>
<h2>Loops</h2>
<p>Mata has <span class="InputCode">while</span>, <span class="InputCode">do</span>-<span class="InputCode">while</span>,
          		and <span class="InputCode">for</span> loops available (plus <span class="InputCode">goto</span> for
          		easier conversion of FORTRAN code, but we don't want to endorse
          		spaghetti logic).</p>
<h3>While</h3>
<p>while looks very similar to if:</p>
<p class="InputCode">while (<span class="Parameter">condition</span>)<br/> 
          		{<br/>
<span class="indent3"><span class="Parameter">statements</span></span><br/>
          		}</p>
<p>The difference is that the statements will be executed over and
          		over as long as the condition is true. Thus your first concern
          		should be to make sure that at some point the condition will
          		become false, or the loop will run forever.</p>
<p class="InputCode">x=0<br/>
								while (x&lt;=5)<br/>
								{<br/>
<span class="indent3">x</span><br/>
<span class="indent3">x++</span><br/>
				}</p>
<p>Note that <span class="InputCode">x++</span> is shorthand for <span class="InputCode">x=x+1</span>. </p>
<p>Even though we said x&lt;=5, the final value of x is six.
          		That's because the loop only decides to end  when x becomes
          		six.</p>
<p>You can also put a while loop with a single statement in a single
          		line.</p>
<p class="InputCode">while (x&lt;=5) x++<br/>
          	x</p>
<p>This loop is perfectly legal, but it didn't do anything. The reason
          		is that the condition started out false, so the loop never executed
          		at all. Sometimes you need to make sure that a loop runs at least
          		once, and that's a job for do-while.</p>
<h3>Do-While</h3>
<p>A do-while loop starts with do and ends with the while condition.
          		The statements are always executed at least once. If the condition
          		is true, the loop starts over again from the top.</p>
<p class="InputCode">do<br/>
								 {<br/>
<span class="indent3">x++</span><br/>
								 }
								 while (x&lt;=5)<br/>
          	x</p>
<p>Note that x is increased to seven even though it started out greater
          		than five.</p>
<p>One typical use for do-while loops is to do something until it
          		converges:</p>
<p class="InputCode">do<br/> 
          		{<br/>
<span class="Parameter"><span class="indent3">complex mathematical stuff</span></span><br/>
          		} while (abs(newvalue-oldvalue)&gt;tolerance)</p>
<p>But unless you're absolutely certain your process will actually
          		converge, you'd better put in an escape clause that tells it
          		to stop after a while whether it converges or not:</p>
<p class="InputCode">do<br/> 
          		{<br/>
<span class="Parameter"><span class="indent3">complex mathematical stuff</span></span><br/>
          		} while (abs(newValue-oldValue)&gt;tolerance &amp; iteration&lt;maxIterations)</p>
<h3>For</h3>
<p>Recall our first while loop: </p>
<p class="InputCode">x=0<br/>
          		while (x&lt;=5)<br/> 
          			{<br/>
<span class="indent3">x</span><br/>
<span class="indent3">x++</span><br/>
          		}</p>
<p>This is such a common structure that programmers wanted a quicker
          		way to construct it. The answer was for loops. The for loop equivalent
          		to this while loop is</p>
<p class="InputCode">for (x=0;  x&lt;=5; x++)<br/> 
          		{<br/>
<span class="indent3">x</span><br/>
          		}          	</p>
<p>Note the three components: an initialization step, a rule for when
          		the loop should end, and some sort of progression towards that
          		ending. Strictly speaking you can skip the initialization and
          		the progression--just leave the semi-colons as placeholders.</p>
<p class="InputCode">for(; x&lt;=10;) {<br/>
<span class="indent3">x</span><br/>
<span class="indent3">x++</span><br/>
          		}</p>
<p>All this really means though is that you're promising to take
          		care of those steps yourself. In particular x must already be
          		defined and you need to make sure the loop will in fact end.</p>
<p>By far the most common use of for loops is to loop over the elements
          		of a matrix.</p>
<p class="InputCode">m=J(5,5,0)<br/>
          	for(i=1; i&lt;=rows(m); i++) {<br/>
<span class="indent3">for(j=1; j&lt;=cols(m); j++) {</span><br/>
<span class="indent3"><span class="indent3">m[i,j]=i+(j-1)*cols(m)</span></span><br/>
<span class="indent3">}</span><br/>
          		}
				<br/>
          	m</p>
<h2>Writing Your Own Functions</h2>
<p>Mata allows you to write your own functions--in fact many of the
          		standard functions we've used are written in Mata. As you've
          		seen, calling a function is a matter of typing the function name
          		and then giving a list of arguments in parentheses. Defining a function
          		follows the same structure: first the word <span class="InputCode">function</span> to
          		tell Mata what you're doing, then a name, and then a list of arguments
          		in parentheses. The body of the function follows in curly brackets.
          		If you want your function to return a result, one of the statements
          		in the body needs to be <span class="InputCode">return</span>, followed
          		by the thing to return in parentheses. </p>
<p class="InputCode">function myfunction(x,y)<br/> 
          		{<br/>
<span class="indent3"><span class="Parameter">statements</span></span><br/>
<span class="indent3">return(z)</span><br/>
          		}</p>
<p>As an example, consider the following (not terribly useful) function. </p>
<p class="InputCode">function doubleAndSum(x)<br/> 
          		{<br/>
<span class="indent3">x=x*2</span><br/>
<span class="indent3">return(sum(x))</span><br/>
          		}</p>
<p>This function takes a matrix, multiplies it by the scalar two,
          		and returns the sum of all the elements in the matrix. To test
          		it, try the following:</p>
<p><span class="InputCode">m=I(3)<br/>
          		doubleAndSum(m)<br/>
       			m</span></p>
<p>Note that you passed in a matrix called m even though the function
          		calls it x. That's fine: the doubleAndSum function refers to
          		whatever it is given as x. In fact the input doesn't even have
          		to have a name.</p>
<p class="InputCode">doubleAndSum(I(3))<br/>
          		doubleAndSum(1..3)</p>
<p>In the first case, the argument passed in is the result of the
          		I function. In the second, it is a row vector defined on the
          		spot. On the other hand, in these cases we can't see how the
          		input matrix was doubled as they aren't stored anywhere.</p>
<p>Function arguments in Mata are "passed by reference." If a function
          		changes one of the arguments it is given, that change persists
          		even after the function is completed. </p>
<h2>Example: Loops and Functions  </h2>
<p>Our next example comes from basic physics, but the real point is
          		using loops and functions to get useful results. The classic
          		equation for the motion of a body under uniform acceleration
          		is simply</p>
<p>x(t)=x0+v0*t+1/2*a*t^2</p>
<p>Depending on the level of mathematics used in your last physics
          		course, you may or may not have worked with that as a vector
          		equation, where x,x0,v0 and a are vectors with one number for
          		each dimension. The vector component makes this a good problem
          		for Mata. Let's track and plot the movement of a falling object
          		for ten seconds. </p>
<p>Begin by defining a function x which takes x0,v0,a and t as arguments
          		and returns the position of the body at time t.</p>
<p class="InputCode">function x(x0,v0,a,t)<br/> 
          		{<br/>
<span class="indent3">x=x0+v0*t+1/2*a*t^2</span><br/>
<span class="indent3">return(x)</span><br/>
          		}</p>
<p>This is a good point to pause and test what we've done so far before
          		moving on. Try:</p>
<p class="InputCode">x0=0,0,0<br/>
          		v0=10,0,0<br/>
          		a=0,0,0</p>
<p>This represents a body just moving at 10 meters/second (not that
          		Mata cares about the units) in the positive x direction, so it
          		will be easy to tell if your function works properly or not.</p>
<p class="InputCode">x(x0,v0,a,10)</p>
<p>should give 100,0,0. </p>
<p>But that doesn't guarantee our acceleration term is right, so try</p>
<p class="InputCode">v0=0,0,0<br/>
          		a=0,0,1<br/>
          		x(x0,v0,a,10)</p>
<p>This should give 0,0,50.</p>
<p>Now we'll set up the actual values we want to examine:</p>
<p class="InputCode">x0=0,500<br/>
          		v0=100,0<br/>
          	a=0,-9.8</p>
<p>This is an object starting 500 meters up, moving to the right at
          		100 meters per second, and falling under normal earth gravity
          		(about 9.8 meters per second squared). Note how we suddenly switched
          		from three dimensions to two. Your function won't care in the
          		slightest since they're all still matrices, but it's a lot easier
          		to plot on a two dimensional graph.</p>
<p>Now you need somewhere to put the results. Mata doesn't do graphs,
          		so you'll have to use Stata to plot them. But first we have to
          		think about what the results will be. Your function provides
          		a snapshot of the object at any given time, so we'll take a thousand
          		snapshots spread across the ten second span. Each snapshot will
          		have two numbers, an x coordinate and a y coordinate, so those
          		will be your variables (though to Mata they're just column one
          		and column two of the x row vector).</p>
<p>Get out of Mata, then use standard Stata commands to set up the
          		observations and variables you'll need.</p>
<p class="InputCode">end<br/>
          		clear<br/>
          			set obs 1000<br/>
          			gen x=.<br/>
          			gen y=.<br/>
</p>
<p>Now get back into Mata, and set up a view of these variables. Call
          		it r (as in results): </p>
<p class="InputCode">mata<br/>
          	st_view(r=0,.,.)</p>
<p>Now you're ready to loop over your 1000 snapshots and get the results
          		of the x function for each one:</p>
<p class="InputCode">for(i=1; i&lt;=1000; i++) {<br/>
<span class="indent3">r[i,.]=x(x0,v0,a,i/100)</span><br/>
          		}</p>
<p>Note how the time for each snapshot, i/100, spreads them evenly
          		across 10 seconds as i goes from 1 to 1000.</p>
<p>Finally exit Mata again, and create the graph.</p>
<p class="InputCode">end<br/>
          	scatter y x</p>
<p>It's the classic parabola of projectile motion as you no doubt
          		expected, but of course the real point was to practice using
          		functions and loops to generate and work with data.</p>
<p>As soon as we defined the x() function, Mata compiled it into "object
          		code." This is not quite the same as machine-language code that
          		can be run all by itself. But it is something Mata can understand
          		and run very quickly. If you were planning to use this function
          		in the future you could save the object code. Then future programs
          		wouldn't need to spend time compiling it. If this is something
          		you're interested in, see the <span class="InputCode">mlib</span> and <span class="InputCode">mata
          		mosave</span> commands.</p>
<p>This example is contained in <a href="https://ssc.wisc.edu/sscc/pubs/files/4-26/ex1.do">ex1.do</a>. </p>
<h2>Pointers</h2>
<p>A pointer is a variable which contains the memory address of another
          		variable or matrix. Thus it "points" to that other variable.
          		In principle a pointer is just a number, but you'll 
          		never work with the number directly. Instead, you'll use two
          		operators, <span class="InputCode">&amp;</span> and <span class="InputCode">*</span>.
          		Computer scientists call these the "reference" and "dereference"
          		operators, but I like to think of them as "the address of"
          		and "the thing at." </p>
<p>Consider the following:</p>
<p class="InputCode">x=(1..3)\(4..6)\(7..9)<br/>
          		p=&amp;x<br/>
          		*p<br/>
          		(*p)[2,2]</p>
<p>First we define a matrix <span class="InputCode">x</span> so we
          		have something to work with. Then
          		<span class="InputCode">p</span> is defined as "the address
          		of <span class="InputCode">x</span>."  Thus
          		<span class="InputCode">*p</span> or "the thing at <span class="InputCode">p</span>"
          		is just another name for <span class="InputCode">x</span>.
          		You can use subscripts with
          		<span class="InputCode">*p</span> just like you would with <span class="InputCode">x</span>,
          		but note how you have to put <span class="InputCode">*p</span> in
          		parenthesis first. <span class="InputCode">(*p)[2,2]</span>          		means
          		"find the thing at the address contained in <span class="InputCode">p</span> and
          		get the value at row two, column two. " <span class="InputCode">*p[2,2]</span> would
          		mean "get the value at row two, column two of <span class="InputCode">p</span>,
          		and then find the thing at that address" which won't work because <span class="InputCode">p</span> is
          		a scalar.</p>
<p>Note that the matrix you are pointing to doesn't need to have a
          		name. For example:</p>
<p class="InputCode">p=&amp;J(5,5,0)</p>
<p>makes <span class="InputCode">p</span> point to a 5x5 matrix of
          		zeroes (since that's what <span class="InputCode">J</span> returns)
          		even though there's no direct name for that matrix. It's only
          		accessible as <span class="InputCode">*p</span>. </p>
<p>One use for pointers is to construct data structures Mata doesn't
          		handle automatically. For example, you can construct a three
          		dimensional matrix by making a two dimensional matrix of pointers,
          		each of which points to a column vector.</p>
<p>The first step is to define the matrix that will contain the pointers.
          		Matrices can't switch between containing numbers and containing
          		pointers, so you need to make sure that the matrix is defined
          		as containing pointers. On the other hand, we don't have any
          		actual pointers to store yet. Thus we'll set the initial values
          		of the matrix to <span class="InputCode">NULL</span>, a special pointer that doesn't point to
          		anything.</p>
<p class="InputCode">          		x=J(5,5,NULL)</p>
<p>Now loop over all the elements of x, and make each one a pointer
          		to a new (and unique) column vector. </p>
<p class="InputCode">for (i=1; i&lt;=rows(x); i++)<br/> 
          		{<br/>
<span class="indent3">for (j=1; j&lt;=cols(x); j++)</span><br/>
<span class="indent3">{</span><br/>
<span class="indent3"><span class="indent3">x[i,j]=&amp;J(5,1,0)</span></span><br/>
<span class="indent3">}</span><br/>
          		}</p>
<p>To work with an element i,j,k of your three dimensional matrix
          		you'd use the following:</p>
<p class="InputCode">(*(x[i,j]))[k]</p>
<p>Yes, the parentheses are essential. It's rather awkward though,
          		so if you were going to work with such matrices a lot consider
          		defining the following functions:</p>
<p class="InputCode">function put(val,x,i,j,k)<br/> 
          		{<br/>
<span class="indent3">/* Usage: value to put, matrix to put it in,
          					i, j, k to put it at. */</span><br/>
<span class="indent3">(*(x[i,j]))[k,1]=val</span><br/>
          		}</p>
<p class="InputCode">function get(x,i,j,k)<br/> 
          		{<br/>
<span class="indent3">/* Usage: matrix to get from, i, j, k of value
          			to get. */ </span><br/>
<span class="indent3">return((*(x[i,j]))[k,1])</span><br/>
          		}</p>
<p>Then you can do things like:</p>
<p class="InputCode">put(3,x,5,5,5)<br/>
          		get(x,5,5,5) </p>
<p>The fact that you can't mix pointers and regular data within a
          		matrix does limit your flexibility. You can't, for example, have
          		a matrix of individual data including pointers to other data
          		relevant to the individual. You can, however, have two parallel
          		matrices, one containing numbers and the other containing
          		pointers. If row i represents the same individual in both matrices,
          		you can pull information from either or both as needed. </p>
<p>It's also possible to create a pointer to a function. Given your
          		existing function doubleAndSum() try:</p>
<p class="InputCode">p=&amp;doubleAndSum()<br/>
          		(*p)(I(3))</p>
<p>Note how Mata distinguishes between <span class="InputCode">x()</span> the
          		function and <span class="InputCode">x</span> the
          		variable by the parentheses, even though you're not passing in
          		any arguments when you define a pointer.</p>
<p>The main reason you'd want to create a pointer to a function is
          		so that you can use that pointer as the argument of a function.
          		For example, Mata's optimizer functions have you pass in a pointer
          		to the function which is to be optimized. </p>
<h2>The Mata Optimizer</h2>
<p>Many statistical operations involve maximizing or minimizing some
          		quantity--maximum likelihood estimation being the obvious example.
          		Mata includes an optimizer for these operations. Mata's optimizer
          		is actually a family of functions which define and then solve
          		an optimization problem.</p>
<h3>Evaluator functions </h3>
<p>The first function must be written by you: the function to
          		be maximized or minimized. This function can do whatever you
          		want, it may be very complex or very simple, but it must accept
          		a certain set of arguments and return the proper result in order
          		for the optimizer to use it. You can name the arguments whatever
          		you like, but there must be the right number and each must have
          		the proper meaning. </p>
<p>Optimization problems are described using a variety of notations,
          		but if we consider the problem of maximizing
          		y=f(x), the Mata version of f() must take the following arguments:</p>
<ul>
<li>a number indicating whether the function is supposed to calculate
          			(0) just f(x), (1) y=f(x) and f'(x) or (2) f(x), f'(x) and
          			f''(x) </li>
<li>x (the thing that changes as the optimizer looks for the max) </li>
<li>y (where f(x) will be stored) </li>
<li>A variable to store f'(x) if calculated</li>
<li>A variable to store f''(x)  if calculated (often H since it is
          			the hessian in multivariate problems) </li>
</ul>
<p>If you can find an analytic solution for f'(x) and f''(x) and code
          		them in, Mata's optimizer will be much faster and more accurate.
          		This is often impractical though, and Mata is perfectly willing
          		to find numeric approximations to the derivatives it needs. Note,
          		however, that even if your function never calculates derivatives
          		it must still accept variables where they can be stored.</p>
<p>So let's try a very simple function: y=-x^4. If you're willing
          		to let Mata find all the derivatives for you, you can code this
          		as the following:</p>
<p class="InputCode">function f(todo,x,y,g,H)<br/>
          		{<br/>
<span class="indent3">y=-x^4</span><br/>
} </p>
<p>Note that <span class="InputCode">todo</span> (the number telling
          		the function whether to calculate derivatives or not), <span class="InputCode">g</span>,
          		and <span class="InputCode">H</span> are completely unused, but must
          		still be accepted. Note also that we could change all the names.
          		We could call <span class="InputCode">x</span> Fred and <span class="InputCode">y</span> George
          		as long as George=f(Fred).</p>
<p>If we're not quite so lazy we can also code the derivatives for
          		this function quite easily:</p>
<p class="InputCode">function g(todo,x,y,g,H)<br/>
          		{<br/>
<span class="indent3">y=-x^4</span><br/>
<span class="indent3">if (todo&gt;=1)</span><br/>
<span class="indent3">{</span><br/>
<span class="indent3"><span class="indent3">g=-4*x^3</span></span><br/>
<span class="indent3"><span class="indent3">if (todo==2)</span></span><br/>
<span class="indent3"><span class="indent3">{</span></span><br/>
<span class="indent3"><span class="indent3"><span class="indent3">H=-12*x^2</span></span></span><br/>
<span class="indent3"><span class="indent3">}</span></span><br/>
<span class="indent3">}</span><br/>
}</p>
<p>In this case, both x and y were scalars, but you're not limited
          		to scalars. Consider y=-x1^4 - x2^4</p>
<p class="InputCode">function h(todo,x,y,g,H)<br/>
          		{<br/>
<span class="indent3">y=-x[1]^4-x[2]^4</span><br/>
          		}</p>
<p>The two x's are stored in a row vector x, so x1 is x[1] and x2
          		is x[2]. Making sure the optimizer sends in the right size of
          		x is one of the steps in setting it up. </p>
<p>In many cases the quantity you'll want to maximize will be the
          		sum of a column. For example, in maximum likelihood you will
          		probably create a column where each row gives an observation's
          		contribution to the likelihood function. Mata's optimizer will
          		do this automatically with the proper settings, so the previous
          		function could be recast as:</p>
<p class="InputCode">function i(todo,x,y,g,H)<br/>
          		{<br/>
<span class="indent3">y=J(2,1,.) </span><br/>
<span class="indent3">y[1]=-x[1]^4</span><br/>
<span class="indent3">y[2]=-x[2]^4 </span><br/>
} </p>
<p>Note how the function had to define y as a column vector of the
          		proper size--otherwise it is a scalar. </p>
<p>In statistical applications the quantity to be maximized will depend
          		not just on  parameters that can vary (x in our problems thus
          		far) but on  data that do not vary. Mata's optimizer can
          		be set up to pass up to nine additional arguments to your evaluator
          		function, which can contain the data. They go after the first
          		two arguments (and before the final three).</p>
<p>This calls for a change of variable names. Consider maximizing
          		s=f(b). We'll now use x for  the data matrix. Then
          		the function definition would be: </p>
<p class="InputCode">function f(todo, b, x, s, g, H) </p>
<p>x can contain both the independent and dependant variables, but
          		if it's easier to work with a separate matrix y, then the definition
          		becomes:</p>
<p class="InputCode">function f(todo, b, x, y, s, g, H) </p>
<p>We'll do an example using this kind of evaluator shortly.</p>
<h3>Setting Up and Running an Optimization Problem</h3>
<p>Once you've got your evaluator function defined, you're ready to
          		set up the optimization problem. The first step is to call the
          		<span class="InputCode">optimize_init</span> function. <span class="InputCode">optimize_init</span> takes
          		no arguments and returns a variable containing a description
          		of your optimization problem. You'll never look at this description,
          		but you will pass it in to all the other optimization functions.</p>
<p class="InputCode">s=optimize_init()</p>
<p>Next tell it where to find the evaluator:</p>
<p class="InputCode">optimize_init_evaluator(s,&amp;f())</p>
<p>The first argument is the problem description, and the second is
          		a pointer to the evaluator function you already defined.</p>
<p>Now give it a starting value for x--remember the f() function
          		is in the form y=f(x).</p>
<p class="InputCode">optimize_init_params(s,-100)</p>
<p>Of course the correct answer is zero, but we want it to do some
          		work! </p>
<p>Now you're ready to actually run the optimizer:</p>
<p class="InputCode">optimize(s)</p>
<p>This returns the value of x which maximizes f(x). You may want
          		to store this in a variable:</p>
<p class="InputCode">xmax=optimize(s)</p>
<p>If we want to use the g(x) function instead, there's one additional
          		step. Recall that in g(x) we coded the first and second derivatives
          		ourselves so Mata doesn't have to approximate them. Mata refers
          		to this as a "d2" evaluator. A "d1" evaluator codes just the
          		first derivative, and a "d0" evaluator codes no derivatives at
          		all (the f(x) function is a d0 evaluator). Mata will assume functions
          		are d0 unless we say otherwise, so you need to add:</p>
<p class="InputCode">optimize_init_evaluatortype(s,"d2")</p>
<p>Note that the optimizer doesn't care what order all the initialization
          		functions are called in, as long as they're before the actual
          		<span class="InputCode">optimize()</span>. </p>
<p>What about h(x1, x2)? It's identical to f(x), except that we need
          		to set an initial value for both variables:</p>
<p class="InputCode">optimize_init_params(s,(-100,100)) </p>
<p>In doing so we also tell Mata that future x's must have two columns. </p>
<p>Finally,
          		i(x1,x2), where the function to be maximized is the column sum
          		of y, is what Mata calls a "v0" evaluator.
          		The "v" is
          		for vector, and the "0" again means that we didn't code
          		any derivatives. Thus we need </p>
<p class="InputCode">optimize_init_evaluatortype(s,"v0")</p>
<p>To see the complete code to run the optimizer with each evaluator,
          		see the the last parts of <a href="https://ssc.wisc.edu/sscc/pubs/files/4-26/mataclass.do">mataclass.do</a>. There is one setup function
          		we haven't needed to call but you should know:</p>
<p class="InputCode">optimize_init_which(s,"min")</p>
<p>changes the problem from maximizing the function (the default)
          		to minimizing it. </p>
<h2>Example: Ranking Teams</h2>
<p>As a final, extended example, consider a problem familiar to any
          		sports fan: determining how good a team is based on its won/loss
          		record.</p>
<p>We'll assume that a team can be characterized by a single "strength"
          		variable s. If team i plays team j, we'll assume that the probability
          		of team i winning is given by exp(si-sj)/(1+exp(si-sj)), better
          		known to Stata as  <span class="InputCode">invlogit(si-sj)</span>.
          		Then, given a record of games played and who won, we can find
          		a set of values for s that maximizes the probability of the given
          		outcome. We'll do a Monte Carlo study by first creating data
          		which fits our assumptions, and then seeing how well the method works.</p>
<h3>Creating the Data </h3>
<p>The first step is to create the data. This is an exercise in matrix
          		manipulation, so if you want to focus on the optimization part
          		of the problem feel free to skip ahead. On the other hand, most
          		readers will benefit from some practice in this area.</p>
<p>First create a row vector <span class="InputCode">str</span> containing
          		the real strengths of each team. For simplicity, use the uniform
          		function, giving strengths distributed uniform(0,1). For our
          		example we'll make 50 teams: </p>
<p class="InputCode">str=uniform(1,50)</p>
<p>Note that the column number within the <span class="InputCode">str</span> vector acts as a sort
          		of team ID. </p>
<p>Next we need a way to keep track of who played who. We'll create
          		a two-column matrix, where each row is a game and the two columns
          		will contain the IDs of the two teams who played in that game.
          		For brevity we'll call the team in column one the "home" team
          		and the team in column two the "visiting" team. We'll assume
          		that each team plays 20 games, 10 as the home team and 10 as
          		the visiting team.</p>
<p>Begin by creating a column vector <span class="InputCode">teams</span> containing
          		the 50 teams using the range operator:</p>
<p>teams=1::50</p>
<p>Now create a column vector <span class="InputCode">season</span> which is just ten copies of <span class="InputCode">teams</span>          		stacked on top of each other: </p>
<p class="InputCode">season=teams<br/>
          		for(i=1;i&lt;10;i++)<br/>
          		{<br/>
<span class="indent3">season=season\teams</span><br/>
          		}</p>
<p>This represents the home teams. Next assign the visiting teams
          		by taking the same vector, putting it in a random order, and
          		column joining it to the original:</p>
<p class="InputCode">season=season,jumble(season) </p>
<p>The only trouble is, it's entirely possible for a team to be randomly
          		assigned to play itself. This wouldn't really bother our
          		estimator, but it does offend any claims that this represents
          		the real world. More importantly, fixing it is good practice.</p>
<p>Create a column vector <span class="InputCode">same</span> with
          		the same number of rows as <span class="InputCode">season</span>          		which
          		contains a 1 if the home and visiting teams are the same and
          		a 0 if they are not:</p>
<p class="InputCode">same=(season[.,1]:==season[.,2])</p>
<p>If a game has the a team playing itself, we will swap the visiting
          		team with the visiting team of a randomly chosen game. Since
          		it's possible we might get the same team yet again, we'll keep
          		checking and swapping until there are no more games between the
          		same team. Here's the code:</p>
<p class="InputCode">while (max(same)==1)<br/>
          		{<br/>
<span class="indent3">for(i=1; i&lt;=rows(season); i++)</span><br/>
<span class="indent3">{</span><br/>
<span class="indent3"><span class="indent3">if (same[i])</span></span><br/>
<span class="indent3"><span class="indent3">{</span></span><br/>
<span class="indent3"><span class="indent3"><span class="indent3">swap=trunc(uniform(1,1)*rows(season))+1</span></span></span><br/>
<span class="indent3"><span class="indent3"><span class="indent3">temp=season[swap,2]</span></span></span><br/>
<span class="indent3"><span class="indent3"><span class="indent3">season[swap,2]=season[i,2]</span></span></span><br/>
<span class="indent3"><span class="indent3"><span class="indent3">season[i,2]=temp</span></span></span><br/>
<span class="indent3"><span class="indent3">}</span></span><br/>
<span class="indent3">}</span><br/>
<span class="indent3">same=(season[.,1]:==season[.,2])</span><br/>
}</p>
<p>Note how <span class="InputCode">max(same)</span> will be zero
          		if there are no longer any games where the home and visiting
          		teams are the same, so that's how we know when we're done.</p>
<p>We then loop over the rows, stopping to change those where <span class="InputCode">same[i]</span>          		is
          		one (or true). In those cases, we pick a random row and swap
          		visiting teams with it, using a temp variable to store its visiting
          		team's ID as we do. We then recalculate <span class="InputCode">same</span> based
          		on the new version of
          		<span class="InputCode">season</span> before the while condition
          		is reevaluated.</p>
<p>Now we need to decide who won each game. We'll create a column
          		vector winner, which will contain a 1 if the home team won and
          		a zero if the visiting team won. </p>
<p class="InputCode">winner=J(rows(season),1,.)<br/>
          		for(i=1; i&lt;=rows(season); i++)<br/>
          		{<br/>
<span class="indent3">winner[i]=uniform(1,1):&lt;invlogit(str[season[i,1]]-str[season[i,2]])</span><br/>
}</p>
<p>Note how indexing is used to pull up the strength (<span class="InputCode">str</span>) of the
          		appropriate team--we'll be doing that a lot.</p>
<h3>The Maximum Likelihood Estimator </h3>
<p>Now we're ready to construct the (log) likelihood function to be
          		maximized. We'll start with a version that's easy to understand,
          		and try to make it efficient later.</p>
<p class="InputCode">function llf(todo,strhat,season,winner,llf,g,H)<br/>
          		{<br/>
<span class="indent3">llf=J(rows(season),1,.)</span><br/>
<span class="indent3">for(i=1;i&lt;=rows(season);i++)</span><br/>
<span class="indent3">{</span><br/>
<span class="indent3"><span class="indent3">if (winner[i]) llf[i]=log(invlogit(strhat[season[i,1]]-strhat[season[i,2]]))</span></span><br/>
<span class="indent3"><span class="indent3">else llf[i]=log(invlogit(strhat[season[i,2]]-strhat[season[i,1]]))</span></span><br/>
<span class="indent3">}</span><br/>
}</p>
<p>This will be a v0 evaluator which takes <span class="InputCode">season</span> and <span class="InputCode">winner</span> as
          		additional arguments. The estimated strengths are stored in strhat,
          		and the column of log likelihoods (which will be summed automatically
          		by virtue of being v0) is stored in <span class="InputCode">llf</span>.</p>
<p>We have two possible outcomes, and the formula for finding the
          		log likelihood is different in each outcome. For now we'll handle
          		the two possibilities with an if/else structure, but there are
          		more efficient ways.</p>
<p>Now to set up the optimization problem:</p>
<p class="InputCode">s=optimize_init()<br/>
          		optimize_init_evaluator(s, &amp;llf())<br/>
          		optimize_init_evaluatortype(s,"v0")<br/>
          		strhat0=J(1,rows(teams),.5)<br/>
          		optimize_init_params(s,strhat0)<br/>
          		optimize_init_argument(s,1,season)<br/>
          		optimize_init_argument(s,2,winner)<br/>
          		strhat1=optimize(s)</p>
<p>Most of these you've seen before.  Note that <span class="InputCode">strhat0</span> is
          		the vector of starting values for our estimate of <span class="InputCode">str</span>.
          		Since the actual strengths are distributed uniform(0,1) we'll
          		start by setting them all to 0.5.</p>
<p>What is new is <span class="InputCode">optimize_init_arguments</span>.
          		This is where you tell the optimizer to pass in <span class="InputCode">season</span> and <span class="InputCode">winner</span> to
          		your evaluator. As you see <span class="InputCode">optimize_init_arguments</span> takes
          		three arguments: the optimization problem, the number of the
          		argument you're setting, and what to pass in.</p>
<p>Run the code. It will take a while  but it should work.</p>
<h3>Efficiency</h3>
<p>So how can we make it faster? It would be nice if we didn't have
          		to figure out which formula to use for the likelihood. So let's
          		rearrange the data a bit: instead of column one being the "home"
          		team and column two the "visiting" team, terms which have no
          		real meaning in our model, let's make column one the winner and
          		column two the loser.</p>
<p>Create a new matrix <span class="InputCode">season2</span> with the new arrangement:</p>
<p class="InputCode">season2=J(rows(season),2,.)<br/>
          		for(i=1;i&lt;=rows(season);i++)<br/>
          		{<br/>
<span class="indent3">if (winner[i]) season2[i,.]=season[i,.]</span><br/>
<span class="indent3">else season2[i,.]=season[i,(2,1)]</span><br/>
				}<br/>
</p>
<p>Of course this loop takes time to run, but it only runs once. It's
          		the evaluator that must be run over and over, so taking a bit
          		more time to set things up so that the evaluator runs faster
          		is well worth it.</p>
<p>One general principle when it comes to writing fast Mata code is
          		that matrix operations are  faster than loops you write
          		out. There's no matrix operation that would allow you to look
          		in one matrix for the estimated strength of a team identified
          		in another matrix, but you can take calculating the <span class="InputCode">log</span> and <span class="InputCode">invlogit</span>          		functions
          		out of the loop.</p>
<p>Here's a second and more efficient version of the evaluator
          		function:</p>
<p class="InputCode">function llf2(todo,strhat,season,llf,g,H)<br/>
          		{<br/>
<span class="indent3">x=J(rows(season),1,.)</span><br/>
<span class="indent3">for(i=1;i&lt;=rows(season);i++)</span><br/>
<span class="indent3">{</span><br/>
<span class="indent3"><span class="indent3">x[i]=strhat[season[i,1]]-strhat[season[i,2]]</span></span><br/>
<span class="indent3">}</span><br/>
<span class="indent3">llf=log(invlogit(x))</span><br/>
} </p>
<p>Note how it doesn't need  to have the <span class="InputCode">winner</span> matrix passed in anymore--it
          		expects a version of <span class="InputCode">season</span> (<span class="InputCode">season2</span>) that conveys that information
          		by which team is in column one. </p>
<p>Here's the setup needed to run this version:</p>
<p class="InputCode">s=optimize_init()<br/>
          		optimize_init_evaluator(s, &amp;llf2())<br/>
          		optimize_init_evaluatortype(s,"v0")<br/>
          		strhat0=J(1,rows(teams),.5)<br/>
          		optimize_init_params(s,strhat0)<br/>
          		optimize_init_argument(s,1,season2)<br/>
          		strhat2=optimize(s) </p>
<p>You'll see that this runs in about half the time of	the original.
          		Most of the gain comes from moving the calculation of  <span class="InputCode">log</span>          		and <span class="InputCode">invlogit</span> out
          		of the loop.</p>
<p>For those looking for the absolute best performance, consider turning
          		on matastrict (<span class="InputCode">mata set matastrict on</span>).
          		Matastrict requires that you declare the names and types of all
          		variables before using them rather than letting Mata choose.
          		Mata has more variable types than most languages, and they can
          		be confusing. On the other hand, declaring your variables can
          		help you avoid errors. More importantly, Mata's compiler can
          		use the additional information to create slightly more efficient
          		object code.</p>
<p>If you are interested in using matastrict, see the manuals and
          		especially the section on declarations. </p>
<h3>Constraints</h3>
<p>One characteristic of this model is that only the difference between
          		teams is identified. You could add 100 or -1,000,000 to all the
          		strengths and the probability of each outcome would remain the
          		same. Thus two different runs on the same data could give very
          		different numbers and both be right. However, if we constrain
          		just one strength to be a given number, then all the strengths
          		are identified.</p>
<p>Mata's optimizer accepts constraints on the parameters in the form
          		of two matrices <span class="InputCode">C</span> and <span class="InputCode">c</span>. The parameters <span class="InputCode">p</span> are then constrained
          		such that <span class="InputCode">Cp=c</span>.</p>
<p>Let's constrain the strength of team one to be zero. To implement
          		this, the <span class="InputCode">C</span> matrix needs to be a row
          		vector with a column for each team. It will have a one in the
          		first column and a zero in all other columns, which makes it
          		a unit vector. <span class="InputCode">c</span> will
          		be simply the scalar zero. </p>
<p class="InputCode">C=e(1,rows(teams))<br/>
          		c=0</p>
<p>You then pass in this constraint using the <span class="InputCode">optimize_init_constraints</span>          		function.
          		It takes two arguments: the problem <span class="InputCode">s</span>,
          		as usual, and then a matrix which is the row join of <span class="InputCode">C</span> and <span class="InputCode">c</span>.
          		I'm not sure why it doesn't just take them as two separate arguments,
          		but it's easy to join them.</p>
<p class="InputCode">optimize_init_constraints(s,(C,c))</p>
<p>Since you've made no other changes to the problem, you can simply
          		run it again by calling optimize.</p>
<p class="InputCode">strhat3=optimize(s)  </p>
<p>This version will actually run significantly faster.</p>
<p>As an exercise, consider constructing some sort of metric
          		for how well your estimator does. (One easy one would be how
          		often it correctly identifies the best team.) Then vary the number
          		of games per season and see how many it takes to get reasonable
          		accuracy. However, don't do this if you want to continue to take
          		the ranking systems of actual sports seriously.</p>
<p>This example (with additional commands for timing each method)
          		is found in <a href="https://ssc.wisc.edu/sscc/pubs/files/4-26/ex2.do">ex2.do</a>. </p>
<h2>Learning More</h2>
<p>This article has just scratched the surface of what's possible
          		in Mata. There's obviously much more to learn, and even
          		more to be looked up when you need it.</p>
<p>As usual, Stata Corp. has included most of the Mata documentation
          		in the online help. There is one trick though: to get help for
          		Mata you need to type <span class="InputCode">help mata <span class="Parameter">topic</span></span> rather
          		than just <span class="InputCode">help
          		<span class="Parameter">topic</span></span>. This is especially important
          		for functions and such that exist in both Mata and Stata. For
          		example, compare the results of the following:</p>
<p class="InputCode">help abs<br/>
          		help mata abs</p>
<p>A couple useful starting places:</p>
<p class="InputCode">help mata<br/>
          		help mata functions</p>
<p>The Mata manuals are available in the CDE Library and the 4218
          		lab. There are two books, but they should be thought of as two
          		volumes of the same manual. </p>
<p>You are also welcome to ask the
          			<a href="https://ssc.wisc.edu/sscc/helpdesk.htm">Help Desk</a> for assistance. Mata is new
          		to us as well, but we'll try to figure things out together. </p>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>Bootstrapping in Stata </kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p>Stata's <span class="InputCode">bootstrap</span> command makes
          		it easy to bootstrap just about any statistic you can calculate.
          		The results of almost all Stata commands can be bootstrapped
          		immediately, and it's relatively straightforward to put any other
          		results you've calculated in a form that can be bootstrapped. This
          		article will show you how. </p>
<p>If you're just looking to bootstrap the results of a Stata command,
          		all you'll need is a basic familiarity with Stata. However, if
          		you need to calculate something else and then bootstrap it you'll
          		need to write an official Stata program to do so. If you're
          		not familiar with writing Stata programs (which are not the same
          		as do files) you'll want to take a look at <a href="https://ssc.wisc.edu/sscc/pubs/stata_prog2.htm">Stata Programming Tools</a>,
          		in particular the <a href="https://ssc.wisc.edu/sscc/pubs/stata_prog2.htm#Programs">section on programs</a>.</p>
<h2><a id="BootstrappingResultsfromStataCommands" name="BootstrappingResultsfromStataCommands"></a>Bootstrapping Results from Stata Commands</h2>
<p>If there is a single Stata command that calculates the result
          		you need, you can simply tell Stata to bootstrap the result of
          		that command. As an example, load the automobile data that comes
          		with Stata and consider trying to find the mean of the <span class="InputCode">mpg</span> variable.
          		The <span class="InputCode">summarize</span> (<span class="InputCode">sum</span>)
          		command will do exactly what you want: </p>
<p class="InputCode">sysuse auto<br/>
          	sum mpg </p>
<p>But how will the <span class="InputCode">bootstrap</span> command find the number it needs in
          		all that output? The answer is that you will tell it where to
          		look in the return vector.</p>
<h3>The Return Vector</h3>
<p>In addition to the output you see on the screen or in your log,
          		all Stata commands quietly put their results in a return vector.
          		You can refer to this vector in subsequent commands, or in the
          		case of <span class="InputCode">bootstrap</span> you can tell it
          		what part of the return vector you care about.</p>
<p>To see the current tables of the return vector, type</p>
<p class="InputCode">return list</p>
<p>The <span class="InputCode">sum</span> command is a basic command (as opposed
          		to an estimation command) so its return vector is called <span class="InputCode">r().</span>          		Looking over the list, you'll see that <span class="InputCode">r(mean)</span> is
          		the number you want. You're now ready to actually carry out the
          		bootstrap.</p>
<h3>The bootstrap Command Syntax </h3>
<p>The basic syntax for a bootstrap command is simple:</p>
<p class="InputCode">bootstrap <span class="Parameter">var</span>=r(<span class="Parameter">result</span>):
          		<span class="Parameter">command</span></p>
<p>Here <span class="InputCode"><span class="Parameter">var</span></span> is
          		simply what you want to call the quantity you're bootstrapping.
          		You're welcome to choose any name you	like	as long as it
          		meets the usual rules for a Stata variable name. In our case
          		<span class="InputCode">meanMPG</span> would be appropriate. </p>
<p><span class="InputCode">r(<span class="Parameter">result</span>)</span>tells
          		the bootstrap command to look in the <span class="InputCode">r()</span> vector
          		for the particular result you're interested in. We're interested
          		in <span class="InputCode">r(mean)</span>. </p>
<p>Finally <span class="Parameter"><span class="InputCode">command</span></span> should
          		be replaced by the actual command that calculates the result
          		you want. In our case it's <span class="InputCode">sum mpg</span>. </p>
<p>Putting this all together, the command to bootstrap the mean of
          		the variable <span class="InputCode">mpg</span> is simply:</p>
<p class="InputCode">bootstrap meanMPG=r(mean): sum mpg</p>
<p>When you run that you'll get a note explaining that bootstrap can't
          		exclude missing values and such unless you're  working with
          		an estimation command (more on them shortly) but that won't be
          		a problem in this case. The results you want will follow.</p>
<p>What if you wanted to bootstrap two different quantities? No problem,
          		just list them both:</p>
<p class="InputCode">bootstrap meanMPG=r(mean) maxMPG=r(max): sum
          		mpg</p>
<h3>Bootstrapping Estimation Commands</h3>
<p>Estimation commands are slightly different in that they store their
          		results in the <span class="InputCode">e()</span> vector rather than the <span class="InputCode">r()</span> vector and must
          		be listed by typing <span class="InputCode">ereturn list</span> rather
          		than <span class="InputCode">return
          		list</span>. To see this, type the following:</p>
<p class="InputCode">reg mpg weight foreign<br/>
          		ereturn list</p>
<p>One warning: bootstrap is an estimation command, so after running
          		it the <span class="InputCode">e()</span> vector will contain the results of the bootstrap,
          		not the results of the command you were bootstrapping. </p>
<p>Suppose you wanted to bootstrap the F-statistic for some odd reason.
          		All you'd have to do is type:</p>
<p class="InputCode">bootstrap f=e(F): reg mpg weight foreign </p>
<p>A more common example would be to bootstrap the coefficients.
          		They're available in <span class="InputCode">e(b)</span> but that's
          		a matrix so getting at them individually would be complicated.
          		Fortunately this is so common that it's set up as a convenient
          		special case: if
          		<span class="InputCode">bootstrap</span> is given nothing to bootstrap,
          		it will look for an
          		<span class="InputCode">e(b)</span> matrix and bootstrap that. Thus
          		all you need to type is:</p>
<p class="InputCode">bootstrap: reg mpg weight foreign</p>
<h2><a id="BootstrapOptions" name="BootstrapOptions"></a>Bootstrap Options</h2>
<p>The <span class="InputCode">bootstrap</span> command has  a fair
          		number of options available. The <span class="InputCode">nowarn</span> option
          		will get rid of that annoying message about <span class="InputCode">e(sample)</span> that
          		you got after our first example. The <span class="InputCode">reps</span> option
          		allows you choose how many bootstrap replications are performed--the
          		default is 50. For a full list of options type <span class="InputCode">help
          		bootstrap</span>.</p>
<p>However, all these options apply to the <span class="InputCode">bootstrap</span> command
          		and not to the  command you're bootstrapping. Thus they go after
          		a comma as always, but before the semicolon that ends the bootstrap
          		part of the command. You could then have another comma at the
          		end of the command to be bootstrapped, followed by options that
          		apply to it. For example:</p>
<p class="InputCode">bootstrap perc90=r(p90), nowarn reps(25):
          			sum mpg, detail</p>
<p>This bootstraps the 90th percentile of <span class="InputCode">mpg</span>,
          		which is only available if <span class="InputCode">sum</span> is
          		given the <span class="InputCode">detail</span> option. It also suppresses
          		the warning message and only does 25 replications. Note where all
          		those options are located in the command.</p>
<h2><a id="BootstrappingResultsYouveCalculated" name="BootstrappingResultsYouveCalculated"></a>Bootstrapping Results You've Calculated</h2>
<p>If all you need to do is bootstrap the results of existing Stata
          		commands you may want to stop here, especially since things are about
          		to get a bit more complicated.</p>
<p>If there's no single Stata command that will calculate a result
          		you want to bootstrap, you'll just have to write your own. As
          		you may know from reading <a href="https://ssc.wisc.edu/sscc/pubs/stata_prog2.htm#Programs">Stata Programming Tools</a>, Stata allows you to write programs that act like regular
          		Stata commands. You can even make them return results so that
          		they'll work with <span class="InputCode">bootstrap</span>. </p>
<p>Suppose you wanted to bootstrap the statistic "Mean weight of those
          		cars in the top quartile for mpg." Calculating the statistic
          		isn't hard to do:</p>
<p class="InputCode">xtile quartile=mpg, nq(4)<br/>
          		sum weight if quartile==4</p>
<p>But since it requires two commands it can't be bootstrapped as
          		is. We'll need to write a program that carries out those two
          		steps and returns the result in <span class="InputCode">r()</span>.</p>
<p class="InputCode">program define topQuartileMean, rclass<br/>
<span class="indent3">xtile quartile=mpg, nq(4)</span><br/>
<span class="indent3">sum weight if quartile==4</span><br/>
<span class="indent3">return scalar tqm=r(mean)</span><br/>
<span class="indent3">drop quartile</span><br/>
end</p>
<p>Most of this should be familiar, but there are a few additional
          		elements that need to be explained. </p>
<p>Adding the <span class="InputCode">rclass</span> option to the
          		program definition tells Stata that this program will be putting
          		things in the <span class="InputCode">r()</span> vector.  The
          		<span class="InputCode">return</span> command is what actually does
          		so, and <span class="InputCode">scalar</span> means this particular
          		result is a single number as opposed to a matrix like <span class="InputCode">e(b)</span>.
          		We're calling our returned value <span class="InputCode">tqm</span> (as
          		in top quartile mean) so it will be available after the program
          		runs as <span class="InputCode">r(tqm)</span>.
          		The number we're putting in it is the <span class="InputCode">r(mean)</span> result
          		from the previous <span class="InputCode">sum</span> command--not
          		a result of our <span class="InputCode">topQuartileMean</span> program,
          		which doesn't have results yet.</p>
<p> Also note that we
          		need to drop the <span class="InputCode">quartile</span> variable
          		at the end so we can create a new one in the next bootstrap replication.</p>
<p>Now that the program <span class="InputCode">topQuartileMean</span> is defined, you can use it
          		with bootstrap just like any other Stata command:</p>
<p class="InputCode">bootstrap tqm=r(tqm): topQuartileMean</p>
<p>You'll then get your results.  </p>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title> Using Reshape to Manage Hierarchical Data</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- InstanceBeginEditable name="Text" -->
<p>Hierarchical data is any kind of data where observations fall into groups or clusters. The most common examples at the SSCC are individuals living in a household and a subject being observed multiple times, but there are many other applications: schools within a district, courses taken by a student, or even  individuals who are part of a subject's social network can all be treated as hierarchical data. Hierarchies can also have more than two levels; for example students may be grouped into classrooms which are grouped into schools which are grouped into districts.</p>
<p>One of the most useful tools for managing hierarchical data in Stata is the <span class="InputCode">reshape</span> command. It is very simple to use, but you need to be able to picture in your mind what it does and why. This article will try to give you that picture and then discuss using <span class="InputCode">reshape</span> in a variety of situations.</p>
<p>Note that SPSS has a tool called the <span class="MenuOutput">Restructure Data Wizard</span> which looks very different but  does essentially the same thing, and you can <a href="http://ssc.wisc.edu/sscc/pubs/4-18.htm#ExampleReshapingData">write a program to do it in SAS</a> (though with substantially more effort). Thus the conceptual parts of this article may be of interest even if you don't use Stata.</p>
<h2><a id="DescribingHierarchicalData" name="DescribingHierarchicalData"></a>Describing Hierarchical Data</h2>
<p>Since hierarchical data can describe so many different things, we need some to define terms that can apply to all of them. We'll describe the smallest unit in the data as the level one unit. In the examples mentioned above the level one unit would be an individual within the household, a particular time the subject was observed, a school within the district, a course taken by the student, or an individual within the subject's social network. A level two unit is then a group of level one units: the household in which the individuals live, the subject which is measured repeatedly, the district which contains the schools, the student who takes the courses or the subject whose social network is being described. If needed, a level three unit is  a collection of level two units, and so forth.</p>
<p>Normally a hierarchical data set will include some variables which describe the level one units and some which describe the level two units. For example, a data set of individuals living in households may contain the age and sex of each individual, plus the household income of the household as a whole. Age and sex would then be level one variables while household income would be a level two variable.</p>
<p>Level two variables are easy to identify: they always have the same value for all level one units in the same level two unit. For example, the total number of people in the household must be the same for every member of a household, or if a subject is observed multiple times he or she must have the same race each time. Anything that varies within a level two unit is a level one variable: individuals within a household can obviously have different employment statuses, so employment status must be a level one variable. What occasionally gets forgotten is that individuals observed over time can change their education level or marital status, so those must be level one variables as well. While it's rarely difficult to identify which of your variables are level one and which are level two, taking a moment to do so during the planning stage of your project and before writing any code can help you avoid a lot of headaches.</p>
<p>In an ideal world, each level would have an associated  identifier: for example a household ID and an individual ID, or a subject ID and a wave ID. The level one identifiers only need to be unique within a level two group, and in fact <span class="InputCode">reshape</span> will only be able to use it if this is the case. Often data sets do not come with a usable level one identifier, but <a href="#CreatingaLevelOneIdentifier">one can be created very easily</a>.</p>
<h2><a id="RepresentingHierarchicalDataasaMatrix" name="RepresentingHierarchicalDataasaMatrix"></a>Representing Hierarchical Data as a Matrix</h2>
<p>Stata (like most statistical programs) stores its data in a matrix, where rows are observations and columns are variables. But when working with hierarchical data "observation" is an ambiguous term: it could mean either a level one unit or a level two unit. The purpose of the <span class="InputCode">reshape</span> command is to allow you to go back and forth between the two definitions at will, restructuring your data accordingly.</p>
<p>If an observation represents a level one unit, then your data are in the long form. The long form is so named because it has a larger number of observations but fewer variables. In the long form, both level one and level two variables are represented by columns in the data matrix. However, level two variables will have many repeated values, since all the observations in the same level two group will share the same values of all the level two variables.</p>
<p>If, on the other hand, an observation represents a level two unit, then your data are in the wide form. The wide form is so named because it has fewer observations but more variables. In wide form, level two variables are represented by columns as usual. However, level one variables are represented by sets of columns, with each set containing a column for each level one unit. Thus the values of the level one variables for each level one unit within a level two unit are stored in the same row, but in different columns.</p>
<p>Consider the following data (taken from the <a href="http://pwt.econ.upenn.edu/php_site/pwt_index.php">Penn World 
	Table</a>).</p>
<a id="long" name="long"></a><table align="center" border="1" cellpadding="4" cellspacing="0">
<tr align="left">
<th>Country</th>
<th>Continent</th>
<th>Year</th>
<th>Population</th>
<th> GDP Per-Capita</th>
</tr>
<tr>
<td>Afghanistan</td>
<td>Asia</td>
<td>2000</td>
<td>25889</td>
<td>478</td>
</tr>
<tr>
<td>Afghanistan</td>
<td>Asia</td>
<td>2001</td>
<td>26813</td>
<td>428</td>
</tr>
<tr>
<td>Afghanistan</td>
<td>Asia</td>
<td>2002</td>
<td>27756</td>
<td>547</td>
</tr>
<tr>
<td>Albania</td>
<td>Europe</td>
<td>2000</td>
<td>3474</td>
<td>3797</td>
</tr>
<tr>
<td>Albania</td>
<td>Europe</td>
<td>2001</td>
<td>3490</td>
<td>4269</td>
</tr>
<tr>
<td>Albania</td>
<td>Europe</td>
<td>2002</td>
<td>3509</td>
<td>4431</td>
</tr>
<tr>
<td>Algeria</td>
<td>Africa</td>
<td>2000</td>
<td>31194</td>
<td>5753</td>
</tr>
<tr>
<td>Algeria</td>
<td>Africa</td>
<td>2001</td>
<td>31736</td>
<td>5534</td>
</tr>
<tr>
<td>Algeria</td>
<td>Africa</td>
<td>2002</td>
<td>32278</td>
<td>5639</td>
</tr>
</table>
<p>This is panel data, where countries are observed over time. Thus a level two unit is a country and a level one unit is a country's data in a particular year. Population and GDP Per-Capita are level one variables as they change over time. Continent is a level two variable as it does not change (at least not over the time scale we're interested in). As listed above, each row represents a level one unit. Thus this data set is in the long form. Now consider the exact same data in a different format:</p>
<a id="wide" name="wide"></a>
<table align="center" border="1" cellpadding="4">
<tr>
<th scope="col">Country</th>
<th scope="col">Pop2000</th>
<th scope="col">CGDP2000</th>
<th scope="col">Pop2001</th>
<th scope="col">CGDP2001</th>
<th scope="col">Pop2002</th>
<th scope="col">CGDP2002</th>
<th scope="col">Continent</th>
</tr>
<tr>
<td> Afghanistan</td>
<td>25889</td>
<td>478</td>
<td>26813</td>
<td>428</td>
<td>27756</td>
<td>547</td>
<td>Asia</td>
</tr>
<tr>
<td>Albania</td>
<td>3474</td>
<td>3797</td>
<td>3490</td>
<td>4269</td>
<td>3509</td>
<td>4431</td>
<td>Europe</td>
</tr>
<tr>
<td>Algeria</td>
<td>31194</td>
<td>5753</td>
<td>31736</td>
<td>5534</td>
<td>32278</td>
<td>5639</td>
<td>Africa</td>
</tr>
</table>
<p>Now a row represents a level two unit, so this is the wide form. The level one variables Population and GDP Per-Capita (abbreviated Pop and CGDP) are represented by three columns each: one for the year 2000, one for 2001, and one for 2002.</p>
<h2><a id="UsingReshape" name="UsingReshape"></a>Using Reshape</h2>
<p>Stata's <span class="InputCode">reshape</span> command allows you switch between the two forms at will. The general syntax is:</p>
<p class="InputCode">reshape [<span class="Parameter">long or wide</span>] [<span class="Parameter">"stubs" of level one variable names</span>], i(<span class="Parameter">level two ID</span>) j(<span class="Parameter">level one ID</span>)</p>
<p>Before talking through the syntax in detail let's do an example. First load the Stata version of this data by typing (or more likely, copying and pasting): </p>
<p class="InputCode">use http://ssc.wisc.edu/sscc/pubs/files/4-28/reshape1</p>
<p>Do a list (<span class="InputCode">l</span>) and you'll see it's currently in the long form (as in <a href="#long">this table</a>). To change that, type:</p>
<p class="InputCode">reshape wide pop cgdp, i(country) j(year)</p>
<p>Do another list to see the results (it should look like <a href="#wide">this table</a>). To go back to long form, type: </p>
<p class="InputCode"> reshape long pop cgdp, i(country) j(year)</p>
<p>Referring back to the general syntax, <span class="InputCode">long</span> or <span class="InputCode">wide</span> is the form in which you want to put the data. Next comes a list of level one variables, but note that when the data set is in wide form it does not contain any variables called literally <span class="InputCode">pop</span> or <span class="InputCode">cgdp</span>. Instead you have <span class="InputCode">pop2000</span>, <span class="InputCode">pop2001</span> and so forth. Note too that <span class="InputCode">continent</span> is not in the list, as it is a level two variable.</p>
<p> The <span class="InputCode">i()</span> option is where you give the level two identifier variable. <span class="InputCode">j()</span> is then the level one identifier--but  note again that in wide form the data set does not have a variable called <span class="InputCode">year</span>. When reshaping from wide to long, <span class="InputCode">pop cgdp</span> combined with <span class="InputCode">j(year) </span>can be interpreted as "look for variables that start with <span class="InputCode">pop</span> or <span class="InputCode">cgdp</span>, then take whatever follows that and put it in a new variable called <span class="InputCode">year</span>."</p>
<p>Incidentally this is why <span class="InputCode">reshape</span> can't use Stata's <em>varlist</em> syntax (which is unfortunate if your data set includes a large number of level one variables). The stubs  aren't really variable names. </p>
<h2><a id="RemovingExtraneousCases" name="RemovingExtraneousCases"></a>Removing Extraneous Cases</h2>
<p>Now consider a (fabricated) data set consisting of individuals living in households:</p>
<table align="center" border="1" cellpadding="4">
<tr>
<th scope="col">household</th>
<th scope="col">income</th>
<th scope="col">age1</th>
<th scope="col">female1</th>
<th scope="col">age2</th>
<th scope="col">female2</th>
<th scope="col">age3</th>
<th scope="col">female3</th>
</tr>
<tr>
<td>1</td>
<td>30000</td>
<td>30</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>2</td>
<td>90000</td>
<td>45</td>
<td>0</td>
<td>43</td>
<td>1</td>
<td>15</td>
<td>0</td>
</tr>
</table>
<p>Here the level one unit is an individual, the level two unit is a household (with the <span class="InputCode">household</span> variable as the identifier), <span class="InputCode">income</span> is a level two variable, and <span class="InputCode">age</span> and <span class="InputCode">female</span> are level one variables. Since an observation represents a household, the level two unit, this data set is in wide form.</p>
<p>Load this data with:</p>
<p class="InputCode">use http://ssc.wisc.edu/sscc/pubs/files/4-28/reshape2</p>
<p>If you need an observation to represent an individual instead, all you need to do is reshape the data into the long form:</p>
<p class="InputCode">reshape long age female, i(household) j(j)</p>
<p>Most of this is familiar, but there is one puzzle: what is <span class="InputCode">j</span>? At one level the answer is "The number at the end of <span class="InputCode">age</span> and <span class="InputCode">female</span>." But if you want to go further and ask "What does <span class="InputCode">j</span> mean?" the answer in this case is "We don't know." It's the order in which the individuals in the household are listed in the data set, but they may have been listed in more or less random order--in which case <span class="InputCode">j</span> would mean absolutely nothing. Or <span class="InputCode">j</span> may be very important--person one may always be the respondent, or the head of the household. We don't know without consulting the documentation for the data set (and since this data set was fabricated no documentation exists). So we'll punt and just call it <span class="InputCode">j</span>.</p>
<p>Here is the result of the reshape command:</p>
<table align="center" border="1" cellpadding="4">
<tr>
<th scope="col">household</th>
<th scope="col">j</th>
<th scope="col">income</th>
<th scope="col">age</th>
<th scope="col">female</th>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>30000</td>
<td>30</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>30000</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>30000</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>90000</td>
<td>45</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>90000</td>
<td>43</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>90000</td>
<td>15</td>
<td>0</td>
</tr>
</table>
<p>There's just one problem: person number three in household one. Note that in wide form the number of columns is determined by the household with the largest number of members--the data set must be wide enough to contain all the individuals in that household. However, since all rows have the same number of columns, smaller households have as many columns as the biggest household. In this data set, household one only has two people so <span class="InputCode">age3</span> and <span class="InputCode">female3</span> are missing. But the reshape command doesn't choose not create an observation just because these variables don't have values. After all, conceivably there could  be a third person in household one and we just don't know their age or sex.</p>
<p>Such agnosticism is rarely an option with real data. In big surveys the largest household tends to be very large indeed, so you could easily have variables like <span class="InputCode">age26</span> and <span class="InputCode">female26</span>. Converting them all to observations results in a data set consisting mostly of missing values. Thus you most likely want to drop these extraneous observations:</p>
<p class="InputCode">drop if age==. &amp; female==.</p>
<p>If you had more level one variables you would still use all of them in the <em>if</em> condition, just to be sure that you don't eliminate a real person who is only missing a few variables.</p>
<p>Note that what we've discussed so far covers 90%  of the ways <span class="InputCode">reshape</span> is used. The remaining examples in this article cover special cases, so continue reading at your discretion.</p>
<h2><a id="CreatingaLevelOneIdentifier" name="CreatingaLevelOneIdentifier"></a>Creating a Level One Identifier</h2>
<p>Now suppose you had gotten the data in long form, but without the <span class="InputCode">j</span> variable.</p>
<table align="center" border="1" cellpadding="4">
<tr>
<th scope="col">household</th>
<th scope="col">income</th>
<th scope="col">age</th>
<th scope="col">female</th>
</tr>
<tr>
<td>1</td>
<td>30000</td>
<td>30</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>30000</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>90000</td>
<td>45</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>90000</td>
<td>43</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>90000</td>
<td>15</td>
<td>0</td>
</tr>
</table>
<p>Type:</p>
<p class="InputCode">use http://ssc.wisc.edu/sscc/pubs/files/4-28/reshape3</p>
<p>to load this in Stata.</p>
<p>This data set contains all the information in the original data set. But what if you had to convert it to wide form? There's no j variable and nothing that can be used as a j variable. So you'll  have to make one:</p>
<p class="InputCode">bysort household: gen j=_n</p>
<p>A list (<span class="InputCode">l</span>) will verify that this works, but you should be very careful if the order of the household members is important. By default Stata's sort algorithm is not "stable" meaning that ties are not necessarily left in the same order they started in. Thus when you sort by <span class="InputCode">household</span>, you could change the order of the individuals within each household.</p>
<p>One solution is to add the <span class="InputCode">stable</span> option to all your sorts. Then Stata will use a (slightly slower) stable sort algorithm. However, this can't be used with <span class="InputCode">bysort</span>. Thus you'd have to instead type:</p>
<p class="InputCode">sort household, stable<br/>
            by household: gen j=_n</p>
<p>Another approach is to create a new variable that keeps track of the original order. This has the advantage of of allowing you to return to the proper sort order later if you ever have to sort by something else.</p>
<p class="InputCode">gen originalOrder=_n<br/>
              sort household originalOrder<br/>
              by household: gen j=_n</p>
<p>This can  be done with <span class="InputCode">bysort</span>, since <span class="InputCode">bysort</span> understands variables in parentheses as variables it should sort by but not use to form <em>by</em> groups:</p>
<p class="InputCode">gen originalOrder=_n<br/>
              bysort household (originalOrder): gen j=_n<br/>
</p>
<h2><a id="UsingStringsasIdentifiers" name="UsingStringsasIdentifiers"></a>Using Strings as Identifiers</h2>
<p>Suppose you had data on students who have taken the SAT, including their SAT section scores. The SAT has three sections, which we'll call <span class="InputCode">verbal</span>, <span class="InputCode">math</span> and <span class="InputCode">writing</span> (officially they're now called Critical Reading, Mathematics and Writing). Each student takes all three sections.</p>
<table align="center" border="1" cellpadding="4">
<tr>
<th>id</th>
<th>section</th>
<th>score</th>
</tr>
<tr>
<td>13</td>
<td>verbal</td>
<td>571</td>
</tr>
<tr>
<td>13</td>
<td>math</td>
<td>236</td>
</tr>
<tr>
<td>13</td>
<td>writing</td>
<td>533</td>
</tr>
<tr>
<td>55</td>
<td>verbal</td>
<td>722</td>
</tr>
<tr>
<td>55</td>
<td>math</td>
<td>353</td>
</tr>
<tr>
<td>55</td>
<td>writing</td>
<td>226</td>
</tr>
<tr>
<td>68</td>
<td>verbal</td>
<td>454</td>
</tr>
<tr>
<td>68</td>
<td>math</td>
<td>739</td>
</tr>
<tr>
<td>68</td>
<td>writing</td>
<td>513</td>
</tr>
</table>
<p>First load the data:</p>
<p class="InputCode">use http://ssc.wisc.edu/sscc/pubs/files/4-28/reshape4</p>
<p>The level one unit in this data set is a section and the level two unit is a student. The variables <span class="InputCode">id</span> and <span class="InputCode">section</span> are the level two and level one identifiers respectively, and <span class="InputCode">score</span> is a level one variable. However, <span class="InputCode">section</span> is stored as a string. That's not a problem: just add the <span class="InputCode">string</span> option to  <span class="InputCode">reshape</span>:</p>
<p class="InputCode">reshape wide score, i(id) j(section) string</p>
<p>The process of reshaping the data is the same, but the values of <span class="InputCode">section</span> which are added to the <span class="InputCode">score</span> stub are now <span class="InputCode">verbal</span>, <span class="InputCode">math</span> and <span class="InputCode">writing</span> rather than numbers. The resulting variables are <span class="InputCode">scoremath</span>, <span class="InputCode">scoreverbal</span> and <span class="InputCode">scorewriting</span>.</p>
<p> These variable names are functional, but somewhat hard to read. One solution would be rename <span class="InputCode">score</span> to <span class="InputCode">score_</span>  before reshaping (<span class="InputCode">ren score score_</span>). Then the reshaped variables would be <span class="InputCode">score_math</span>, <span class="InputCode">score_verbal</span> and <span class="InputCode">score_writing</span>. Another would be to capitalize the first letter in the values of <span class="InputCode">section</span> using the <span class="InputCode">proper</span> function (<span class="InputCode">replace section=proper(section)</span>). Then the variables would be <span class="InputCode">scoreMath</span>, <span class="InputCode">scoreVerbal</span> and <span class="InputCode">scoreWriting</span>.</p>
<p>In any case the structure will be the same:</p>
<table align="center" border="1" cellpadding="4">
<tr>
<th>id</th>
<th>scoreMath</th>
<th>scoreVerbal</th>
<th>scoreWriting</th>
</tr>
<tr>
<td>13</td>
<td>236</td>
<td>571</td>
<td>533</td>
</tr>
<tr>
<td>55</td>
<td>353</td>
<td>722</td>
<td>226</td>
</tr>
<tr>
<td>68</td>
<td>739</td>
<td>454</td>
<td>513</td>
</tr>
</table>
<h2><a id="HandlingNonstandardVariableNames" name="HandlingNonstandardVariableNames"></a>Handling Non-standard Variable Names</h2>
<p>Now suppose you got this data set in wide form and needed to convert it to long, but it had slightly different variable names:</p>
<table align="center" border="1" cellpadding="4">
<tr>
<th>id</th>
<th>SATMathScore</th>
<th>SATVerbalScore</th>
<th>SATWritingScore</th>
</tr>
<tr>
<td>13</td>
<td>236</td>
<td>571</td>
<td>533</td>
</tr>
<tr>
<td>55</td>
<td>353</td>
<td>722</td>
<td>226</td>
</tr>
<tr>
<td>68</td>
<td>739</td>
<td>454</td>
<td>513</td>
</tr>
</table>
<p>Load this with:</p>
<p class="InputCode">use http://ssc.wisc.edu/sscc/pubs/files/4-28/reshape5</p>
<p>These variable names are very clear, but they don't follow the stub+suffix convention. Fortunately you can tell Stata where to find the j variable within the stub using the @ sign:</p>
<p class="InputCode"> reshape long SAT@Score, i(id) j(section) string</p>
<p>This tells Stata to look for variables than start with <span class="InputCode">SAT</span> and end with <span class="InputCode">Score</span>, and then the j variable, <span class="InputCode">section,</span> is everything in between.</p>
<table align="center" border="1" cellpadding="4">
<tr>
<th>id</th>
<th>section</th>
<th>SATScore</th>
</tr>
<tr>
<td>13</td>
<td>Math</td>
<td>236</td>
</tr>
<tr>
<td>13</td>
<td>Verbal</td>
<td>571</td>
</tr>
<tr>
<td>13</td>
<td>Writing</td>
<td>533</td>
</tr>
<tr>
<td>55</td>
<td>Math</td>
<td>353</td>
</tr>
<tr>
<td>55</td>
<td>Verbal</td>
<td>722</td>
</tr>
<tr>
<td>55</td>
<td>Writing</td>
<td>226</td>
</tr>
<tr>
<td>68</td>
<td>Math</td>
<td>739</td>
</tr>
<tr>
<td>68</td>
<td>Verbal</td>
<td>454</td>
</tr>
<tr>
<td>68</td>
<td>Writing</td>
<td>513</td>
</tr>
</table>
<h2><a id="WorkingWithMoreThanTwoLevels" name="WorkingWithMoreThanTwoLevels"></a>Working With More Than Two Levels</h2>
<p>If you have more than two levels things get more complicated at the conceptual level, but the Stata code remains the same except that you may have to apply the <span class="InputCode">reshape</span> command multiple times. Suppose you had data on two schools, each with two classes, each of which has two students (yes, these are very small schools and classes, but it makes for manageable tables). Thus the level one unit is a student, the level two unit is a class and the level three unit is a school. The data set includes an identifier for each level (<span class="InputCode">school</span>, <span class="InputCode">class</span>, <span class="InputCode">student</span>) and one variable for each level (<span class="InputCode">lunch</span>--percentage of the school's students receiving free or reduced price lunches, <span class="InputCode">exp</span>--the number of years of teaching experience the class's teacher has, and <span class="InputCode">score</span>--the student's score on a test). Also note that the identifiers are 1 and 11 rather than 1 and 2 or random numbers. This is to guarantee we run into a problem that is otherwise merely common.</p>
<p>Load this with:</p>
<p class="InputCode">use http://ssc.wisc.edu/sscc/pubs/files/4-28/reshape6</p>
<p>Now that there are three levels, a row could represent a level one unit, a level two unit or a level three unit. The structure where a row represents a level one unit is sometimes called the long-long form:</p>
<table align="center" border="1" cellpadding="4">
<tr>
<th>school</th>
<th>lunch</th>
<th>class</th>
<th>exp</th>
<th>student</th>
<th>score</th>
</tr>
<tr>
<td>1</td>
<td>45</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>83</td>
</tr>
<tr>
<td>1</td>
<td>45</td>
<td>1</td>
<td>1</td>
<td>11</td>
<td>82</td>
</tr>
<tr>
<td>1</td>
<td>45</td>
<td>11</td>
<td>4</td>
<td>1</td>
<td>96</td>
</tr>
<tr>
<td>1</td>
<td>45</td>
<td>11</td>
<td>4</td>
<td>11</td>
<td>71</td>
</tr>
<tr>
<td>11</td>
<td>26</td>
<td>1</td>
<td>7</td>
<td>1</td>
<td>90</td>
</tr>
<tr>
<td>11</td>
<td>26</td>
<td>1</td>
<td>7</td>
<td>11</td>
<td>91</td>
</tr>
<tr>
<td>11</td>
<td>26</td>
<td>11</td>
<td>8</td>
<td>1</td>
<td>90</td>
</tr>
<tr>
<td>11</td>
<td>26</td>
<td>11</td>
<td>8</td>
<td>11</td>
<td>76</td>
</tr>
</table>
<p>Now consider reshaping so that a row represents a level two unit. The j variable is clearly <span class="InputCode">student</span>. But the i variable is not just <span class="InputCode">class</span>, because <span class="InputCode">class</span> only uniquely identifies a class within a school. To fully identify a class you need both <span class="InputCode">school</span> and <span class="InputCode">class</span>. Thus the command is:</p>
<p class="InputCode">reshape wide score, i(school class) j(student)</p>
<p>And the result is:</p>
<table align="center" border="1" cellpadding="4">
<tr>
<th>school</th>
<th>class</th>
<th>score1</th>
<th>score11</th>
<th>lunch</th>
<th>exp</th>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>83</td>
<td>82</td>
<td>45</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>11</td>
<td>96</td>
<td>71</td>
<td>45</td>
<td>4</td>
</tr>
<tr>
<td>11</td>
<td>1</td>
<td>90</td>
<td>91</td>
<td>26</td>
<td>7</td>
</tr>
<tr>
<td>11</td>
<td>11</td>
<td>90</td>
<td>76</td>
<td>26</td>
<td>8</td>
</tr>
</table>
<p>This is sometimes called long-wide form. It is long with respect to classes, but wide with respect to students.</p>
<p> To make a row represent a level three unit, a school, you need to reshape again:</p>
<p class="InputCode">reshape wide score1 score11 exp, i(school) j(class)</p>
<p>But this gives an error:</p>
<p><span class="Red">score11 already defined</span><br/>
<span class="Blue">r(110);</span><br/>
</p>
<p>The trouble is the identifiers. The reshape command identifies the values of the j variable (<span class="InputCode">class</span>) as 1 and 11. It then tries to add them to the names of the existing variables <span class="InputCode">score1</span> and <span class="InputCode">score11</span>. But that means the score for student 1 in class 1 would be stored as <span class="InputCode">score11</span>, and that variable already exists. It's true that the existing <span class="InputCode">score11</span> will be renamed something else shortly, but even if Stata recognized that and proceeded  the results would still be problematic: both student 1, class 11 and student 11, class 1 would have their scores stored as <span class="InputCode">score111</span>.</p>
<p>While this data set was constructed specifically to ensure that this problem arose, it will probably come up on its own if you have more than two levels and the values of the identifiers do not always have the same lengths. The solution is to separate the student numbers and the class numbers somehow. The following adds an underscore between them:</p>
<p class="InputCode">ren score1 score1_<br/>
              ren score11 score11_<br/>  
            reshape wide score1_ score11_ exp, i(school) j(class)</p>
<p>The result is the following:</p>
<table align="center" border="1" cellpadding="4">
<tr>
<th>school</th>
<th>score1_1</th>
<th>score11_1</th>
<th>exp1</th>
<th>score1_11</th>
<th>score11_11</th>
<th>exp11</th>
<th>lunch</th>
</tr>
<tr>
<td>1</td>
<td>83</td>
<td>82</td>
<td>1</td>
<td>96</td>
<td>71</td>
<td>4</td>
<td>45</td>
</tr>
<tr>
<td>11</td>
<td>90</td>
<td>91</td>
<td>7</td>
<td>90</td>
<td>76</td>
<td>8</td>
<td>26</td>
</tr>
</table>
<p>This is sometimes known as the wide-wide form, because it is wide in both class and student.<br/>
</p>
<p>Note that Stata doesn't really understand  the nesting structure of your data set and will allow you to do things that don't  make much sense. For example, you could start with the original data in long-long form and type:</p>
<p class="InputCode">reshape wide score exp, i(school student) j(class)</p>
<p>Stata will carry out its instructions without complaint, but this is treating a class as the level one unit and a student as the level two unit--as if all the student 1s had something important in common. While Stata will prevent you from doing a reshape that is clearly wrong (for example, misidentifying a level one variable as a level two variable) it is your responsibility to make sure you've correctly identified the levels and that the reshape  makes sense.</p>
<!-- InstanceEndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
<kb_document>
<kb_title>Redirecting and Customizing Tabular Output in SAS</kb_title>
<kb_keywords>.</kb_keywords>
<kb_summary>.</kb_summary>
<kb_body>

<!-- #BeginEditable "Text" -->
<p>SAS introduced the Output Delivery System (ODS) in version 7 which 
              provides a way of managing your SAS output. This document illustrates 
              how you can use ODS to:</p>
<ul>
<li>create SAS data sets from procedure output</li>
<li>redirect tabular output to HTML, Rich Text Format (RTF), or 
                PostScript formatted files for inclusion in other programs like 
                Internet Explorer, Word, WordPerfect, or Latex.</li>
<li>select and exclude components of the tabular output</li>
<li>use templates to customize the appearance of tabular output 
                layout, format, and headers.</li>
</ul>
<p>SAS has extended the capabilities of ODS in version 9.1 to include 
              graphics for some statistical procedures. Graphics produced through 
              ODS require minimal syntax, unlike graphs produced through SAS/GRAPH. 
              ODS for statistical graphics is documented in  
              <a href="https://www.ssc.wisc.edu/sscc/pubs/4-21.htm">A Simple Procedure 
              for Producing Publication-Quality Graphs using SAS</a>.</p>
<h2>Creating SAS Data Sets from Procedure Output</h2>
<p>SAS procedures have always made the most important statistics available as 
  output data sets (using <span class="InputCode">OUT=</span> options or <span class="InputCode">OUTPUT</span> 
  statements), but with ODS, every number in every table of every procedure can 
  be accessed via a data set.</p>
<p>ODS divides procedure output into components called output objects. Look at 
  the following default output from the TTEST procedure:</p>
<p> <br/>
</p>
<pre>
                                  Statistics
 
                             Lower CL          Upper CL  Lower CL
Variable  gender          N      Mean    Mean      Mean   Std Dev  Std Dev
score     f               7    74.504  76.857    79.211    1.6399   2.5448
score     m               7    79.804  82.714    85.625     2.028   3.1472
score     Diff (1-2)            -9.19  -5.857    -2.524    2.0522   2.8619


                          Statistics
 
                      Upper CL
Variable  gender       Std Dev    Std Err    Minimum    Maximum
score     f             5.6039     0.9619         73         80
score     m             6.9303     1.1895         78         87
score     Diff (1-2)    4.7242     1.5298                      


                               T-Tests
 
Variable    Method           Variances      DF    t Value    Pr &gt; |t|
score       Pooled           Equal          12      -3.83      0.0024
score       Satterthwaite    Unequal      11.5      -3.83      0.0026


                    Equality of Variances
 
Variable    Method      Num DF    Den DF    F Value    Pr &gt; F
score       Folded F         6         6       1.53    0.6189

  </pre>
<p>ODS defines three output objects in the above output: a "Statistics" 
  table, "T-Tests" table, and "Equality of Variances" table. 
  Any object can be written to a SAS data set once you know ODS's name for the 
  object.</p>
<h3>Determining the Names of Output Objects</h3>
<p>Use the <span class="InputCode">ODS TRACE</span> statement to determine the 
  names of procedure objects:</p>
<p class="InputCode">ods trace output;</p>
<p class="InputCode"> proc ttest;<br/>
  class gender;<br/>
  var score;<br/>
  title 'GOLF SCORES';<br/>
  run;</p>
<p class="InputCode">ods trace off;</p>
<p>When the trace is turned on (<span class="InputCode">ODS TRACE OUTPUT;</span>), 
  information about the objects, including their names, is written to the log:</p>
<p class="InputCode">Output Added:<br/>
  -------------<br/>
  Name: Statistics<br/>
  Label: Statistics<br/>
  Template: Stat.TTest.Statistics<br/>
  Path: Ttest.Statistics<br/>
  -------------</p>
<p class="InputCode">Output Added:<br/>
  -------------<br/>
  Name: TTests<br/>
  Label: T-Tests<br/>
  Template: Stat.TTest.TTests<br/>
  Path: Ttest.TTests<br/>
  -------------</p>
<p><span class="InputCode">Output Added:<br/>
  -------------<br/>
  Name: Equality<br/>
  Label: Equality of Variances<br/>
  Template: Stat.TTest.Equality<br/>
  Path: Ttest.Equality<br/>
</span> </p>
<p>The three output objects are called Statistics, Ttests, and Equality.</p>
<p><span class="InputCode">ODS TRACE OFF;</span> turns off the trace. (No <span class="InputCode">RUN</span> 
  statement is needed.)</p>
<h3>Redirecting the Output</h3>
<p>Once you know the name of the object you want to make a SAS data set from, 
  use the <span class="InputCode">ODS OUTPUT</span> statement to save the results. 
  The <span class="InputCode">ODS OUPUT</span> statement can be placed anywhere 
  before the RUN statement in the procedure step. For example, to save the Statistics 
  object:</p>
<p> <span class="InputCode">proc ttest;<br/>
  class gender;<br/>
  var score;<br/>
  title 'GOLF SCORES';<br/>
  ods output Statistics = tstats;<br/>
  run;</span></p>
<p>Below is a listing of the fourteen variables and three observations that got 
  written to the TSTATS data set:</p>
<pre>                               Lower           Upper    Lower    UMPULower
Variable  Class           N  CLMean    Mean  CLMean  CLStdDev  CLStdDev

 score    f               7  74.504  76.857  79.211   1.6399    1.5634  
 score    m               7  79.804  82.714  85.625    2.028    1.9335  
 score    Diff (1-2)      _   -9.19  -5.857  -2.524   2.0522    2.0019  

          UMPUUpper     Upper
StdDev    CLStdDev     CLStdDev    StdErr    Minimum    Maximum

2.5448     5.2219       5.6039     0.9619        73         80 
3.1472     6.4579       6.9303     1.1895        78         87 
2.8619     4.5727       4.7242     1.5298         _          _ 
</pre>
<h2>Redirecting Output to HTML, RTF, or PostScript Files</h2>
<p>SAS data sets are not the only place you can redirect output to. You can also 
  redirect output to RTF, HTML, or PostScript formatted files. For example, to 
  redirect the <span class="InputCode">TTEST</span> procedure's output in the 
  example above to an RTF file, add the following two ODS statements to your program:</p>
<p class="InputCode">ods rtf file="tstats.rtf";<br/>
  proc ttest;<br/>
  class gender;<br/>
  var score;<br/>
  title 'GOLF SCORES';<br/>
  run;<br/>
  ods rtf close;</p>
<p>You could then insert the file tstats.rtf into a WORD or WORDPERFECT document 
  and have nicely formatted tables.</p>
<p>To redirect the output to an HTML file, use the <span class="InputCode">ODS 
  HTML</span> statement:</p>
<p class="InputCode">ods html body="tstats.htm";</p>
<p class="InputCode"> proc ttest;<br/>
  class gender;<br/>
  var score;<br/>
  title 'GOLF SCORES';<br/>
  run;</p>
<p class="InputCode">ods html close;</p>
<p>You could then view the output from a browser like Internet Explorer or Netscape.</p>
<p>To create high-resolution printer output, use <span class="InputCode">ODS PRINTER</span> 
  to redirect the output to a PostScript file:</p>
<p class="InputCode">ods printer file="tstats.ps";</p>
<p class="InputCode"> proc ttest;<br/>
  class gender;<br/>
  var score;<br/>
  title 'GOLF SCORES';<br/>
  run;</p>
<p><span class="InputCode">ods printer close;</span><br/>
<br/>
  Use the Linux <span class="InputCode">lpr</span> command to print the file.</p>
<p></p>
<h3>Selecting and Excluding Components of the Output</h3>
<p>You can also use ODS to control which output objects you want included or excluded 
  from your output. For example, to request only the Statistics object in your 
  output:</p>
<p class="InputCode">ods select Statistics;<br/>
  ods html body="tstats.htm";</p>
<p>To exclude the Statistics object from the output:</p>
<p class="InputCode">ods exclude Statistics;<br/>
  ods rtf file="tstats.rtf";</p>
<p>You can also use the <span class="InputCode">ODS SELECT</span> and <span class="InputCode">EXCLUDE</span> 
  statements to control which tables you want displayed in your default listing 
  (<span class="InputCode">.lst</span> file):</p>
<p class="InputCode">ods listing;<br/>
  ods exclude Statistics;<br/>
  proc ttest;<br/>
  class gender;<br/>
  var score;<br/>
  title 'GOLF SCORES';<br/>
  run;</p>
<p>Note that the <span class="InputCode">LISTING</span> destination is open by 
  default so the only time you need to include an <span class="InputCode">ODS 
  LISTING</span> statement is when you have used another destination like RTF 
  or HTML previously in the program.</p>
<p>To summarize what has been illustrated so far, there are currently five destinations 
  you can specify for your procedure output: </p>
<p><span class="InputCode">LISTING</span> the default; traditional .lst file<br/>
<span class="InputCode">OUTPUT</span> SAS data set<br/>
<span class="InputCode">HTML</span> html file<br/>
<span class="InputCode">RTF</span> rtf file for inclusion in Word or WordPerfect<br/>
<span class="InputCode">PRINTER</span> PostScript file for high resolution output</p>
<p>and you use an <span class="InputCode">ODS SELECT</span> or <span class="InputCode">EXCLUDE</span> 
  statement to control which parts of the procedural output you want.</p>
<h2>Customizing The Appearance of Your SAS Output</h2>
<p>With ODS you can change the appearance of most of your SAS output. You can 
  reorder columns, change the style of the output including justification, cell 
  formats, colors, fonts, etc. You can apply these changes to the entire SAS output 
  or just to a particular output object. </p>
<p>SAS uses templates to describe what a particular piece of output is supposed 
  to look like by default. The <span class="InputCode">TEMPLATE</span> procedure 
  enables you to create and edit templates. The <span class="InputCode">TEMPLATE</span> 
  procedure can get complicated very quickly. In this section, only a very simple 
  example is provided. For more detailed information, please refer to the on-line 
  manual at <a href="http://support.sas.com/documentation/onlinedoc/91pdf/sasdoc_913/base_ods_9268.pdf">http://support.sas.com/documentation/onlinedoc/91pdf/sasdoc_913/base_ods_9268.pdf</a>.</p>
<p>In the example below, the output for the means values in the Statistics table 
  of the <span class="InputCode">TTEST</span> procedure is reformatted to display 
  with only one significant digit after the decimal point. By default, three significant 
  digits are displayed. First, the <span class="InputCode">PROC TEMPLATE</span> 
  step is run to define the new template. Second, the <span class="InputCode">TTEST</span> 
  procedure is run redirecting the output to a SAS data set. Third, the reformatted 
  output is displayed using a <span class="InputCode">DATA</span> step:</p>
<p class="InputCode">proc template;<br/>
  edit Stat.TTest.Statistics as test; <br/>
  edit mean; format=8.1; end;<br/>
  end;<br/>
  run;</p>
<p class="InputCode">ods listing close;<br/>
  ods output statistics=tstats; <br/>
  proc ttest;<br/>
  class gender;<br/>
  var score;<br/>
  title 'GOLF SCORES';<br/>
  run;</p>
<p class="InputCode">ods listing;<br/>
  data _null_;<br/>
  set tstats;<br/>
  file print ods=(template='test');<br/>
  put _ODS_;<br/>
  run;</p>
<p>Notes:</p>
<ol>
<li>The first <span class="InputCode">EDIT</span> statement 
    in <span class="InputCode">PROC TEMPLATE</span> is where you name the template 
    you want to modify. The <span class="InputCode">ODS TRACE</span> output (refer 
    to p. 2) provides the name of the template for each object. </li>
<li>The second edit statement specifies that the means in 
    the Statistics table should be formatted with a width of 8 and 1 digit to 
    the right of the decimal point. </li>
<li>The <span class="InputCode">FILE</span> statement in 
    the <span class="InputCode">DATA</span> step tells SAS to print the results 
    to the SAS output file (<span class="InputCode">.lst</span> file) using the 
    "test" template created above in the <span class="InputCode">PROC 
    TEMPLATE</span> call.</li>
<li>The <span class="InputCode">PUT</span> statement tells 
    SAS to write the output using ODS.</li>
</ol>
<p>You can already see how complicated things get just for this simple example. 
    Again, if you need to customize output, you should refer to the complete documentation 
    on ODS.</p>
<!-- #EndEditable -->

</kb_body>
<img_base_url></img_base_url>
</kb_document>
</kb_documents>